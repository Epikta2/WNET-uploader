<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WNET File Transfer</title>
    
    <!-- üîß AGGRESSIVE CACHE BUSTING: Force fresh JavaScript load -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="cache-bust" content="v2.2-emergency-20241225">
    <script>
        // üö® IMMEDIATE CACHE BUST: Force reload if old version detected
        if (!window.WNET_EMERGENCY_OVERRIDE_ACTIVE) {
            console.log('üö® CACHE DETECTED: Forcing hard reload...');
            window.location.reload(true);
        }
        window.WNET_EMERGENCY_OVERRIDE_ACTIVE = true;
    </script>
    
    <!-- üöÄ ULTRA-FAST CONNECTION HINTS: Browser-level preconnect -->
    <link rel="preconnect" href="/" crossorigin>
    <link rel="dns-prefetch" href="/">
    <link rel="preload" href="/favicon.ico" as="image">
    <link rel="preload" href="/1x1.png" as="image">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8fafc;
            color: #333;
            min-height: 100vh;
        }
        
        /* Wide white background - only for content area */
        .wide-background {
            background-color: #f8fafc;
            width: 100%;
            margin: 0;
            padding: 0;
        }
        
        .background-white {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            width: 80%;
            margin: 0px auto 0px auto;
        }
        
        .container {
            max-width: 600px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.06);
            padding: 0;
            text-align: center;
            position: relative;
        }
        
        /* Wide white background that extends beyond container - only for content sections */
        .container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100vw;
            height: 100%;
            background: white;
            z-index: -1;
            border-radius: 16px;
        }
        
        /* Tab Navigation */
        .tabs {
            display: flex;
            border-bottom: 1px solid #e2e8f0;
            border-radius: 16px 16px 0 0;
            background: #f8fafc;
        }
        .tab {
            flex: 1;
            padding: 18px;
            background: none;
            border: none;
            font-size: 15px;
            font-weight: 600;
            color: #000;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 16px 16px 0 0;
        }
        .tab:first-child {
            border-radius: 16px 0 0 0;
        }
        .tab:last-child {
            border-radius: 0 16px 0 0;
        }
        .tab.active {
            background: white;
            color: #4A90E2;
            border-bottom: 2px solid #4A90E2;
            margin-bottom: -1px;
        }
        .tab:hover:not(.active) {
            background: #f1f5f9;
            color: #475569;
        }
        
        /* Content area */
        .content {
            padding: 60px 40px 40px 40px;
        }
        
        .header {
            margin-bottom: 30px;
        }
        .title {
            font-size: 22px;
            color: #1a1a1a;
            margin-bottom: 12px;
            font-family: Arial, sans-serif;
            font-weight: 600;
        }
        .subtitle {
            font-size: 16px;
            color: #000;
            margin-bottom: 30px;
            font-weight: 400;
        }
        
        /* Large drag and drop area */
        .upload-zone {
            border: 2px dashed #d1d5db;
            border-radius: 12px;
            background: #f9fafb;
            padding: 45px 40px 40px 40px;
            margin-bottom: 0px;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .upload-zone:hover {
            border-color: #1890ff;
            background: #f0f8ff;
        }
        .upload-zone.dragover {
            border-color: #1890ff;
            background: #e6f3ff;
            transform: scale(1.02);
        }
        .upload-zone.has-files {
            padding: 40px;
            justify-content: flex-start;
            align-items: stretch;
        }
        .upload-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
        }
        .upload-icon {
            font-size: 48px;
            color: #1890ff;
            margin-bottom: 20px;
        }
        .upload-text {
            font-size: 20px;
            color: #374151;
            margin-bottom: 8px;
            font-weight: 500;
        }
        .upload-subtext {
            font-size: 14px;
            color: #6b7280;
            margin-bottom: 30px;
        }
        
        /* Files inside upload zone */
        .upload-zone-files {
            width: 100%;
            margin-top: 20px;
        }
        .upload-zone-file {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .upload-zone-file:last-child {
            margin-bottom: 0;
        }
        .upload-zone-file-info {
            flex: 1;
        }
        .upload-zone-file-name {
            font-weight: 500;
            color: #374151;
            margin-bottom: 4px;
            word-break: break-word;
        }
        .upload-zone-file-size {
            font-size: 14px;
            color: #6b7280;
        }
        .upload-zone-file-remove {
            background: none;
            border: none;
            cursor: pointer;
            color: #9ca3af;
            font-size: 18px;
            padding: 4px;
            margin-left: 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        .upload-zone-file-remove:hover {
            color: #ef4444;
            background: #fef2f2;
        }
        
        /* Hidden file inputs */
        .file-inputs {
            display: none;
        }
        
        /* Action buttons */
        .action-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 20px;
        }
        .btn {
            padding: 10px 20px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
            color: #000;
            display: inline-block;
            text-align: center;
        }
        .btn:hover {
            border-color: #4A90E2;
            color: #4A90E2;
        }
        .btn-primary {
            background: white;
            color: #000;
            border-color: #e2e8f0;
            font-size: 13px;
            padding: 10px 40px;
            font-weight: 500;
        }
        .btn-primary:hover {
            background: white;
            border-color: #4A90E2;
            color: #4A90E2;
        }
        .btn-primary:disabled {
            background: #f8fafc;
            border-color: #e2e8f0;
            color: #cbd5e1;
            cursor: not-allowed;
        }
        .btn-primary:disabled:hover {
            background: #f8fafc;
            border-color: #e2e8f0;
            color: #cbd5e1;
        }
        
        /* Selected files display */
        .selected-files {
            margin-top: 20px;
            text-align: left;
            display: none;
        }
        .selected-file {
            padding: 12px 16px;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .file-info {
            flex: 1;
        }
        .file-name {
            font-weight: 500;
            color: #374151;
        }
        .file-size {
            font-size: 12px;
            color: #6b7280;
        }
        
        /* Progress Section */
        .progress-container {
            position: relative;
            width: 280px;
            height: 280px;
            margin: 0 auto 40px auto;
        }
        .progress-circle {
            width: 280px;
            height: 280px;
            border-radius: 50%;
            background: #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        .progress-circle::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 280px;
            height: 280px;
            border-radius: 50%;
            background: conic-gradient(
                #4A90E2 0deg,
                #4A90E2 calc(var(--progress) * 3.6deg),
                transparent calc(var(--progress) * 3.6deg),
                transparent 360deg
            );
        }
        .progress-circle::after {
            content: '';
            position: absolute;
            width: 272px;
            height: 272px;
            background: white;
            border-radius: 50%;
            top: 4px;
            left: 4px;
        }
        .progress-content {
            position: relative;
            z-index: 3;
            text-align: center;
            padding: 30px;
            width: 180px;
        }
        .progress-percentage {
            font-size: 20px;
            font-weight: 700;
            color: #4A90E2;
            margin-bottom: 15px;
            line-height: 1.2;
        }
        .time-remaining-label {
            font-size: 11px;
            color: #000;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 500;
        }
        .time-remaining {
            font-size: 20px;
            font-weight: 700;
            color: #1a1a1a;
            line-height: 1;
        }
        
        .file-status {
            font-size: 14px;
            color: #666;
            margin-bottom: 30px;
        }
        
        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 35px;
            text-align: center;
            max-width: 380px;
            margin-left: auto;
            margin-right: auto;
        }
        .stat-item {
            padding: 18px;
            background: #f8fafc;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
        }
        .stat-label {
            font-size: 13px;
            color: #000;
            margin-bottom: 6px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .stat-value {
            font-size: 14px;
            font-weight: 700;
            color: #1e293b;
        }
        
        /* Brand */
        
        
        /* Hidden states */
        .upload-section.hidden { display: none; }
        .progress-section.hidden { display: none; }
        .download-section.hidden { display: none; }
        

        
        /* Navigation */
        .nav-button {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .nav-button:hover {
            background: #e5e7eb;
        }
        
        /* Download section - simplified */
        .download-section {
            margin-top: 0;
            padding-top: 0;
        }
        
        /* Ensure download section has same padding as upload */
        .download-section.content {
            padding: 60px 40px 10px 40px;
        }
        
        .download-section h3 {
            font-size: 24px;
            margin-bottom: 30px;
            color: #1a1a1a;
            font-weight: 300;
        }
        .file-list {
            text-align: left;
            margin-top: 30px;
            margin-bottom: 40px; /* Add bottom spacing to match upload section */
        }
        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; /* Changed from center to flex-start for better alignment */
            padding: 20px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 12px;
            background: white;
            transition: all 0.2s;
            min-height: 80px; /* Ensure consistent height */
        }
        .file-item:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .file-info {
            flex: 1;
            margin-right: 20px; /* Add space between file info and button */
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-height: 40px; /* Ensure minimum height for content */
        }
        .file-name {
            font-weight: 500;
            color: #374151;
            margin-bottom: 5px;
            word-break: break-word; /* Handle long filenames */
            line-height: 1.4;
        }
        .file-size {
            font-size: 12px;
            color: #6b7280;
            margin-top: auto; /* Push to bottom of file-info */
        }
        .download-btn {
            padding: 10px 20px;
            background: white;
            color: #000;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            align-self: center;
            height: fit-content;
        }
        .download-btn:hover {
            background: white;
            border-color: #4A90E2;
            color: #4A90E2;
        }
        .download-btn:disabled {
            background: #f3f4f6;
            color: #9ca3af;
            border-color: #e5e7eb;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .download-btn:disabled:hover {
            background: #f3f4f6;
            color: #9ca3af;
            border-color: #e5e7eb;
        }
        
        /* Download Progress */
        .download-progress.hidden { display: none; }
        
        .brand {
           margin: 20px auto -5px auto;
           display: flex;
           justify-content: center;
           align-items: center;
           
        }

        /* Progress section specific styling */
        .progress-section .header {
            margin-bottom: 30px;
        }
        .progress-section .title {
            font-size: 24px;
            margin-bottom: 8px;
        }
        .progress-section .subtitle {
            font-size: 14px;
            margin-bottom: 20px;
        }

        /* Download progress styling - consistent with upload */
        .download-progress .progress-container {
            margin-bottom: 30px;
        }

        /* Completion Screen */
        .completion-screen {
            display: none;
            text-align: center;
            padding: 40px;
        }
        .completion-screen:not(.hidden) {
            display: block;
        }
        .completion-circle {
            width: 280px;
            height: 280px;
            border-radius: 50%;
            background: #22c55e;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 30px auto;
            position: relative;
        }
        .completion-circle::after {
            content: '';
            position: absolute;
            width: 272px;
            height: 272px;
            background: white;
            border-radius: 50%;
            top: 4px;
            left: 4px;
        }
        .completion-checkmark {
            font-size: 60px;
            color: #22c55e;
            font-weight: 300;
            position: relative;
            z-index: 3;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        .completion-message {
            font-size: 18px;
            color: #6b7280;
            margin-bottom: 8px;
            font-weight: 500;
        }
        .completion-time {
            font-size: 16px;
            color: #1f2937;
            font-weight: 700;
            margin-bottom: 20px;
        }
        .completion-files {
            font-size: 16px;
            color: #6b7280;
            margin-bottom: 40px;
        }
        
        /* Brand logo in completion screen */
        
        
        /* Download Progress */
        .download-progress.hidden { display: none; }
        
        /* Download Completion Bar */
        .download-completion-bar.hidden { display: none; }
        .download-completion-bar {
            margin-bottom: 20px;
        }
        .completion-container {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 20px;
            background: #f8fdf9;
            border: 1px solid #d1fae5;
            border-radius: 12px;
        }
        .completion-circle-small {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #22c55e;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            flex-shrink: 0;
        }
        .completion-circle-small::after {
            content: '';
            position: absolute;
            width: 42px;
            height: 42px;
            background: white;
            border-radius: 50%;
            top: 4px;
            left: 4px;
        }
        .completion-checkmark-small {
            font-size: 24px;
            color: #22c55e;
            font-weight: 600;
            position: relative;
            z-index: 3;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        .completion-content {
            flex: 1;
        }
        .completion-message-small {
            font-size: 16px;
            color: #065f46;
            font-weight: 600;
            margin-bottom: 4px;
        }
        .completion-stats {
            font-size: 14px;
            color: #6b7280;
        }
        .btn-small {
            background: none;
            border: none;
            font-size: 18px;
            color: #9ca3af;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        .btn-small:hover {
            background: #f3f4f6;
            color: #6b7280;
        }
    </style>
</head>
<body>
    <div class="wide-background">
        <div class="background-white">
    <div class="container">
        <!-- Tab Navigation -->
        <div class="tabs">
            <button class="tab active" id="uploadTab" onclick="switchTab('upload')">Upload Files</button>
            <button class="tab" id="downloadTab" onclick="switchTab('download')">Downloads</button>
        </div>
        
        <!-- Upload Section -->
        <div class="upload-section content" id="uploadSection">
            <div class="header">
                <div class="title">WNET File Transfer</div>
                    <div class="subtitle">Upload large video files securely</div>
            </div>
            
            <div class="upload-zone" id="uploadZone" onclick="document.getElementById('fileInput').click()">
                    <div class="upload-content" id="uploadContent">
                <div class="upload-icon">‚¨á</div>
                <div class="upload-text">Drag Files/Folders Here</div>
                    </div>
                    <div class="upload-zone-files" id="uploadZoneFiles"></div>
            </div>
            
            <div class="file-inputs">
                <input type="file" id="fileInput" accept=".mp4,.mov,.avi,.mkv,.webm,.wmv,.mxf,video/*" multiple>
                <input type="file" id="folderInput" webkitdirectory multiple>
            </div>
            
            <div class="selected-files" id="selectedFiles"></div>
            
                <div style="text-align: center; padding-top:20px;">
            <button class="btn btn-primary" id="sendButton" onclick="uploadFile()" disabled>Upload</button>
                </div>
        </div>

        <!-- Progress Section -->
        <div class="progress-section content hidden" id="progressSection">
            <div class="header">
                <div class="title">WNET File Transfer</div>
                <div class="subtitle">Upload and download large video files securely</div>
            </div>

            <div class="progress-container">
                <div class="progress-circle" id="progressCircle">
                    <div class="progress-content">
                            <div class="progress-percentage" id="progressPercentage">0% completed</div>
                            <div class="time-remaining-label">Time elapsed</div>
                        <div class="time-remaining" id="timeRemaining">00:00:00</div>
                            <div class="time-remaining-label" style="margin-top: 15px;">Time remaining</div>
                            <div class="time-remaining" id="timeRemainingETA">Calculating...</div>
                    </div>
                </div>
            </div>


            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">Speed</div>
                    <div class="stat-value" id="uploadSpeed">0.00 Mbps</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Uploaded</div>
                    <div class="stat-value" id="uploadProgress">0 GB / 0 GB</div>
                </div>
            </div>

            <div class="action-buttons">
                    <button class="btn" onclick="cancelUpload()">Cancel Upload</button>
            </div>
        </div>

            <!-- Completion Section -->
            <div class="completion-screen content hidden" id="completionSection">
            <div class="header">
                    <div class="title">WNET File Transfer</div>
                    <div class="subtitle">Upload and download large video files securely</div>
            </div>
            
                <div class="completion-circle">
                    <div class="completion-checkmark">‚úì</div>
                </div>

                <div class="completion-time" id="completionTime">Total time 00:00:00</div>

                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">Speed</div>
                        <div class="stat-value" id="completionSpeed">0.00 Mbps</div>
                </div>
                    <div class="stat-item">
                        <div class="stat-label">Uploaded</div>
                        <div class="stat-value" id="completionUploaded">0 GB</div>
                    </div>
                </div>

                <div class="action-buttons" style="margin-top: 40px;">
                    <button class="btn" onclick="startNewUpload()">Upload More</button>
                </div>
                
            </div>

            <!-- Download Section -->
            <div class="download-section content hidden" id="downloadSection">
                <div class="header">
                    <div class="title">Available Downloads</div>
                    <div class="subtitle">Download your transferred files</div>
            </div>

            <!-- Download Progress -->
            <div class="download-progress hidden" id="downloadProgressSection">
                <div class="progress-container">
                    <div class="progress-circle" id="downloadProgressCircle">
                        <div class="progress-content">
                                <div class="progress-percentage" id="downloadProgressPercentage">0% completed</div>
                                <div class="time-remaining-label">Time elapsed</div>
                            <div class="time-remaining" id="downloadTimeRemaining">00:00:00</div>
                                <div class="time-remaining-label" style="margin-top: 15px;">Time remaining</div>
                                <div class="time-remaining" id="downloadTimeRemainingETA">Calculating...</div>
                        </div>
                    </div>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">Speed</div>
                        <div class="stat-value" id="downloadSpeed">0.00 Mbps</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Downloaded</div>
                        <div class="stat-value" id="downloadProgressText">0 GB / 0 GB</div>
                    </div>
                </div>
            </div>
                
                <!-- Download Completion Bar - Above Refresh Button -->
                <div class="download-completion-bar hidden" id="downloadCompletionSection">
                    <div class="completion-container">
                        <div class="completion-circle-small">
                            <div class="completion-checkmark-small">‚úì</div>
                        </div>
                        <div class="completion-content">
                            <div class="completion-message-small">Download completed successfully!</div>
                            <div class="completion-stats" id="downloadCompletionStats">
                                <span id="downloadCompletionTime">Total time: 00:00:00</span> ‚Ä¢ 
                                <span id="downloadCompletionSpeed">0.00 Mbps avg</span> ‚Ä¢ 
                                <span id="downloadCompletionSize">0 GB</span>
                            </div>
                        </div>
                        <button class="btn-small" onclick="startNewDownload()">√ó</button>
                    </div>
                </div>
                
                <button class="btn btn-primary" onclick="refreshFileList()">Refresh File List</button>
                
                <div class="file-list" id="fileList">
                    <div style="text-align: center; color: #888; padding: 40px;">
                        Loading files...
                </div>
            </div>
        </div>

        <!-- Download Completion Screen -->
        <div class="completion-screen content hidden" id="downloadCompletionScreen">
            <div class="header">
                <div class="title">Available Downloads</div>
                <div class="subtitle">Download your transferred files</div>
            </div>
            
            <div class="completion-circle">
                <div class="completion-checkmark">‚úì</div>
            </div>

            <div class="completion-message">Download completed successfully!</div>
            <div class="completion-time" id="downloadCompletionTimeFullScreen">Total time 00:00:00</div>

            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">Speed</div>
                    <div class="stat-value" id="downloadCompletionSpeedFullScreen">0.00 Mbps</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Downloaded</div>
                    <div class="stat-value" id="downloadCompletionDownloaded">0 GB</div>
                </div>
            </div>
            
            <!-- Show file list below completion -->
            <div style="margin-top: 40px;">
                <button class="btn btn-primary" onclick="refreshFileList()">Refresh File List</button>
                
                <div class="file-list" id="completionFileList">
                    <div style="text-align: center; color: #888; padding: 40px;">
                        Loading files...
                    </div>
                </div>
            </div>
            
        </div>

        </div>

        <div class="brand">
        <img src="https://wavelengthpublicmedia.org/wp-content/themes/wnet-theme/assets/images/logo.jpg" width="200px" alt="WNET" />
        </div>
    </div>
    
    <!-- Brand logo outside all containers, centered on full page -->
   

    <!-- Hidden elements for legacy compatibility -->
    <div style="display: none;">
        <div id="uploadProgressContainer"></div>
        <progress id="uploadProgress" value="0" max="100"></progress>
        <span id="uploadProgressText"></span>
        <div id="uploadTimer">00:00:00</div>
        <div id="uploadFileSize"></div>
        <div id="uploadETA"></div>
        <div id="downloadProgressContainer"></div>
        <progress id="downloadProgress" value="0" max="100"></progress>
        <span id="downloadProgressText"></span>
        <div id="downloadTimer">00:00:00</div>
        <div id="downloadSavingMsg"></div>
        <div id="downloadETA"></div>
    </div>

    <script>
        // Replace these with your actual R2 credentials and bucket name
        const R2_ACCOUNT_ID = 'YOUR_ACCOUNT_ID';
        const R2_ACCESS_KEY_ID = 'YOUR_ACCESS_KEY_ID';
        const R2_SECRET_ACCESS_KEY = 'YOUR_SECRET_ACCESS_KEY';
        const R2_BUCKET_NAME = 'YOUR_BUCKET_NAME';

        // Set your R2 Public Development URL base here
        const R2_PUBLIC_URL_BASE = 'https://pub-2078a13599a74a339318b659bb618965.r2.dev'; // <-- Your actual public URL base

        // Connection quality detection and chunk size configuration
        const CHUNK_SIZES = {
            slow: 100 * 1024 * 1024,    // 100MB chunks for slow connections (increased from 50MB)
            medium: 200 * 1024 * 1024,  // 200MB chunks for medium connections (increased from 100MB)
            fast: 500 * 1024 * 1024     // 500MB chunks for fast connections (increased from 250MB)
        };

        let currentChunkSize = CHUNK_SIZES.medium; // Default to medium
        let uploadRetryCount = 0;
        const MAX_RETRIES = 3;

        let uploadTimerInterval = null;
        let downloadTimerInterval = null;
        let lastUploadTime = 0;
        let lastDownloadTime = 0;
        let lastUploadSize = 0;
        let lastDownloadSize = 0;
        let lastEtaUpdate = 0; // Track last ETA update time
        let uploadStartTime = 0; // Track upload start time for avg speed
        let etaHistory = []; // Store ETA history for smoothing
        let speedHistory = []; // Store speed history for smoothing
        let lastLoaded = 0; // Track last loaded bytes for resume functionality

        // Global Performance tracking object
        const performanceTracker = {
            startTime: 0,
            partTimes: [],
            parallelPeaks: 0,
            retryCount: 0,
            bytesPerSecond: [],
            connectionUtilization: [],
            disabled: false, // Add disabled flag
            
            reset: function() {
                this.startTime = Date.now();
                this.partTimes = [];
                this.parallelPeaks = 0;
                this.retryCount = 0;
                this.bytesPerSecond = [];
                this.connectionUtilization = [];
                this.disabled = false; // Reset disabled flag
            },
            
            showPerformancePanel: function() {
                if (this.disabled) return;
                const panel = document.getElementById('uploadPerformance');
                if (panel) panel.style.display = 'block';
            },
            
            updateConnection: function(info) {
                if (this.disabled) return;
                const msg = `üîó Connection: ${info.latency}ms latency, ${(info.bandwidth * 8).toFixed(2)} Mbps bandwidth (${info.type})`;
                console.log(msg);
                const elem = document.getElementById('perfConnection');
                if (elem) elem.textContent = msg;
            },
            
            updateStrategy: function(partSize, maxParallel, partCount) {
                if (this.disabled) return;
                const msg = `üì¶ Strategy: ${partCount} parts √ó ${(partSize/1024/1024).toFixed(1)}MB, ${maxParallel} max parallel`;
                console.log(msg);
                const elem = document.getElementById('perfStrategy');
                if (elem) elem.textContent = msg;
            },
            
            logPartComplete: function(partNum, bytes, timeMs, parallel) {
                // Don't log if disabled or upload was cancelled
                if (this.disabled || isUploadCancelled) {
                    return;
                }
                
                const speed = (bytes / 1024 / 1024) / (timeMs / 1000);
                const speedMbps = speed * 8; // Convert to Mbps
                this.partTimes.push({ part: partNum, timeMs, speed, parallel });
                this.parallelPeaks = Math.max(this.parallelPeaks, parallel);
                
                const msg = `‚úÖ Part ${partNum}: ${(timeMs/1000).toFixed(1)}s, ${speedMbps.toFixed(2)} Mbps, ${parallel} active`;
                console.log(msg);
                
                // Add to UI (show last 10 parts)
                const elem = document.getElementById('perfParts');
                if (elem) {
                    const div = document.createElement('div');
                    div.textContent = msg;
                    div.style.color = speedMbps > 24 ? '#28a745' : speedMbps > 8 ? '#ffc107' : '#dc3545'; // Adjusted thresholds for Mbps
                    elem.appendChild(div);
                    
                    // Keep only last 10 entries
                    while (elem.children.length > 10) {
                        elem.removeChild(elem.firstChild);
                    }
                    elem.scrollTop = elem.scrollHeight;
                }
            },
            
            logProgress: function(completed, total, totalBytes, elapsedMs) {
                // Don't log if disabled or upload was cancelled
                if (this.disabled || isUploadCancelled) {
                    return;
                }
                
                const progress = (completed / total * 100).toFixed(1);
                const avgSpeed = (totalBytes / 1024 / 1024) / (elapsedMs / 1000);
                const avgSpeedMbps = avgSpeed * 8; // Convert to Mbps
                const eta = ((total - completed) * (elapsedMs / completed)) / 1000;
                
                const msg = `üìä Progress: ${progress}% (${completed}/${total} parts), ${avgSpeedMbps.toFixed(2)} Mbps avg, ETA: ${eta.toFixed(0)}s`;
                console.log(msg);
                
                const elem = document.getElementById('perfProgress');
                if (elem) elem.textContent = msg;
            },
            
            logRetry: function(partNum, attempt, maxAttempts, delay, error) {
                if (this.disabled) return;
                this.retryCount++;
                const msg = `‚ö†Ô∏è Part ${partNum} retry ${attempt}/${maxAttempts} after ${delay}ms: ${error}`;
                console.log(msg);
                
                const elem = document.getElementById('perfParts');
                if (elem) {
                    const div = document.createElement('div');
                    div.textContent = msg;
                    div.style.color = '#dc3545';
                    elem.appendChild(div);
                    elem.scrollTop = elem.scrollHeight;
                }
            },
            
            logFinalSummary: function(totalTime, partCount, partSize) {
                if (this.disabled) return;
                if (this.partTimes.length === 0) return; // No parts completed
                
                const avgPartTime = this.partTimes.reduce((a, b) => a + b.timeMs, 0) / this.partTimes.length;
                const fastestPart = Math.min(...this.partTimes.map(p => p.timeMs));
                const slowestPart = Math.max(...this.partTimes.map(p => p.timeMs));
                const avgPartSpeed = this.partTimes.reduce((a, b) => a + b.speed, 0) / this.partTimes.length;
                const avgPartSpeedMbps = avgPartSpeed * 8; // Convert to Mbps
                
                const summary = [
                    `üèÅ UPLOAD COMPLETE - Performance Summary:`,
                    `üìà Total time: ${(totalTime/1000).toFixed(1)}s`,
                    `‚ö° Peak parallel: ${this.parallelPeaks} connections`,
                    `üîÑ Retries: ${this.retryCount}`,
                    `üìä Part timing: avg=${(avgPartTime/1000).toFixed(1)}s, fastest=${(fastestPart/1000).toFixed(1)}s, slowest=${(slowestPart/1000).toFixed(1)}s`,
                    `üöÄ Part speeds: avg=${avgPartSpeedMbps.toFixed(2)} Mbps per part`,
                    `üí° ${this.parallelPeaks < 50 ? 'Browser/network limited connections' : 'Reached high parallelism'}`
                ];
                
                // üîß RELIABILITY IMPROVEMENT - Add error and bandwidth info
                if (this.errorLog && this.errorLog.length > 0) {
                    const errorTypes = [...new Set(this.errorLog.map(e => e.error))];
                    summary.push(`‚ö†Ô∏è Error types: ${errorTypes.join(', ')}`);
                }
                
                summary.forEach(line => console.log(line));
                
                const elem = document.getElementById('perfSummary');
                if (elem) {
                    elem.innerHTML = summary.map(line => `<div style="margin:2px 0;">${line}</div>`).join('');
                }
            }
        };

        // Configuration flag for new upload speed detection
        const USE_UPLOAD_SPEED_DETECTION = true; // Re-enabled with CORS fixes

        // Hybrid speed detection: Use latency estimate + test file validation
        async function detectRealUploadSpeed() {
            try {
                console.log(`üß™ Running quick upload validation test...`);
                
                // Quick 3MB single connection test for validation (better for ~88 Mbps connections)
                const testSize = 3 * 1024 * 1024; // 3MB for meaningful test on fast connections
                const testResult = await performSingleSpeedTest(testSize, 1, 1);
                
                if (testResult && testResult > 5) {
                    console.log(`‚úÖ Upload validation: ${testResult.toFixed(1)} Mbps measured`);
                    return testResult;
                } else {
                    console.warn('‚ö†Ô∏è Upload test gave low result, using latency-based fallback');
                    return null;
                }
                
            } catch (error) {
                console.warn('‚ùå Upload validation failed, using latency-based fallback:', error.message);
                return null;
            }
        }
        
        // Helper function for single speed test
        async function performSingleSpeedTest(testSize, attempt, connectionNum) {
            // Create test chunk
            const testChunk = new Blob([new ArrayBuffer(testSize)]);
            
            // Get test upload URL (use same endpoint as main upload)
            const testFileName = `test-upload-${Date.now()}-${connectionNum}.bin`;
            const presignResponse = await fetch('/api/presign', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    fileName: testFileName,
                    contentType: 'application/octet-stream'
                })
            });
            
            if (!presignResponse.ok) throw new Error('Failed to get test upload URL');
            const { url } = await presignResponse.json();
            
            // Measure upload speed
            const startTime = Date.now();
            
            const speedMbps = await new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                const timeout = setTimeout(() => {
                    xhr.abort();
                    reject(new Error('Test upload timeout'));
                }, 15000); // 15 second timeout for larger test file
                
                xhr.open('PUT', url, true);
                xhr.setRequestHeader('Content-Type', 'application/octet-stream');
                // Remove custom headers that might cause CORS issues
                
                xhr.onload = function() {
                    clearTimeout(timeout);
                    if (xhr.status >= 200 && xhr.status < 300) {
                        const uploadTime = (Date.now() - startTime) / 1000; // seconds
                        const speedMbps = (testSize * 8) / (uploadTime * 1000000); // Convert to Mbps
                        console.log(`‚úÖ Connection ${connectionNum} speed: ${speedMbps.toFixed(2)} Mbps (${(testSize/1024/1024).toFixed(1)}MB in ${uploadTime.toFixed(1)}s)`);
                        resolve(speedMbps);
                    } else {
                        reject(new Error(`Test upload failed: ${xhr.status}`));
                    }
                };
                
                xhr.onerror = function() {
                    clearTimeout(timeout);
                    reject(new Error('Test upload network error'));
                };
                
                xhr.send(testChunk);
            });
            
            return speedMbps;
        }

        // Enhanced connection quality detection - considers both latency AND bandwidth
        async function detectConnectionQuality() {
            try {
                // Step 1: Measure latency with multiple samples for reliability
                const latencySamples = [];
                for (let i = 0; i < 3; i++) {
                const latencyStart = Date.now();
                const pingResponse = await fetch('/api/ping');
                    const sampleLatency = Date.now() - latencyStart;
                    latencySamples.push(sampleLatency);
                    
                    // Small delay between samples to avoid overwhelming
                    if (i < 2) await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // Use median latency for more reliable detection
                latencySamples.sort((a, b) => a - b);
                const latency = latencySamples[1]; // Median of 3 samples
                
                console.log(`Latency samples: [${latencySamples.join(', ')}]ms, using median: ${latency}ms`);

                // Step 2: Try to measure bandwidth with small test upload
                let bandwidthMBps = 2.5; // Default assumption
                let actualBandwidthTest = null;
                
                try {
                    // Quick bandwidth test (separate from the main validation test)
                    console.log('üß™ Running connection bandwidth test...');
                    const testSize = 1 * 1024 * 1024; // 1MB for quick connection test
                    const testResult = await performSingleSpeedTest(testSize, 1, 'bandwidth');
                    if (testResult && testResult > 1) {
                        actualBandwidthTest = testResult;
                        bandwidthMBps = testResult / 8; // Convert Mbps to MB/s
                        console.log(`‚úÖ Bandwidth test: ${testResult.toFixed(1)} Mbps measured`);
                    } else {
                        throw new Error('Bandwidth test gave low result');
                    }
                } catch (error) {
                    console.log('‚ö†Ô∏è Bandwidth test failed, using latency-based estimation:', error.message);
                }
                
                // More reliable bandwidth estimates - prioritize high-speed detection
                if (latency < 20) {
                    bandwidthMBps = 25;  // ULTRA - Very fast local connections
                } else if (latency < 100) {
                    bandwidthMBps = 20;   // ULTRA - Fast connections with some routing delay
                } else if (latency < 250) {
                    bandwidthMBps = 18;   // ULTRA - Good connections like yours (expanded range)
                } else if (latency < 400) {
                    bandwidthMBps = 12;   // FAST - Moderate connections with geographic routing
                } else if (latency < 600) {
                    bandwidthMBps = 6;    // MODERATE - Slower connections
                } else {
                    bandwidthMBps = 3;    // SLOW/MOBILE - Very slow connections
                }

                console.log(`Connection test: ${latency}ms latency, ${(bandwidthMBps * 8).toFixed(2)} Mbps bandwidth (${bandwidthMBps > 2.5 ? 'estimated' : 'measured'})`);

                // Step 3: Classify connection type (optimized for high-performance connections)
                let connectionType;
                if (latency < 50 && bandwidthMBps >= 8) {
                    connectionType = 'fast-unlimited'; // Low latency + high bandwidth
                    currentChunkSize = CHUNK_SIZES.fast;
                } else if (latency < 150 && bandwidthMBps >= 5) {
                    connectionType = 'fast-limited'; // Your connection type - good latency + high bandwidth
                    currentChunkSize = CHUNK_SIZES.medium;
                } else if (latency >= 150 && bandwidthMBps > 3) {
                    connectionType = 'slow-unlimited'; // High latency + decent bandwidth
                    currentChunkSize = CHUNK_SIZES.medium;
                } else {
                    connectionType = 'slow-limited'; // High latency + limited bandwidth
                    currentChunkSize = CHUNK_SIZES.slow;
                }

                return { type: connectionType, latency, bandwidth: bandwidthMBps, actualBandwidthTest };
            } catch (error) {
                console.error('Connection quality detection failed:', error);
                currentChunkSize = CHUNK_SIZES.slow;
                return { type: 'slow-limited', latency: 999, bandwidth: 0.5 };
            }
        }

        // üîß RELIABILITY IMPROVEMENTS - Enhanced retry with jitter
        function getRetryDelayWithJitter(attempt) {
            const baseDelay = Math.pow(2, attempt) * 1000; // 1s, 2s, 4s, 8s, 16s...
            const jitter = Math.random() * 1000; // 0-1000ms random jitter
            return Math.min(30000, baseDelay + jitter); // Cap at 30 seconds
        }

        // üîß RELIABILITY IMPROVEMENTS - Enhanced error logging
        function logPartError(partNumber, attempt, status, error, delay = null) {
            const errorType = status || error.code || error.name || 'network';
            const logMessage = delay ? 
                `‚ö†Ô∏è Part ${partNumber} retry ${attempt}/5 in ${(delay/1000).toFixed(1)}s due to: ${errorType}` :
                `‚ùå Part ${partNumber} failed after 5 retries. Last error: ${errorType}`;
            
            console.warn(logMessage);
            
            // Add to performance tracker for analytics
            if (!performanceTracker.errorLog) performanceTracker.errorLog = [];
            performanceTracker.errorLog.push({
                part: partNumber,
                attempt,
                error: errorType,
                timestamp: Date.now()
            });
            
            // Also log to existing retry tracking
            if (delay) {
                performanceTracker.logRetry(partNumber, attempt, 5, delay, errorType);
            }
        }

        // üîß RELIABILITY IMPROVEMENTS - Token expiry detection
        function handleTokenExpiry(error, partNumber) {
            if (error.status === 403 || error.status === 401) {
                console.error(`üîê Token expired for part ${partNumber}. Status: ${error.status}`);
                alert('Your upload session has expired. Please refresh the page and try again.');
                return true; // Indicates token expiry was handled
            }
            return false; // Not a token expiry issue
        }

        // Calculate estimated time remaining
        function calculateETA(loaded, total, speed) {
            if (speed <= 0) return 'Calculating...';
            const remainingBytes = total - loaded;
            const remainingSeconds = remainingBytes / (speed * 1024 * 1024);
            return formatTime(remainingSeconds * 1000);
        }

        // Exponential backoff delay calculation
        function getRetryDelay(retryCount) {
            return Math.min(1000 * Math.pow(2, retryCount), 30000); // Max 30 seconds delay
        }

        // Error recovery and retry mechanism
        async function logUploadFailure(details) {
            try {
                await fetch('/api/log-upload-failure', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(details)
                });
            } catch (e) {
                // Ignore logging errors
            }
        }

        async function handleUploadError(error, file, uniqueFilename, progressBar, progressText, progressContainer, timerDisplay, startTime, partNumber = null) {
            console.error('Upload error:', error);
            // Gather log details
            const connectionQuality = typeof detectConnectionQuality === 'function' ? await detectConnectionQuality() : 'unknown';
            const speed = document.getElementById('uploadSpeed')?.textContent || 'unknown';
            const details = {
                fileName: uniqueFilename,
                fileSize: file.size,
                partNumber,
                error: error.message || error.toString(),
                connectionQuality,
                speed,
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent
            };
            logUploadFailure(details);
            
            if (uploadRetryCount < MAX_RETRIES) {
                const delay = getRetryDelay(uploadRetryCount);
                console.log(`Retrying upload in ${delay/1000} seconds... (Attempt ${uploadRetryCount + 1}/${MAX_RETRIES})`);
                
                if (progressText) progressText.textContent = `Upload failed. Retrying in ${delay/1000} seconds... (Attempt ${uploadRetryCount + 1}/${MAX_RETRIES})`;
                
                await new Promise(resolve => setTimeout(resolve, delay));
                uploadRetryCount++;
                
                // Resume from last successful position
                if (lastLoaded > 0) {
                    console.log(`Resuming from position: ${lastLoaded}`);
                    return await uploadFileWithResume(file, uniqueFilename, lastLoaded, progressBar, progressText, progressContainer, timerDisplay, startTime);
                } else {
                    return await uploadFile();
                }
            } else {
                console.error('Max retries reached. Upload failed.');
                if (progressText) progressText.textContent = 'Upload failed after multiple attempts. Please try again.';
                if (progressContainer) progressContainer.style.display = 'none';
                clearInterval(uploadTimerInterval);
                uploadRetryCount = 0;
                throw new Error('Max retries reached');
            }
        }

        // Upload with resume capability
        async function uploadFileWithResume(file, uniqueFilename, startPosition, progressBar, progressText, progressContainer, timerDisplay, startTime) {
            try {
                const presignResponse = await fetch('/api/presign', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileName: uniqueFilename,
                        contentType: file.type || 'application/octet-stream',
                        startPosition: startPosition
                    })
                });

                if (!presignResponse.ok) {
                    throw new Error('Failed to get pre-signed URL for resume');
                }

                const { url } = await presignResponse.json();
                const xhr = new XMLHttpRequest();
                xhr.open('PUT', url, true);
                xhr.setRequestHeader('Content-Type', file.type || 'application/octet-stream');
                xhr.setRequestHeader('Content-Range', `bytes ${startPosition}-${file.size-1}/${file.size}`);

                let lastLoaded = startPosition;
                let lastTime = Date.now();

                xhr.upload.onprogress = function(event) {
                    if (event.lengthComputable) {
                        const totalLoaded = startPosition + event.loaded;
                        const percent = Math.round((totalLoaded / file.size) * 100);
                        
                        const now = Date.now();
                        const bytesSinceLast = event.loaded - lastLoaded;
                        const timeSinceLast = (now - lastTime) / 1000;
                        if (timeSinceLast > 0 && bytesSinceLast > 0) {
                            const smoothSpeed = calculateSmoothSpeed(bytesSinceLast, timeSinceLast);
                            const speedMbps = smoothSpeed * 8; // Convert to Mbps
                            
                            // Only update ETA every 2 seconds to prevent jumping
                            let etaText = document.getElementById('timeRemaining').textContent;
                            if (now - lastEtaUpdate > 2000) { // Update every 2 seconds
                                etaText = calculateSmoothETA(event.loaded, event.total, smoothSpeed);
                                lastEtaUpdate = now;
                            }
                            
                            // Update circular progress
                            updateCircularProgress(
                                percent,
                                etaText,
                                `${speedMbps.toFixed(2)} Mbps`,
                                event.loaded,
                                event.total
                            );
                        }
                        // Update both local and global lastLoaded for resume functionality
                        lastLoaded = event.loaded; // Global variable for resume
                        const localLastLoaded = event.loaded; // Local variable for this function
                        lastTime = now;
                    }
                };

                return new Promise((resolve, reject) => {
                    xhr.onload = function() {
                        if (xhr.status >= 200 && xhr.status < 300) {
                            uploadRetryCount = 0;
                            resolve();
                        } else {
                            reject(new Error(`Upload failed with status ${xhr.status}`));
                        }
                    };
                    xhr.onerror = function() {
                        reject(new Error('Network error during upload'));
                    };
                    xhr.send(file.slice(startPosition));
                });
            } catch (error) {
                return handleUploadError(error, file, uniqueFilename, progressBar, progressText, progressContainer, timerDisplay, startTime);
            }
        }

        async function uploadFile() {
            // Check for selected files first, then fallback to file input
            let file;
            if (selectedFiles && selectedFiles.length > 0) {
                file = selectedFiles[0];
            } else {
            const fileInput = document.getElementById('fileInput');
                file = fileInput.files[0];
            }

            if (!file) {
                alert('Please select a file first');
                return;
            }

            if (!isValidVideoFile(file)) {
                return;
            }

            // Detect connection quality before starting upload
            const connectionInfo = await detectConnectionQuality();
            console.log(`Connection quality: ${connectionInfo.type}, Chunk size: ${currentChunkSize / (1024 * 1024)}MB`);

            // Generate a unique filename with timestamp
            const uniqueFilename = getTimestampedFilename(file.name);

            // Show progress section
            showProgressSection(file.name);

            let startTime = Date.now();
            if (uploadTimerInterval) clearInterval(uploadTimerInterval);
            uploadTimerInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                document.getElementById('timeRemaining').textContent = formatTime(elapsed);
            }, 100);

            // Use multipart upload for files over 1GB (1 * 1024 * 1024 * 1024 bytes)
            if (file.size > 1 * 1024 * 1024 * 1024) {
                await multipartUpload(file, uniqueFilename, null, null, null, null, startTime);
                return;
            }

            // Step 1: Get pre-signed URL from backend
            let presignResponse;
            try {
                presignResponse = await fetch('/api/presign', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileName: uniqueFilename,
                        contentType: file.type || 'application/octet-stream'
                    })
                });
            } catch (err) {
                hideProgressSection();
                clearInterval(uploadTimerInterval);
                alert('Failed to get pre-signed URL');
                return;
            }

            if (!presignResponse.ok) {
                hideProgressSection();
                clearInterval(uploadTimerInterval);
                alert('Failed to get pre-signed URL');
                return;
            }

            const { url } = await presignResponse.json();

            // Step 2: Upload file directly to R2 using the pre-signed URL
            let lastLoaded = 0;
            let lastTime = Date.now();
            const xhr = new XMLHttpRequest();
            
            // Track this XMLHttpRequest for cancellation
            activeXhrRequests.push(xhr);
            
            xhr.open('PUT', url, true);
            xhr.setRequestHeader('Content-Type', file.type || 'application/octet-stream');

            xhr.upload.onprogress = function (event) {
                // Check for cancellation during progress
                if (isUploadCancelled) {
                    console.log('Regular upload cancelled - aborting');
                    xhr.abort();
                    return;
                }
                
                if (event.lengthComputable) {
                    const percent = Math.round((event.loaded / event.total) * 100);
                    const timeElapsed = Date.now() - startTime;
                    
                    // Real-time speed calculation with smoothing - update less frequently
                    const now = Date.now();
                    const bytesSinceLast = event.loaded - lastLoaded;
                    const timeSinceLast = (now - lastTime) / 1000; // seconds
                    
                    // Only update every 2 seconds for much smoother display
                    if (timeSinceLast >= 2.0 && bytesSinceLast > 0) {
                        const smoothSpeed = calculateSmoothSpeed(bytesSinceLast, timeSinceLast);
                        const speedMbps = smoothSpeed * 8; // Convert to Mbps
                        
                        // Calculate time remaining ETA
                        const eta = calculateSmoothETA(event.loaded, event.total, smoothSpeed);
                        
                        // Update circular progress with elapsed time and ETA
                        updateCircularProgress(
                            percent,
                            formatTime(timeElapsed), // Show elapsed time
                            `${speedMbps.toFixed(2)} Mbps`,
                            event.loaded,
                            event.total,
                            eta // Show time remaining
                        );
                        
                    lastLoaded = event.loaded;
                    lastTime = now;
                    } else if (timeSinceLast < 2.0) {
                        // Still update progress percentage but not speed/time
                        const progressCircle = document.getElementById('progressCircle');
                        progressCircle.style.setProperty('--progress', percent);
                        document.getElementById('progressPercentage').textContent = `${percent}% completed`;
                        
                        const uploadedGB = (event.loaded / (1024 * 1024 * 1024)).toFixed(2);
                        const totalGB = (event.total / (1024 * 1024 * 1024)).toFixed(2);
                        document.getElementById('uploadProgress').textContent = `${uploadedGB} GB / ${totalGB} GB`;
                    }
                }
            };

            xhr.onload = async function () {
                // Remove from active requests when done
                const index = activeXhrRequests.indexOf(xhr);
                if (index > -1) activeXhrRequests.splice(index, 1);
                
                clearInterval(uploadTimerInterval);
                lastUploadTime = Date.now() - startTime;
                lastUploadSize = file.size;
                
                // Show final stats
                if (lastUploadTime > 0 && lastUploadSize > 0) {
                    const mb = lastUploadSize / 1024 / 1024;
                    const sec = lastUploadTime / 1000;
                    const speedMBs = mb / sec; // MB/s
                    const speedMbps = speedMBs * 8; // Convert to Mbps
                    
                    // Show 100% completion with final elapsed time
                    updateCircularProgress(
                        100,
                        formatTime(lastUploadTime), // Show total elapsed time
                        `${speedMbps.toFixed(2)} Mbps`,
                        file.size,
                        file.size
                    );
                }
                
                // Notify backend after upload
                await fetch('/api/notify-upload', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileName: uniqueFilename,
                        size: file.size,
                        contentType: file.type || 'application/octet-stream'
                    })
                });

                setTimeout(() => {
                    const mb = lastUploadSize / 1024 / 1024;
                    const sec = lastUploadTime / 1000;
                    const speedMBs = mb / sec; // MB/s
                    const speedMbps = speedMBs * 8; // Convert to Mbps
                    
                    // Show completion screen instead of alert
                    showCompletionScreen(lastUploadTime, file.size, speedMbps);
                    
                    // Clear selected files after successful upload
                    if (selectedFiles && selectedFiles.length > 0) {
                    selectedFiles = [];
                    updateSelectedFilesDisplay();
                    updateSendButton();
                    }
                }, 2000);
            };

            xhr.onerror = function() {
                // Remove from active requests on error
                const index = activeXhrRequests.indexOf(xhr);
                if (index > -1) activeXhrRequests.splice(index, 1);
                
                // Check if error is due to cancellation
                if (isUploadCancelled) {
                    console.log('Regular upload cancelled during upload');
                    return; // Exit silently for cancellation
                }
                
                handleUploadError(new Error('Network error during upload'), file, uniqueFilename, null, null, null, null, startTime);
            };
            
            xhr.onabort = function() {
                // Remove from active requests on abort
                const index = activeXhrRequests.indexOf(xhr);
                if (index > -1) activeXhrRequests.splice(index, 1);
                
                console.log('Regular upload aborted');
                // Exit silently for cancellation - no error handling needed
            };

            xhr.send(file);
        }

        // Multipart upload logic for files > 1GB
        async function multipartUpload(file, uniqueFilename, progressBar, progressText, progressContainer, timerDisplay, startTime) {
            try {
                // üö® TRIPLE-REDUNDANT OVERRIDE: Force optimal settings at function start
                console.log('üö® EMERGENCY v2.2: Forcing 25MB parts + 20 parallel for high-latency networks');
                window.FORCE_ULTRA_SETTINGS = { partSize: 25 * 1024 * 1024, parallel: 20, maxCap: 24 };
                // Detect connection quality (reuse logic from uploadFile)
                let connectionInfo = { type: 'medium', latency: 200, bandwidth: 2 };
                if (typeof detectConnectionQuality === 'function') {
                    connectionInfo = await detectConnectionQuality();
                }
                
                // Optimized part size and parallelism based on connection type
                let partSize;
                let maxParallel;
                
                // üéØ NEW: Real-world upload speed based profiles (ChatGPT optimized)
                function getUploadProfile(uploadMbps) {
                    if (uploadMbps < 50) {
                        // DSL: Rural, older connections, throttled networks - AGGRESSIVE optimization for sub-20min
                        return { partSize: 12 * 1024 * 1024, parallel: 5, maxCap: 6, tier: 'DSL' };
                    } else if (uploadMbps < 100) {
                        // CABLE: Most suburban broadband, basic fiber
                        return { partSize: 25 * 1024 * 1024, parallel: 8, maxCap: 12, tier: 'CABLE' };
                    } else if (uploadMbps < 500) {
                        // FIBER: Modern high-speed residential
                        return { partSize: 50 * 1024 * 1024, parallel: 12, maxCap: 16, tier: 'FIBER' };
                } else {
                        // ENTERPRISE: Data centers, business, studios
                        return { partSize: 100 * 1024 * 1024, parallel: 16, maxCap: 20, tier: 'ENTERPRISE' };
                    }
                }

                // üéØ LEGACY: Latency-based profiles (preserved as fallback)
                function getLatencyBasedProfile(bandwidth) {
                    if (bandwidth >= 15) {
                        // Ultra Fast (120+ Mbps) - AGGRESSIVE HIGH-LATENCY: 25MB parts for fastest TCP ramp-up
                        return { partSize: 25 * 1024 * 1024, parallel: 20, maxCap: 24, tier: 'ULTRA' };
                    } else if (bandwidth >= 8) {
                        // Very Fast (64+ Mbps) - High-speed broadband  
                        return { partSize: 80 * 1024 * 1024, parallel: 8, maxCap: 15, tier: 'FAST' };
                    } else if (bandwidth >= 4) {
                        // Moderate (32+ Mbps) - Standard broadband
                        return { partSize: 60 * 1024 * 1024, parallel: 6, maxCap: 12, tier: 'MODERATE' };
                    } else if (bandwidth >= 2) {
                        // Slow (16+ Mbps) - Basic broadband/throttled (ChatGPT optimized)
                        return { partSize: 40 * 1024 * 1024, parallel: 4, maxCap: 10, tier: 'SLOW' };
                    } else {
                        // Very Slow (<16 Mbps) - Mobile/rural/VPN (ChatGPT optimized)
                        return { partSize: 40 * 1024 * 1024, parallel: 3, maxCap: 6, tier: 'MOBILE' };
                    }
                }

                // üéØ SMART DUAL-TEST PROFILE SELECTION: Run both tests, use the best result
                async function getOptimalProfile(bandwidth, connectionInfo) {
                    if (!USE_UPLOAD_SPEED_DETECTION) {
                        console.log('üì° Using latency-based detection (legacy mode)');
                        return getLatencyBasedProfile(bandwidth);
                    }

                    // Collect all available speed measurements
                    const latencyEstimate = bandwidth * 8; // Convert to Mbps
                    const bandwidthTest = connectionInfo?.actualBandwidthTest || null; // From detectConnectionQuality
                    
                    console.log(`üì° Latency estimate: ${latencyEstimate.toFixed(1)} Mbps`);
                    if (bandwidthTest) {
                        console.log(`üì° Bandwidth test: ${bandwidthTest.toFixed(1)} Mbps`);
                    }
                    
                    try {
                        // Additional validation test
                        const validationTest = await detectRealUploadSpeed();
                        if (validationTest) {
                            console.log(`üì° Validation test: ${validationTest.toFixed(1)} Mbps`);
                        }
                        
                        // Collect all valid measurements
                        const measurements = [latencyEstimate];
                        if (bandwidthTest && bandwidthTest > 5) measurements.push(bandwidthTest);
                        if (validationTest && validationTest > 5) measurements.push(validationTest);
                        
                        // Use the highest reliable measurement (but cap for safety)
                        const bestSpeed = Math.max(...measurements);
                        const finalSpeed = Math.min(bestSpeed, 150); // Cap at 150 Mbps for safety
                        
                        // For high latency estimates (120+ Mbps), prefer ULTRA profile for proven performance
                        let profile;
                        if (latencyEstimate >= 120 && finalSpeed >= 120) {
                            profile = getLatencyBasedProfile(bandwidth); // Use ULTRA profile
                            console.log(`üöÄ HIGH-SPEED DETECTED: Using ULTRA profile for ${finalSpeed.toFixed(1)} Mbps capability`);
                        } else {
                            profile = getUploadProfile(finalSpeed);
                        }
                        console.log(`üéØ BEST OF ALL TESTS: ${finalSpeed.toFixed(1)} Mbps (latency: ${latencyEstimate.toFixed(1)}, bandwidth: ${bandwidthTest?.toFixed(1) || 'N/A'}, validation: ${validationTest?.toFixed(1) || 'N/A'}) ‚Üí ${profile.tier} (${(profile.partSize/1024/1024).toFixed(0)}MB parts, ${profile.parallel} parallel)`);
                        return profile;
                        
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Using latency-based profile:', error.message);
                        const fallbackProfile = getLatencyBasedProfile(bandwidth);
                        console.log(`üì° LATENCY FALLBACK: ${latencyEstimate.toFixed(1)} Mbps ‚Üí ${fallbackProfile.tier}`);
                        return fallbackProfile;
                    }
                }
                
                const profile = await getOptimalProfile(connectionInfo.bandwidth, connectionInfo);
                
                // üîç DEBUG: Validate profile object
                console.log('üîç Selected upload profile:', profile);
                if (!profile || !profile.partSize || !profile.parallel || !profile.maxCap) {
                    throw new Error(`Invalid profile returned: ${JSON.stringify(profile)}`);
                }
                
                partSize = profile.partSize;
                maxParallel = profile.parallel;
                const maxParallelCap = profile.maxCap;
                
                // üö® AGGRESSIVE HIGH-LATENCY OVERRIDE: Force 25MB parts for ULTRA profile for fastest ramp-up
                if (profile.tier === 'ULTRA' && partSize > 25 * 1024 * 1024) {
                    const oldPartSize = partSize;
                    partSize = 25 * 1024 * 1024; // Force 25MB for fastest TCP ramp-up
                    maxParallel = 20; // Increase parallel to compensate
                    console.log(`üîß AGGRESSIVE OVERRIDE: Forcing 25MB parts + 20 parallel for ULTRA profile (was ${(oldPartSize/1024/1024).toFixed(0)}MB + ${profile.parallel} parallel)`);
                }
                
                // üîç DEBUG: Validate calculated values
                const partsCount = Math.ceil(file.size / partSize);
                console.log('üîç Parts count calculation:', { fileSize: file.size, partSize, partsCount });
                if (partsCount <= 0 || isNaN(partsCount)) {
                    throw new Error(`Invalid parts count: ${partsCount}`);
                }
                
                // üö® EMERGENCY RUNTIME OVERRIDE: Force optimal settings regardless of cache
                if (profile.tier === 'ULTRA') {
                    partSize = 25 * 1024 * 1024; // Force 25MB
                    maxParallel = 20; // Force 20 parallel
                    console.log(`üö® EMERGENCY OVERRIDE: Runtime forcing 25MB parts + 20 parallel for high-latency optimization`);
                }
                
                console.log(`üéØ ${profile.tier} PROFILE: ${(connectionInfo.bandwidth * 8).toFixed(1)} Mbps ‚Üí ${(partSize/1024/1024).toFixed(0)}MB parts, ${maxParallel} parallel (cap: ${maxParallelCap})`);
                
                console.log(`üöÄ UNIVERSAL OPTIMIZATION: ${connectionInfo.type} ‚Üí ${partSize / (1024*1024)}MB parts, ${maxParallel} parallel (${profile.tier} tier)`);
                
                // Show performance panel and log initial info
                performanceTracker.reset();
                performanceTracker.showPerformancePanel();
                performanceTracker.updateConnection(connectionInfo);
                performanceTracker.updateStrategy(partSize, maxParallel, Math.ceil(file.size / partSize));
                
                // üîÑ ENHANCED ADAPTIVE PARALLELISM: 3s monitoring with performance-based adjustments
                let avgPartSpeedHistory = []; // Track per-part speed performance
                let parallelAdjustmentHistory = []; // Track adjustment history
                let lastParallelAdjustment = 0; // Timestamp of last adjustment
                let lastScaleDown = 0; // CHATGPT V2: Cooldown buffer for scale-down operations
                let lowSpeedSamples = 0; // CHATGPT V2: Count consecutive low-speed samples
                let peakPerformanceDetected = false; // Track if we've hit 120+ Mbps
                let optimalParallel = maxParallel; // Remember the sweet spot
                let peakTimestamp = null; // When peak was detected
                let initialPeakThroughput = null; // Store the throughput when peak was first detected
                let lastScaleTime = 0; // Prevent thrashing with minimum intervals
                let peakThroughputHistory = []; // Track peak performance over time
                let throughputSmoothingHistory = []; // For weighted moving average
                let peakResetState = 'stable'; // 'stable', 'warning', 'dropping' - hysteresis state
                let strongPerformanceSamples = 0; // Count samples >90% of peak for reinforcement
                let uploadStartTime = Date.now(); // Track upload start time for initial protection
                
                const adaptiveMonitor = setInterval(async () => {
                    // Only run during active uploads
                    if (!isUploadActive || isUploadCancelled || activeUploads === 0) {
                        console.log('Adaptive monitor stopping - no active upload');
                        clearInterval(adaptiveMonitor);
                        return;
                    }
                    
                        try {
                        // Calculate average part speed from recent completions
                        const recentParts = performanceTracker.partTimes.slice(-10); // Last 10 parts
                        if (recentParts.length >= 3) { // Need at least 3 parts for reliable data
                            const avgPartSpeed = recentParts.reduce((sum, part) => sum + part.speed, 0) / recentParts.length;
                            const avgPartSpeedMbps = avgPartSpeed * 8; // Convert to Mbps
                            
                            avgPartSpeedHistory.push(avgPartSpeed);
                            if (avgPartSpeedHistory.length > 5) avgPartSpeedHistory.shift(); // Keep last 5 readings
                            
                            const smoothedPartSpeed = avgPartSpeedHistory.reduce((a, b) => a + b, 0) / avgPartSpeedHistory.length;
                            const theoreticalThroughput = smoothedPartSpeed * maxParallel * 8; // Theoretical Mbps
                            const currentThroughput = theoreticalThroughput * 0.7; // Realistic sustained throughput (70%)
                            
                            // üéØ PEAK PERFORMANCE DETECTION: Lock in sweet spot when hitting 120+ Mbps sustained (with sufficient data)
                            if (currentThroughput >= 120 && !peakPerformanceDetected && recentParts.length >= 8) {
                                // Only detect peak after we have enough parts for reliable measurement
                                peakPerformanceDetected = true;
                                optimalParallel = maxParallel;
                                peakTimestamp = Date.now();
                                initialPeakThroughput = currentThroughput; // Store the initial peak value
                                console.log(`üéØ PEAK DETECTED: ${currentThroughput.toFixed(0)} Mbps sustained (${theoreticalThroughput.toFixed(0)} Mbps theoretical) at ${maxParallel} parallel - locking sweet spot (${recentParts.length} parts sampled)`);
                            }
                            
                            // üïí NEXT-LEVEL SMART PEAK DECAY: Enhanced with hysteresis, smoothing, reinforcement, and warnings
                            if (peakPerformanceDetected && peakTimestamp && initialPeakThroughput) {
                                const timeSincePeak = Date.now() - peakTimestamp;
                                
                                // üìä ENHANCEMENT 2: Weighted Moving Average for currentThroughput
                                throughputSmoothingHistory.push(currentThroughput);
                                if (throughputSmoothingHistory.length > 5) throughputSmoothingHistory.shift(); // Keep last 5 readings
                                
                                // Calculate weighted average (more recent samples have higher weight)
                                const weights = [0.4, 0.3, 0.15, 0.1, 0.05]; // Most recent gets 40% weight
                                let weightedSum = 0, totalWeight = 0;
                                for (let i = 0; i < throughputSmoothingHistory.length; i++) {
                                    const weight = weights[i] || 0.05;
                                    weightedSum += throughputSmoothingHistory[throughputSmoothingHistory.length - 1 - i] * weight;
                                    totalWeight += weight;
                                }
                                const averageThroughput = weightedSum / totalWeight;
                                
                                // üéØ ENHANCEMENT 1: Hysteresis Band with Two Thresholds
                                const dropThreshold = 0.75 * initialPeakThroughput;    // 75% - reset threshold
                                const recoveryThreshold = 0.85 * initialPeakThroughput; // 85% - maintain threshold
                                const warningThreshold = 0.80 * initialPeakThroughput;  // 80% - warning threshold
                                
                                // üîÑ State machine for hysteresis
                                if (averageThroughput < dropThreshold) {
                                    peakResetState = 'dropping';
                                } else if (averageThroughput > recoveryThreshold) {
                                    peakResetState = 'stable';
                                    strongPerformanceSamples++; // Count strong samples for reinforcement
                                } else if (averageThroughput < warningThreshold && peakResetState === 'stable') {
                                    peakResetState = 'warning';
                                    strongPerformanceSamples = 0; // Reset strong sample counter
                                }
                                
                                // üö® ENHANCEMENT 4: Tier Decay Indicator
                                if (peakResetState === 'warning' && timeSincePeak > 45000) { // 45s warning
                                    console.log(`üìâ PERFORMANCE WARNING: Throughput degrading to ${averageThroughput.toFixed(0)} Mbps (${((averageThroughput/initialPeakThroughput)*100).toFixed(0)}% of peak) ‚Äî possible tier down soon`);
                                }
                                
                                // üéØ ENHANCEMENT 3: Peak Reinforcement
                                if (averageThroughput > 0.9 * initialPeakThroughput && timeSincePeak > 60000 && strongPerformanceSamples >= 3) {
                                    // Extend protection for another 60s when consistently strong
                                    peakTimestamp = Date.now() - 30000; // Reset timer to 30s ago (extends by 30s)
                                    strongPerformanceSamples = 0; // Reset counter
                                    console.log(`üöÄ PEAK REINFORCEMENT: ${averageThroughput.toFixed(0)} Mbps (${((averageThroughput/initialPeakThroughput)*100).toFixed(0)}% of peak) - extending sweet spot protection by 30s`);
                                }
                                
                                // üïí Enhanced reset logic with hysteresis (HIGH-LATENCY OPTIMIZED)
                                if (timeSincePeak > 120000) { // Extended from 60s to 120s for high-latency networks
                                    if (peakResetState === 'dropping') {
                                        // Only reset when in dropping state (below 75% threshold)
                                        peakPerformanceDetected = false;
                                        peakTimestamp = null;
                                        initialPeakThroughput = null;
                                        peakResetState = 'stable';
                                        strongPerformanceSamples = 0;
                                        throughputSmoothingHistory = [];
                                        console.log(`üïí SMART RESET: Performance dropped to ${averageThroughput.toFixed(0)} Mbps (${((averageThroughput/initialPeakThroughput)*100).toFixed(0)}% of peak) - resetting sweet spot`);
                                    } else {
                                        // Performance still acceptable - maintain protection
                                        const statusEmoji = peakResetState === 'stable' ? 'üîí' : '‚ö†Ô∏è';
                                        const statusText = peakResetState === 'stable' ? 'STRONG' : 'MONITORING';
                                        console.log(`${statusEmoji} SWEET SPOT ${statusText}: ${averageThroughput.toFixed(0)} Mbps (${((averageThroughput/initialPeakThroughput)*100).toFixed(0)}% of peak) - keeping protection`);
                                    }
                                }
                            }
                            
                            // üìä THRASHING PROTECTION: Track performance consistency
                            peakThroughputHistory.push(currentThroughput);
                            if (peakThroughputHistory.length > 10) peakThroughputHistory.shift(); // Keep last 10 readings
                            
                            if (peakPerformanceDetected && peakThroughputHistory.length >= 5) {
                                const recentAvg = peakThroughputHistory.slice(-5).reduce((a, b) => a + b, 0) / 5;
                                const peakValue = Math.max(...peakThroughputHistory);
                                
                                // If consistently underperforming (< 90% of peak), consider lowering optimal
                                if (recentAvg < peakValue * 0.9 && maxParallel > optimalParallel) {
                                    optimalParallel = Math.max(optimalParallel - 1, profile.parallel);
                                    console.log(`üìâ PERFORMANCE DECAY: Lowering optimal to ${optimalParallel} (recent: ${recentAvg.toFixed(0)} < 90% of peak: ${peakValue.toFixed(0)})`);
                                }
                            }
                            
                            // üéØ ADAPTIVE RAMP-UP LOGIC: Based on actual part performance
                            const now = Date.now();
                            let shouldAdjust = false;
                            let newParallel = maxParallel;
                            let adjustmentReason = '';
                            
                                                         // üéØ CHATGPT OPTIMIZED: Realistic parallel range based on your data
                             const minParallel = profile.tier === 'MODERATE' ? 6 : Math.max(profile.parallel * 0.67, profile.tier === 'DSL' || profile.tier === 'SLOW' ? 3 : 8); // Tier-specific minimums
                             
                             // üéØ TIER-SPECIFIC ADAPTIVE THRESHOLDS: Optimized for each connection type
                             let rampUpThreshold, rampDownThreshold;
                             
                             if (profile.tier === 'ENTERPRISE' || profile.tier === 'ULTRA') {
                                 rampUpThreshold = 4.0;   // ULTRA: More conservative ramp-up to maintain 130+ Mbps sweet spot
                                 rampDownThreshold = 1.2; // HIGH-LATENCY: Relaxed from 2.0 to 1.2 MB/s to prevent aggressive scaling down
                             } else if (profile.tier === 'FIBER') {
                                 rampUpThreshold = 2.7;   // FIBER: Quicker scaling under stable conditions (ChatGPT optimized)
                                 rampDownThreshold = 1.2; // Wide tolerance for high-speed residential
                             } else if (profile.tier === 'CABLE' || profile.tier === 'FAST') {
                                 rampUpThreshold = 2.0;   // CABLE: Balanced for 50-100 Mbps
                                 rampDownThreshold = 1.2; // Better slowdown detection (ChatGPT optimized)
                             } else if (profile.tier === 'DSL' || profile.tier === 'SLOW') {
                                 rampUpThreshold = 1.5;   // DSL: Conservative for 0-50 Mbps
                                 rampDownThreshold = 0.8; // Better slowdown detection (ChatGPT optimized)
                             } else { // MOBILE or other
                                 rampUpThreshold = 1.2;   // MOBILE: Very conservative
                                 rampDownThreshold = 0.8; // Keep it working
                             }
                             
                             // CHATGPT V2: Track sustained low performance to prevent panic reactions
                             if (smoothedPartSpeed < rampDownThreshold) {
                                 lowSpeedSamples++;
                            } else {
                                 lowSpeedSamples = 0; // Reset if speed recovers
                             }
                             
                             // Ramp UP if parts are performing well for this connection type (but be conservative after peak)
                             if (smoothedPartSpeed > rampUpThreshold && maxParallel < maxParallelCap) {
                                 const now = Date.now();
                                 
                                 if (peakPerformanceDetected && maxParallel >= optimalParallel) {
                                     // Don't ramp up beyond the sweet spot that gave us 120+ Mbps
                                     console.log(`üîí SWEET SPOT PROTECTION: Not ramping beyond ${optimalParallel} parallel (current: ${maxParallel})`);
                                 } else if (now - lastScaleTime < 15000) {
                                     // Minimum 15s interval between scale-ups to prevent thrashing
                                     console.log(`‚è±Ô∏è SCALE COOLDOWN: ${((15000 - (now - lastScaleTime)) / 1000).toFixed(0)}s remaining`);
                            } else {
                                     newParallel = Math.min(maxParallel + (peakPerformanceDetected ? 1 : 3), maxParallelCap); // Smaller steps after peak
                                     shouldAdjust = true;
                                     adjustmentReason = `${profile.tier} RAMP UP: ${smoothedPartSpeed.toFixed(1)} MB/s per part > ${rampUpThreshold} MB/s threshold`;
                                     lowSpeedSamples = 0; // Reset low speed counter on ramp up
                                     lastScaleTime = now; // Update scale timestamp
                                 }
                             }
                             // HIGH-LATENCY V3: Ramp DOWN only after MORE sustained low performance + longer cooldown
                             else if (lowSpeedSamples >= 4 && maxParallel > minParallel && (now - lastScaleDown >= 45000)) { // Increased from 2‚Üí4 samples, 30s‚Üí45s cooldown
                                 newParallel = Math.max(maxParallel - 2, minParallel); // Gentler reduction
                                 shouldAdjust = true;
                                 adjustmentReason = `${profile.tier} SUSTAINED LOW: ${smoothedPartSpeed.toFixed(1)} MB/s per part < ${rampDownThreshold} MB/s for ${lowSpeedSamples} samples`;
                                 lastScaleDown = now; // Update cooldown timer
                                 lowSpeedSamples = 0; // Reset counter after action
                             }
                            
                            // Apply adjustment with throttling (minimum 5s between changes)
                            if (shouldAdjust && (now - lastParallelAdjustment >= 5000)) {
                                console.log(`üîÑ ADAPTIVE ADJUSTMENT: ${adjustmentReason} ‚Üí ${newParallel} parallel (was ${maxParallel})`);
                                
                                maxParallel = newParallel;
                                lastParallelAdjustment = now;
                                
                                // Track adjustment history
                                parallelAdjustmentHistory.push({
                                    timestamp: now,
                                    from: maxParallel,
                                    to: newParallel,
                                    reason: adjustmentReason,
                                    partSpeed: smoothedPartSpeed
                                });
                                
                                // Update performance tracker
                                performanceTracker.updateStrategy(partSize, newParallel, Math.ceil(file.size / partSize));
                            }
                            
                                                         // üö® THROTTLED NETWORK AUTO-FALLBACK: Detect underperforming connections
                             const elapsedMinutes = (Date.now() - uploadStartTime) / 60000;
                             const overallSpeed = (totalUploaded / 1024 / 1024) / ((Date.now() - uploadStartTime) / 1000); // MB/s
                             
                             // Use real detected speed if available, otherwise fall back to latency estimate
                             const realExpectedSpeed = profile.tier === 'DSL' ? 2.4 : // Target 19+ Mbps = 2.4 MB/s (aggressive)
                                                      profile.tier === 'CABLE' ? 3.1 : // 25 Mbps = 3.1 MB/s  
                                                      profile.tier === 'FIBER' ? 6.3 : // 50 Mbps = 6.3 MB/s
                                                      connectionInfo.bandwidth; // ENTERPRISE or fallback
                             
                             // If running for >30s and significantly underperforming, switch to conservative mode
                             if (elapsedMinutes > 0.5 && overallSpeed < (realExpectedSpeed * 0.3)) {
                                 console.log(`üö® THROTTLED NETWORK DETECTED: ${overallSpeed.toFixed(1)} MB/s << expected ${realExpectedSpeed.toFixed(1)} MB/s`);
                                 
                                 // Switch to more conservative settings for throttled/unstable networks
                                 if (partSize < 12 * 1024 * 1024) {
                                     partSize = Math.min(partSize + 2 * 1024 * 1024, 15 * 1024 * 1024); // Larger parts
                                     const newMaxCap = Math.max(maxParallelCap * 0.6, 20); // Reduce max cap
                                     maxParallel = Math.min(maxParallel, newMaxCap);
                                     console.log(`üîÑ FALLBACK MODE: ${(partSize/1024/1024).toFixed(0)}MB parts, ${maxParallel} parallel (throttled network)`);
                                        
                                        // Update performance tracker
                                     performanceTracker.updateStrategy(partSize, maxParallel, Math.ceil(file.size / partSize));
                                 }
                             }
                             
                             // Log current performance every 3 cycles (9s)
                             if (avgPartSpeedHistory.length % 3 === 0) {
                                 const realisticThroughput = smoothedPartSpeed * maxParallel * 8; // Mbps
                                 const sustainedThroughput = realisticThroughput * 0.7; // 70% sustained estimate
                                 console.log(`üìä PERFORMANCE: ${smoothedPartSpeed.toFixed(1)} MB/s per part √ó ${maxParallel} parallel = ${sustainedThroughput.toFixed(0)} Mbps sustained (${realisticThroughput.toFixed(0)} Mbps peak)`);
                             }
                        }
                        
                        } catch (error) {
                        console.warn('Adaptive monitoring failed:', error.message);
                    }
                }, 3000); // Monitor every 3 seconds for faster response
                
                // Adaptive performance tuning - boost for high-performing connections
                let adaptiveBoost = false;
                const performanceCheckInterval = setInterval(() => {
                    if (uploadStartTime > 0) {
                        const elapsedSec = (Date.now() - uploadStartTime) / 1000;
                        const currentSpeed = (totalUploaded / 1024 / 1024) / elapsedSec;
                        
                        // NO BOOST NEEDED - Starting directly with optimal 120 parallel
                        // (Simplified: removed complex ramp-up logic)
                    }
                }, 10000); // Check every 10 seconds
                
                // üöÄ ULTRA-FAST PRE-WARMING: Sub-10s to full speed
                console.log('üöÄ Ultra-fast connection pre-warming...');
                const warmupCount = 32; // Increased to 32 for aggressive high-latency optimization
                const warmupPromises = [];
                
                // üéØ ENHANCED: Multiple preload triggers for connection establishment
                try {
                    const uploadHost = window.location.origin;
                    new Image().src = `${uploadHost}/favicon.ico`;
                    new Image().src = `${uploadHost}/1x1.png`; // Additional tiny asset
                } catch (e) { /* Ignore errors */ }
                
                // üîó AGGRESSIVE PARALLEL WARM-UP: All endpoints, no delays
                const uploadEndpoints = ['/api/multipart/start', '/api/multipart/presign-part'];
                
                for (let i = 0; i < warmupCount; i++) {
                    // Fire all warmup fetches immediately (no staggering for warmup)
                    warmupPromises.push(
                        fetch('/api/ping', { method: 'HEAD', keepalive: true })
                        .catch(() => {}) // Ignore errors, just warming
                    );
                    
                    // Warm up ALL real upload endpoints (not just every 3rd)
                    for (const endpoint of uploadEndpoints) {
                        warmupPromises.push(
                            fetch(endpoint, { method: 'OPTIONS', keepalive: true })
                            .catch(() => {}) // Ignore errors, just warming
                        );
                    }
                }
                
                await Promise.allSettled(warmupPromises);
                console.log('üî• CONNECTIONS PRE-WARMED: Proceeding to launch parts...');
                
                // Provider limits
                const MIN_PART_SIZE = 5 * 1024 * 1024; // 5MB
                const MAX_NUM_PARTS = 10000;
                
                // Step 1: Start multipart upload
                const startRes = await fetch('/api/multipart/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileName: uniqueFilename,
                        contentType: file.type || 'application/octet-stream'
                    })
                });
                if (!startRes.ok) throw new Error('Failed to start multipart upload');
                const { uploadId } = await startRes.json();

                // Persistent checkpointing
                const checkpointKey = `multipart_${uniqueFilename}_${uploadId}`;
                let checkpoint = localStorage.getItem(checkpointKey);
                let completedPartsCheckpoint = checkpoint ? JSON.parse(checkpoint) : [];
                
                // Adjust part size upward if too many parts
                let partCount = Math.ceil(file.size / partSize);
                if (partCount > MAX_NUM_PARTS) {
                    partSize = Math.ceil(file.size / MAX_NUM_PARTS);
                    // Ensure partSize is at least MIN_PART_SIZE
                    if (partSize < MIN_PART_SIZE) partSize = MIN_PART_SIZE;
                    partCount = Math.ceil(file.size / partSize);
                }

                let parts = [];
                let completedParts = 0;
                let totalUploaded = 0; // Track total bytes uploaded across all parts
                let lastReportedTime = Date.now();
                let lastReportedBytes = 0;
                const uploadedBytesPerPart = Array(partCount).fill(0); // Track per-part progress

                // Prepare all part blobs and numbers with error handling
                const partBlobs = [];
                for (let partNumber = 1; partNumber <= partCount; partNumber++) {
                    try {
                    const start = (partNumber - 1) * partSize;
                    const end = Math.min(start + partSize, file.size);
                        const blob = file.slice(start, end);
                        
                        // Validate blob
                        if (!blob || blob.size === 0) {
                            throw new Error(`Invalid blob for part ${partNumber}: size=${blob?.size}`);
                        }
                        
                    partBlobs.push({
                        partNumber,
                            blob,
                        index: partNumber - 1
                    });
                    } catch (error) {
                        console.error(`Failed to create blob for part ${partNumber}:`, error);
                        throw new Error(`File reading failed at part ${partNumber}: ${error.message}`);
                    }
                }

                // Restore completed parts from checkpoint
                for (const cp of completedPartsCheckpoint) {
                    parts[cp.PartNumber - 1] = { ETag: cp.ETag, PartNumber: cp.PartNumber };
                }

                // Parallel upload logic - More aggressive for video files
                let currentIndex = 0;
                let activeUploads = 0;
                let errorOccurred = false;

                uploadStartTime = Date.now();

                async function uploadPart(partBlob) {
                    if (errorOccurred || isUploadCancelled) return; // Check for cancellation
                    const { partNumber, blob, index } = partBlob;
                    // Skip if already completed in checkpoint
                    if (parts[partNumber - 1]) {
                        completedParts++;
                        return;
                    }
                    
                    // Check for cancellation before getting pre-signed URL
                    if (isUploadCancelled) {
                        console.log(`Part ${partNumber} cancelled before pre-signed URL request`);
                        return;
                    }
                    
                    // Step 3: Get pre-signed URL for this part
                    const presignPartRes = await fetch('/api/multipart/presign-part', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            fileName: uniqueFilename,
                            uploadId,
                            partNumber,
                            contentType: file.type || 'application/octet-stream'
                        })
                    });
                    if (!presignPartRes.ok) throw new Error('Failed to get part pre-signed URL');
                    const { url } = await presignPartRes.json();

                    // Step 4: Upload part with retry logic
                    let etag = null;
                    let attempt = 0;
                    const maxAttempts = 5; // Increased from 3 to 5 for video files

                    while (attempt < maxAttempts && !etag && !errorOccurred && !isUploadCancelled) {
                        attempt++;
                        try {
                            const partStartTime = Date.now();
                            etag = await new Promise((resolve, reject) => {
                                // Check for cancellation before creating XMLHttpRequest
                                if (isUploadCancelled) {
                                    console.log(`Part ${partNumber} cancelled before XMLHttpRequest creation`);
                                    reject(new Error('Upload cancelled'));
                                    return;
                                }
                                
                                const partXhr = new XMLHttpRequest();
                                
                                // Track this XMLHttpRequest for cancellation
                                activeXhrRequests.push(partXhr);
                                
                                partXhr.open('PUT', url, true);
                                partXhr.setRequestHeader('Content-Type', file.type || 'application/octet-stream');

                                partXhr.upload.onprogress = function (event) {
                                    // Check for cancellation during progress
                                    if (isUploadCancelled) {
                                        console.log(`Part ${partNumber} progress cancelled - aborting`);
                                        partXhr.abort();
                                        return;
                                    }
                                    
                                    if (event.lengthComputable) {
                                        // Calculate delta for this part
                                        const prev = uploadedBytesPerPart[index];
                                        uploadedBytesPerPart[index] = event.loaded;
                                        const delta = event.loaded - prev;
                                        totalUploaded += delta;

                                        // Calculate progress percentage
                                        const percent = Math.round((totalUploaded / file.size) * 100);
                                        
                                        // Real-time speed calculation (aggregate) with smoothing - less frequent updates
                                        const now = Date.now();
                                        const elapsedSec = (now - uploadStartTime) / 1000;
                                        let avgSpeed = 0;
                                        
                                        if (elapsedSec > 0) {
                                            avgSpeed = (totalUploaded / 1024 / 1024) / elapsedSec; // MB/s
                                        }
                                        
                                        const avgSpeedMbps = avgSpeed * 8; // Convert to Mbps
                                        
                                        // Only update display every 3 seconds for multipart uploads (smoother)
                                        if (now - lastEtaUpdate > 3000) {
                                            // Calculate time remaining ETA
                                            const remainingBytes = file.size - totalUploaded;
                                            const eta = remainingBytes / (avgSpeed * 1024 * 1024);
                                            
                                            // Update circular progress with elapsed time and ETA
                                        updateCircularProgress(
                                            percent,
                                                formatTime(now - uploadStartTime), // Show elapsed time
                                            `${avgSpeedMbps.toFixed(2)} Mbps`,
                                            totalUploaded,
                                                file.size,
                                                formatTime(eta * 1000) // Show time remaining
                                            );
                                            lastEtaUpdate = now;
                                        } else {
                                            // Still update progress percentage but not speed/time
                                            const progressCircle = document.getElementById('progressCircle');
                                            progressCircle.style.setProperty('--progress', percent);
                                            document.getElementById('progressPercentage').textContent = `${percent}% completed`;
                                            
                                            const uploadedGB = (totalUploaded / (1024 * 1024 * 1024)).toFixed(2);
                                            const totalGB = (file.size / (1024 * 1024 * 1024)).toFixed(2);
                                            document.getElementById('uploadProgress').textContent = `${uploadedGB} GB / ${totalGB} GB`;
                                        }

                                        lastReportedBytes = totalUploaded;
                                        lastReportedTime = now;
                                    }
                                };

                                partXhr.onload = function () {
                                    // Remove from active requests when done
                                    const index = activeXhrRequests.indexOf(partXhr);
                                    if (index > -1) activeXhrRequests.splice(index, 1);
                                    
                                    // Don't process completion if upload was cancelled
                                    if (isUploadCancelled) {
                                        console.log(`Part ${partNumber} completed but upload was cancelled - ignoring`);
                                        return;
                                    }
                                    
                                    if (partXhr.status === 200) {
                                        const etag = partXhr.getResponseHeader('ETag')?.replaceAll('"', '');
                                        // Ensure final progress for this part is counted
                                        uploadedBytesPerPart[index] = blob.size;
                                        totalUploaded = uploadedBytesPerPart.reduce((a, b) => a + b, 0);
                                        
                                                                // Track part completion and detect speed degradation
                                        const partTime = Date.now() - partStartTime;
                        const partSpeed = (blob.size / 1024 / 1024) / (partTime / 1000); // MB/s
                        
                        // üîç DETECT PART SPEED DEGRADATION: If part speed drops significantly
                        if (performanceTracker.partTimes.length > 0) {
                            const recentParts = performanceTracker.partTimes.slice(-5); // Last 5 parts
                            const avgRecentSpeed = recentParts.reduce((sum, part) => sum + part.speed, 0) / recentParts.length;
                            
                            // üîç BALANCED DEGRADATION DETECTION: Allow more parallel for 100+ Mbps
                            let degradationThreshold, throttleAmount;
                            
                            if (profile.tier === 'ULTRA' || profile.tier === 'FAST') {
                                degradationThreshold = 0.5; // 50% degradation threshold - less sensitive
                                throttleAmount = 2;          // Gentler throttling
                            } else if (profile.tier === 'MODERATE') {
                                degradationThreshold = 0.6; // 60% degradation threshold
                                throttleAmount = 3;          // Aggressive throttling
                            } else { // SLOW or MOBILE
                                degradationThreshold = 0.5; // 50% degradation threshold
                                throttleAmount = 2;          // Moderate throttling
                            }
                            
                            const connectionMinParallel = Math.max(profile.parallel * 0.6, profile.tier === 'MOBILE' ? 5 : 10);
                            
                            // HIGH-LATENCY ANTI-PANIC: Disable aggressive throttling when sweet spot is locked OR during initial ramp-up
                            const initialProtectionPeriod = (Date.now() - uploadStartTime) < 60000; // 60s initial protection
                            // Only throttle if NOT in sweet spot protection mode AND not in initial ramp-up period
                            if (!peakPerformanceDetected && !initialProtectionPeriod && partSpeed < (avgRecentSpeed * 0.3) && partSpeed < 1.5 && maxParallel > connectionMinParallel) {
                                const oldParallel = maxParallel;
                                maxParallel = Math.max(maxParallel - throttleAmount, connectionMinParallel);
                                console.log(`‚ö†Ô∏è ${profile.tier} PROTECTION: Part ${partNumber} speed ${partSpeed.toFixed(1)} MB/s < 30% of avg ${avgRecentSpeed.toFixed(1)} MB/s AND < 1.5 MB/s ‚Üí throttle to ${maxParallel} (was ${oldParallel})`);
                                
                                // Update performance tracker
                                performanceTracker.updateStrategy(partSize, maxParallel, Math.ceil(file.size / partSize));
                            } else if (peakPerformanceDetected && partSpeed < 1.0) {
                                // Only emergency throttle for truly catastrophic speeds when peak is locked
                                console.log(`üîí SWEET SPOT PROTECTED: Part ${partNumber} speed ${partSpeed.toFixed(1)} MB/s is low but maintaining ${maxParallel} parallel (peak protection active)`);
                            } else if (initialProtectionPeriod && partSpeed < 1.0) {
                                // Initial ramp-up protection - only log, don't throttle
                                console.log(`üõ°Ô∏è INITIAL PROTECTION: Part ${partNumber} speed ${partSpeed.toFixed(1)} MB/s is low but maintaining ${maxParallel} parallel (60s ramp-up protection active)`);
                            }
                            
                            // üö® EMERGENCY BRAKE: Only for truly catastrophic speeds (both relative and absolute)
                            if (partSpeed < (avgRecentSpeed * 0.25) && partSpeed < 1.0 && maxParallel > 8) {
                                const oldParallel = maxParallel;
                                maxParallel = Math.max(8, connectionMinParallel);
                                console.log(`üö® EMERGENCY BRAKE: Part ${partNumber} speed ${partSpeed.toFixed(1)} MB/s << 25% of avg ${avgRecentSpeed.toFixed(1)} MB/s AND < 1.0 MB/s ‚Üí emergency throttle to ${maxParallel} (was ${oldParallel})`);
                                
                                // Update performance tracker
                                performanceTracker.updateStrategy(partSize, maxParallel, Math.ceil(file.size / partSize));
                            }
                        }
                        
                                        performanceTracker.logPartComplete(partNumber, blob.size, partTime, activeUploads);
                                        
                                        resolve(etag);
                                    } else {
                                        const error = new Error('Part upload failed: ' + partXhr.statusText);
                                        error.status = partXhr.status;
                                        reject(error);
                                    }
                                };
                                
                                partXhr.onerror = function () {
                                    // Remove from active requests on error
                                    const index = activeXhrRequests.indexOf(partXhr);
                                    if (index > -1) activeXhrRequests.splice(index, 1);
                                    
                                    reject(new Error('Part upload failed: Network error'));
                                };
                                
                                partXhr.onabort = function () {
                                    // Remove from active requests on abort
                                    const index = activeXhrRequests.indexOf(partXhr);
                                    if (index > -1) activeXhrRequests.splice(index, 1);
                                    
                                    console.log(`Part ${partNumber} upload aborted`);
                                    reject(new Error('Upload cancelled'));
                                };
                                
                                partXhr.send(blob);
                            });
                        } catch (err) {
                            // Check if error is due to cancellation
                            if (isUploadCancelled || err.message === 'Upload cancelled') {
                                console.log(`Part ${partNumber} cancelled during upload`);
                                return; // Exit silently for cancellation
                            }
                            
                            // Check for token expiry first
                            if (handleTokenExpiry(err, partNumber)) {
                                errorOccurred = true;
                                return; // Exit upload on token expiry
                            }
                            
                            // Enhanced error logging
                            const delay = getRetryDelayWithJitter(attempt - 1);
                            logPartError(partNumber, attempt, err.status, err, attempt < maxAttempts ? delay : null);
                            
                            if (attempt >= maxAttempts) {
                                errorOccurred = true;
                                throw new Error(`Part ${partNumber} failed after ${maxAttempts} attempts: ${err.message}`);
                            }
                            
                            // Wait with jittered delay before retry
                            await new Promise(res => setTimeout(res, delay));
                        }
                    }
                    
                    // Check for cancellation before completing part
                    if (isUploadCancelled) {
                        console.log(`Part ${partNumber} cancelled before completion`);
                        return;
                    }
                    
                    parts[partNumber - 1] = { ETag: etag, PartNumber: partNumber };
                    completedParts++;
                    
                    // Log progress every 10 parts
                    if (completedParts % 10 === 0 || completedParts === partCount) {
                        // Don't log progress if upload was cancelled
                        if (!isUploadCancelled) {
                        performanceTracker.logProgress(completedParts, partCount, totalUploaded, Date.now() - uploadStartTime);
                        }
                    }
                    
                    // Update checkpoint in localStorage
                    localStorage.setItem(checkpointKey, JSON.stringify(parts.filter(Boolean)));
                }

                // Function to manage parallel uploads - Smart staggered initiation
                async function runParallelUploads() {
                    return new Promise((resolve, reject) => {
                        let finished = 0;
                        
                        // Helper functions for part completion handling
                        function handlePartCompletion() {
                            finished++;
                            activeUploads--;
                            
                            // Check for cancellation before starting next batch
                            if (isUploadCancelled) {
                                console.log('Upload cancelled - stopping batch processing');
                                reject(new Error('Upload cancelled'));
                                return;
                            }
                            
                            // Immediately start next part with aggressive scheduling
                            if (currentIndex < partBlobs.length) {
                                startNextBatch(); // No delay - immediate execution
                            } else if (finished === partBlobs.length) {
                                resolve();
                            }
                        }
                        
                        function handlePartError(err) {
                            if (isUploadCancelled || err.message === 'Upload cancelled') {
                                console.log('Upload cancelled during part upload');
                                reject(new Error('Upload cancelled'));
                            } else {
                                errorOccurred = true;
                                reject(err);
                            }
                        }
                        
                        // üéØ SMART STAGGERED PART UPLOAD LAUNCH: Zero-to-Speed in <2s
                        function launchUploadParts() {
                            const totalParts = Math.min(maxParallel, partBlobs.length);
                            
                            for (let partIndex = 1; partIndex <= totalParts; partIndex++) {
                                const isInitialBatch = partIndex <= 4; // Reduced to 4 for faster launch
                                const staggerDelay = isInitialBatch ? (partIndex - 1) * 25 : 0; // Aggressive: 0, 25, 50, 75ms then immediate
                                
                                setTimeout(() => {
                                    if (currentIndex < partBlobs.length && !isUploadCancelled && !errorOccurred) {
                                        activeUploads++;
                                        const partBlob = partBlobs[currentIndex++];
                                        console.log(`üöÄ Launching part ${partBlob.partNumber} at ${staggerDelay}ms`);
                                        
                                        uploadPart(partBlob)
                                            .then(() => handlePartCompletion())
                                            .catch(err => handlePartError(err));
                                    }
                                }, staggerDelay);
                            }
                        }
                        
                        // üîÑ CONTINUOUS LAUNCH: Handle remaining parts as slots free up
                        function startNextBatch() {
                            while (activeUploads < maxParallel && currentIndex < partBlobs.length && !isUploadCancelled) {
                                if (errorOccurred || isUploadCancelled) {
                                    console.log('Upload cancelled or error occurred - stopping new uploads');
                                    return reject(new Error(isUploadCancelled ? 'Upload cancelled' : 'Upload failed'));
                                }
                                
                                activeUploads++;
                                const partBlob = partBlobs[currentIndex++];
                                
                                // Parts 9+ launch immediately as threads free up (0.8s+)
                                uploadPart(partBlob)
                                    .then(() => handlePartCompletion())
                                    .catch(err => handlePartError(err));
                            }
                        }
                        
                        // üî• TRIGGER OPTIMIZED LAUNCH SEQUENCE
                        launchUploadParts();
                    });
                }

                await runParallelUploads();
                if (errorOccurred && !isUploadCancelled) throw new Error('Multipart upload failed');

                // Final performance analysis
                const totalTime = Date.now() - uploadStartTime;
                performanceTracker.logFinalSummary(totalTime, partCount, partSize);

                // Step 5: Complete multipart upload
                const completeRes = await fetch('/api/multipart/complete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileName: uniqueFilename,
                        uploadId,
                        parts
                    })
                });
                if (!completeRes.ok) throw new Error('Failed to complete multipart upload');

                // Notify backend after upload
                await fetch('/api/notify-upload', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileName: uniqueFilename,
                        size: file.size,
                        contentType: file.type || 'application/octet-stream'
                    })
                });

                clearInterval(uploadTimerInterval);
                lastUploadTime = Date.now() - startTime;
                lastUploadSize = file.size;
                
                setTimeout(() => {
                    const mb = lastUploadSize / 1024 / 1024;
                    const sec = lastUploadTime / 1000;
                    const speedMBs = mb / sec; // MB/s
                    const speedMbps = speedMBs * 8; // Convert to Mbps
                    
                    // Show completion screen instead of alert
                    showCompletionScreen(lastUploadTime, file.size, speedMbps);
                    
                    // Clear selected files after successful upload
                    if (selectedFiles && selectedFiles.length > 0) {
                    selectedFiles = [];
                    updateSelectedFilesDisplay();
                    updateSendButton();
                    }
                }, 2000);

                // Clear checkpoint on complete
                localStorage.removeItem(checkpointKey);
                
                // Clean up performance monitoring
                if (typeof performanceCheckInterval !== 'undefined') {
                    clearInterval(performanceCheckInterval);
                }
                
                // Clean up adaptive monitoring
                if (typeof adaptiveMonitor !== 'undefined') {
                    clearInterval(adaptiveMonitor);
                }
            } catch (error) {
                // Check if this is a cancellation - handle silently
                if (isUploadCancelled || error.message === 'Upload cancelled') {
                    console.log('Upload cancelled - cleaning up silently');
                    clearInterval(uploadTimerInterval);
                    // Don't show progress section or alert for cancellation
                    // The cancelUpload() function already handled the UI cleanup
                    
                    // Clean up performance monitoring on cancellation
                    if (typeof performanceCheckInterval !== 'undefined') {
                        clearInterval(performanceCheckInterval);
                    }
                    
                                    // Clean up adaptive monitoring on cancellation
                if (typeof adaptiveMonitor !== 'undefined') {
                    clearInterval(adaptiveMonitor);
                    }
                    return; // Exit silently
                }
                
                // On actual error (not cancellation), log details and show alert
                const connectionQuality = typeof detectConnectionQuality === 'function' ? await detectConnectionQuality() : 'unknown';
                const speed = document.getElementById('uploadSpeed')?.textContent || 'unknown';
                const details = {
                    fileName: uniqueFilename,
                    fileSize: file.size,
                    error: error.message || error.toString(),
                    connectionQuality,
                    speed,
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent
                };
                logUploadFailure(details);
                
                clearInterval(uploadTimerInterval);
                hideProgressSection();
                alert('Multipart upload failed: ' + error.message);
                
                // Clean up performance monitoring on error
                if (typeof performanceCheckInterval !== 'undefined') {
                    clearInterval(performanceCheckInterval);
                }
                
                // Clean up adaptive monitoring on error
                if (typeof adaptiveMonitor !== 'undefined') {
                    clearInterval(adaptiveMonitor);
                }
            }
        }

        async function refreshFileList() {
            try {
                const response = await fetch('/api/files');
                const files = await response.json();
                
                // Update main file list
                const fileList = document.getElementById('fileList');
                if (fileList) {
                    fileList.innerHTML = '';

                    if (files.length === 0) {
                        fileList.innerHTML = '<div style="text-align: center; color: #888; padding: 40px;">No files found.</div>';
                    } else {
                        files.forEach(file => {
                            const fileItem = document.createElement('div');
                            fileItem.className = 'file-item';
                            fileItem.innerHTML = `
                                <div class="file-info">
                                    <div class="file-name">${file.name}</div>
                                    <div class="file-size">${formatFileSize(file.size)}</div>
                                </div>
                                <button class="download-btn" onclick="downloadFile('${file.name}')">Download</button>
                            `;
                            fileList.appendChild(fileItem);
                        });
                        
                        // If download is active, disable all buttons and mark active one
                        if (isDownloadActive) {
                            disableAllDownloadButtons();
                            // Mark the specific downloading file if we know which one
                            if (currentDownloadFileName) {
                                markActiveDownloadButton(currentDownloadFileName);
                            }
                        }
                    }
                }
                
                // Also update completion file list if it exists and is visible
                const completionFileList = document.getElementById('completionFileList');
                if (completionFileList) {
                    completionFileList.innerHTML = '';

                    if (files.length === 0) {
                        completionFileList.innerHTML = '<div style="text-align: center; color: #888; padding: 40px;">No files found.</div>';
                    } else {
                        files.forEach(file => {
                            const fileItem = document.createElement('div');
                            fileItem.className = 'file-item';
                            fileItem.innerHTML = `
                                <div class="file-info">
                                    <div class="file-name">${file.name}</div>
                                    <div class="file-size">${formatFileSize(file.size)}</div>
                                </div>
                                <button class="download-btn" onclick="downloadFile('${file.name}')">Download</button>
                            `;
                            completionFileList.appendChild(fileItem);
                        });
                        
                        // If download is active, disable all buttons in completion list too
                        if (isDownloadActive) {
                            const completionButtons = completionFileList.querySelectorAll('.download-btn');
                            completionButtons.forEach(button => {
                                button.disabled = true;
                                button.style.opacity = '0.5';
                                button.style.cursor = 'not-allowed';
                                
                                // Check if this is the currently downloading file
                                const fileItem = button.closest('.file-item');
                                const fileNameElement = fileItem ? fileItem.querySelector('.file-name') : null;
                                const fileName = fileNameElement ? fileNameElement.textContent : '';
                                
                                if (fileName === currentDownloadFileName) {
                                    button.textContent = 'Downloading...';
                                    button.style.background = '#e0f2fe';
                                    button.style.borderColor = '#0ea5e9';
                                    button.style.color = '#0ea5e9';
                                } else {
                                    button.textContent = 'Another Download in Progress...';
                                }
                            });
                        }
                    }
                }
            } catch (error) {
                console.error('Error:', error);
                const fileList = document.getElementById('fileList');
                if (fileList) {
                    fileList.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">Error loading files.</div>';
                }
                const completionFileList = document.getElementById('completionFileList');
                if (completionFileList) {
                    completionFileList.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">Error loading files.</div>';
                }
            }
        }

        async function downloadFile(fileName) {
            // Show download progress section in new UI
            showDownloadProgress(fileName);
            
            let startTime = Date.now();
            if (downloadTimerInterval) clearInterval(downloadTimerInterval);
            downloadTimerInterval = setInterval(() => {
                // Update timer in download progress section
                const elapsed = Date.now() - startTime;
                document.getElementById('downloadTimeRemaining').textContent = formatTime(elapsed);
            }, 100);

            // üöÄ SPEED FIX: Use direct R2 public URLs for maximum speed (no backend throttling)
            const publicUrl = `${R2_PUBLIC_URL_BASE}/${encodeURIComponent(fileName)}`;

            // Step 1: Get file size with HEAD request
            let fileSize = 0;
            try {
                const headRes = await fetch(publicUrl, { method: 'HEAD' });
                if (!headRes.ok) throw new Error('Failed to get file size');
                fileSize = parseInt(headRes.headers.get('content-length'), 10);
                console.log(`File size: ${formatFileSize(fileSize)}`);
            } catch (err) {
                hideDownloadProgressOnError();
                clearInterval(downloadTimerInterval);
                alert('Failed to get file size: ' + err.message);
                return;
            }

            // üéØ DIRECT-TO-DISK DOWNLOAD: File System Access API (zero Chrome delay)
            if (fileSize > 1024 * 1024 * 1024 && 'showSaveFilePicker' in window) { // 1GB+ and supports File System Access API
                console.log(`Large file detected (${formatFileSize(fileSize)}) - using direct-to-disk streaming (zero Chrome delay)`);
                await directToDiskDownload(fileName, publicUrl, fileSize, startTime);
                return;
            }

            // For large files (1GB+), always use real progress streaming even in HTTP environments
            if (fileSize > 1024 * 1024 * 1024) {
                console.log(`Large file detected (${formatFileSize(fileSize)}) - using real progress streaming (HTTP environment)`);
                await streamingDownloadNoBlobDelay(fileName, publicUrl, fileSize, startTime);
                return;
            }

            // For smaller files, use direct URL download (fast but no real progress)
            console.log(`Small file detected (${formatFileSize(fileSize)}) - using direct URL download`);
            await directUrlDownload(fileName, publicUrl, fileSize, startTime);
        }

        // üéØ DIRECT-TO-DISK DOWNLOAD: File System Access API (zero Chrome delay) - SPEED OPTIMIZED
        async function directToDiskDownload(fileName, publicUrl, fileSize, startTime) {
            try {
                console.log('üéØ Starting TURBO DIRECT-TO-DISK download - maximum speed!');
                
                // Show save dialog
                const fileHandle = await window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{
                        description: 'Video Files',
                        accept: {
                            'video/*': ['.mp4', '.mov', '.avi', '.mkv', '.webm', '.wmv', '.mxf'],
                            'application/octet-stream': ['.mp4', '.mov', '.avi', '.mkv', '.webm', '.wmv', '.mxf']
                        }
                    }]
                });

                console.log('‚úÖ Save dialog completed, starting TURBO streaming...');
                const writable = await fileHandle.createWritable();
                
                let bytesWritten = 0;
                let lastTime = Date.now();
                let lastBytes = 0;
                let speeds = [];
                
                // üöÄ SPEED OPTIMIZATION: Dynamic parallel downloads based on connection speed
                const connectionInfo = await detectConnectionQuality();
                let CHUNK_SIZE, MAX_PARALLEL;
                
                // üéØ DYNAMIC PARALLELISM: Based on actual connection speed (File System Access API optimized)
                if (connectionInfo.bandwidth >= 20) {
                    // Ultra-fast connections (160+ Mbps) - Conservative for File System API
                    CHUNK_SIZE = 15 * 1024 * 1024; // 15MB chunks
                    MAX_PARALLEL = 3; // Reduced for stability
                    console.log(`üöÄ ULTRA MODE: ${MAX_PARALLEL} parallel streams for ${(connectionInfo.bandwidth * 8).toFixed(0)} Mbps connection`);
                } else if (connectionInfo.bandwidth >= 15) {
                    // Very fast connections (120+ Mbps) - Your connection level
                    CHUNK_SIZE = 20 * 1024 * 1024; // 20MB chunks
                    MAX_PARALLEL = 3; // Safe for File System API
                    console.log(`üöÄ TURBO MODE: ${MAX_PARALLEL} parallel streams for ${(connectionInfo.bandwidth * 8).toFixed(0)} Mbps connection`);
                } else if (connectionInfo.bandwidth >= 8) {
                    // Fast connections (64+ Mbps)
                    CHUNK_SIZE = 25 * 1024 * 1024; // 25MB chunks
                    MAX_PARALLEL = 2; // Conservative parallelism
                    console.log(`üöÄ FAST MODE: ${MAX_PARALLEL} parallel streams for ${(connectionInfo.bandwidth * 8).toFixed(0)} Mbps connection`);
                } else if (connectionInfo.bandwidth >= 3) {
                    // Medium connections (24+ Mbps)
                    CHUNK_SIZE = 30 * 1024 * 1024; // 30MB chunks
                    MAX_PARALLEL = 2; // Conservative parallelism
                    console.log(`üöÄ MEDIUM MODE: ${MAX_PARALLEL} parallel streams for ${(connectionInfo.bandwidth * 8).toFixed(0)} Mbps connection`);
                } else {
                    // Slower connections (<24 Mbps)
                    CHUNK_SIZE = 50 * 1024 * 1024; // 50MB chunks
                    MAX_PARALLEL = 1; // Single stream for safety
                    console.log(`üöÄ SAFE MODE: ${MAX_PARALLEL} stream for ${(connectionInfo.bandwidth * 8).toFixed(0)} Mbps connection`);
                }
                
                if (fileSize > 100 * 1024 * 1024) { // For files > 100MB, use parallel downloading
                    console.log(`üéØ ADAPTIVE TURBO: Using ${MAX_PARALLEL} parallel streams optimized for your connection`);
                    // await parallelDirectToDisk(publicUrl, fileSize, writable, startTime, fileName, CHUNK_SIZE, MAX_PARALLEL);
                    // DISABLED: Parallel downloads cause freezing - using single stream instead
                    await singleStreamDirectToDisk(publicUrl, fileSize, writable, startTime);
                } else {
                    // üöÄ FILE SYSTEM ACCESS API: Single stream only (prevents freezing)
                    // Parallel downloads cause browser freezing - disabled for stability
                    console.log('üéØ STABLE MODE: Using single stream direct-to-disk (no freezing, instant completion)');
                    await singleStreamDirectToDisk(publicUrl, fileSize, writable, startTime);
                }
                
                // Show "Finalizing..." message before the potentially long close operation
                document.getElementById('downloadProgressPercentage').textContent = 'Finalizing file...';
                document.getElementById('downloadProgressPercentage').style.color = '#4A90E2'; // Blue text
                console.log('üîÑ Finalizing file write to disk...');

                await writable.close();
                console.log('üéâ TURBO DIRECT-TO-DISK COMPLETE - file saved at maximum speed!');

                // Success - Go directly to completion screen
                clearInterval(downloadTimerInterval);
                const downloadTime = Date.now() - startTime;

                // Go directly to completion screen without delay
                    hideDownloadProgress(downloadTime, fileSize);
                // Show final speed
                if (downloadTime > 0 && fileSize > 0) {
                    const mb = fileSize / 1024 / 1024;
                    const sec = downloadTime / 1000;
                    const speedMBs = mb / sec;
                    const speedMbps = speedMBs * 8;
                    document.getElementById('downloadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps (avg)`;
                }
                
                console.log(`‚úÖ TURBO download complete: ${formatFileSize(fileSize)} in ${formatTime(downloadTime)} - MAXIMUM SPEED!`);
                await logDownload(fileName, fileSize, 'turbo-direct-to-disk', document.getElementById('downloadSpeed').textContent);
                
            } catch (error) {
                console.error('‚ùå Turbo direct-to-disk download error:', error);
                
                // For large files (3GB+), DO NOT fall back to blob methods - show error instead
                if (fileSize > 1024 * 1024 * 1024) {
                    hideDownloadProgressOnError();
                    clearInterval(downloadTimerInterval);
                    document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
                    
                    if (error.name === 'AbortError' || error.message.includes('user aborted')) {
                        console.log('User cancelled turbo direct-to-disk download');
                        return;
                    }
                    
                    alert(`Large file download failed: ${error.message}\n\nFor files over 1GB, please use a modern browser with File System Access API support.`);
                    return;
                }
                
                // Only for smaller files, fall back to streaming
                console.log('Falling back to streaming download for smaller file');
                await streamingDownloadNoBlobDelay(fileName, publicUrl, fileSize, startTime);
            }
        }

        // üöÄ PARALLEL DIRECT-TO-DISK: Adaptive speed with dynamic parallel connections
        async function parallelDirectToDisk(publicUrl, fileSize, writable, startTime, fileName, CHUNK_SIZE, MAX_PARALLEL) {
            const totalChunks = Math.ceil(fileSize / CHUNK_SIZE);
            
            let completedChunks = 0;
            let bytesWritten = 0;
            let lastTime = Date.now();
            let speeds = [];
            
            console.log(`üéØ ADAPTIVE PARALLEL: ${totalChunks} chunks (${(CHUNK_SIZE/1024/1024).toFixed(0)}MB each) with ${MAX_PARALLEL} connections`);
            
            // Download chunk function
            async function downloadChunk(chunkIndex) {
                const start = chunkIndex * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE - 1, fileSize - 1);
                
                const response = await fetch(publicUrl, {
                    headers: { 'Range': `bytes=${start}-${end}` }
                });
                
                if (!response.ok) throw new Error(`Chunk ${chunkIndex} failed: ${response.status}`);
                
                const reader = response.body.getReader();
                const chunks = [];
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    chunks.push(value);
                }
                
                // Combine chunk data
                const chunkData = new Uint8Array(chunks.reduce((acc, chunk) => acc + chunk.length, 0));
                let offset = 0;
                for (const chunk of chunks) {
                    chunkData.set(chunk, offset);
                    offset += chunk.length;
                }
                
                return { chunkIndex, data: chunkData, start };
            }
            
            // Process chunks in order and write to file
            const chunkPromises = [];
            const chunkResults = new Map();
            let nextChunkToWrite = 0;
            
            // Start parallel downloads
            for (let i = 0; i < Math.min(MAX_PARALLEL, totalChunks); i++) {
                chunkPromises.push(downloadChunk(i));
            }
            
            let activeDownloads = Math.min(MAX_PARALLEL, totalChunks);
            let nextChunkToStart = activeDownloads;
            
            while (completedChunks < totalChunks) {
                // Wait for next chunk to complete
                const result = await Promise.race(chunkPromises.filter(p => p));
                const chunkIndex = chunkPromises.findIndex(p => p === result);
                
                const { chunkIndex: completedIndex, data, start } = await result;
                chunkResults.set(completedIndex, data);
                
                // Write chunks in order
                while (chunkResults.has(nextChunkToWrite)) {
                    const chunkData = chunkResults.get(nextChunkToWrite);
                    await writable.write(chunkData);
                    
                    bytesWritten += chunkData.length;
                    completedChunks++;
                    chunkResults.delete(nextChunkToWrite);
                    nextChunkToWrite++;
                    
                    // Update progress
                    const now = Date.now();
                    if (now - lastTime >= 300) { // Update every 300ms for responsiveness
                        const percent = Math.round((bytesWritten / fileSize) * 100);
                        const bytesSinceLast = bytesWritten - (speeds.length > 0 ? speeds[speeds.length - 1].bytes : 0);
                        const timeSinceLast = (now - lastTime) / 1000;
                        const currentSpeed = (bytesSinceLast / 1024 / 1024) / timeSinceLast;
                        
                        speeds.push({ speed: currentSpeed, bytes: bytesWritten });
                        if (speeds.length > 8) speeds.shift();
                        
                        const avgSpeed = speeds.reduce((a, b) => a + b.speed, 0) / speeds.length;
                        const avgSpeedMbps = avgSpeed * 8;
                        
                        const remainingBytes = fileSize - bytesWritten;
                        const eta = remainingBytes / (avgSpeed * 1024 * 1024);
                        const elapsedTime = now - startTime;
                        
                        updateDownloadCircularProgress(
                            percent,
                            formatTime(elapsedTime),
                            `${avgSpeedMbps.toFixed(2)} Mbps`,
                            bytesWritten,
                            fileSize,
                            formatTime(eta * 1000)
                        );
                        
                        lastTime = now;
                    }
                }
                
                // Start next chunk download if available
                if (nextChunkToStart < totalChunks) {
                    chunkPromises[chunkIndex] = downloadChunk(nextChunkToStart);
                    nextChunkToStart++;
                } else {
                    chunkPromises[chunkIndex] = null;
                    activeDownloads--;
                }
            }
            
            console.log(`üéâ Parallel download complete: ${completedChunks} chunks processed`);
        }

        // üöÄ SINGLE STREAM DIRECT-TO-DISK: Optimized for smaller files
        async function singleStreamDirectToDisk(publicUrl, fileSize, writable, startTime) {
            let bytesWritten = 0;
            let lastTime = Date.now();
            let speeds = [];
            
            const response = await fetch(publicUrl);
            if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            
            const reader = response.body.getReader();
            
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                
                // Write directly to file system - maximum speed
                await writable.write(value);
                bytesWritten += value.length;
                
                // Update progress every 200ms for maximum responsiveness
                const now = Date.now();
                if (now - lastTime >= 200) {
                    const percent = Math.round((bytesWritten / fileSize) * 100);
                    const bytesSinceLast = bytesWritten - (speeds.length > 0 ? speeds[speeds.length - 1].bytes : 0);
                    const timeSinceLast = (now - lastTime) / 1000;
                    const currentSpeed = (bytesSinceLast / 1024 / 1024) / timeSinceLast;
                    
                    speeds.push({ speed: currentSpeed, bytes: bytesWritten });
                    if (speeds.length > 10) speeds.shift();
                    
                    const avgSpeed = speeds.reduce((a, b) => a + b.speed, 0) / speeds.length;
                    const avgSpeedMbps = avgSpeed * 8;
                    
                    const remainingBytes = fileSize - bytesWritten;
                    const eta = remainingBytes / (avgSpeed * 1024 * 1024);
                    const elapsedTime = now - startTime;
                    
                    updateDownloadCircularProgress(
                        percent,
                        formatTime(elapsedTime),
                        `${avgSpeedMbps.toFixed(2)} Mbps`,
                        bytesWritten,
                        fileSize,
                        formatTime(eta * 1000)
                    );
                    
                    lastTime = now;
                }
            }
            
            // Show 100% completion with "Finalizing..." message when streaming completes
            const progressCircle = document.getElementById('downloadProgressCircle');
            progressCircle.style.setProperty('--progress', 100);
            
            document.getElementById('downloadProgressPercentage').textContent = 'Finalizing...';
            document.getElementById('downloadProgressPercentage').style.color = '#4A90E2'; // Blue text
            document.getElementById('downloadTimeRemainingETA').textContent = '00:00:00';
        }

        // üåä STREAMING DOWNLOAD with ERR_CONTENT_LENGTH_MISMATCH detection
        async function streamingDownload(fileName, publicUrl, fileSize, startTime) {
            try {
                const response = await fetch(publicUrl);
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                
                const reader = response.body.getReader();
                let receivedLength = 0;
                let chunks = [];
                let lastTime = Date.now();
                let lastBytes = 0;
                let speeds = [];
                
                console.log('Streaming download started');
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    chunks.push(value);
                    receivedLength += value.length;
                    
                    // Update progress
                    const percent = Math.round((receivedLength / fileSize) * 100);
                    
                    // Calculate speed and ETA (update every 1 second for stability)
                    const now = Date.now();
                    if (now - lastTime >= 1000) {
                        const bytesSinceLast = receivedLength - lastBytes;
                        const timeSinceLast = (now - lastTime) / 1000;
                        const currentSpeed = (bytesSinceLast / 1024 / 1024) / timeSinceLast; // MB/s
                        
                        speeds.push(currentSpeed);
                        if (speeds.length > 6) speeds.shift(); // Keep fewer readings for stability
                        
                        const avgSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
                        const avgSpeedMbps = avgSpeed * 8; // Convert to Mbps
                        
                        // Calculate ETA with smoothing
                        const remainingBytes = fileSize - receivedLength;
                        const eta = remainingBytes / (avgSpeed * 1024 * 1024);
                        const elapsedTime = now - startTime;
                        
                        // Update download circular progress
                        updateDownloadCircularProgress(
                            percent,
                            formatTime(elapsedTime), // Show elapsed time
                            `${avgSpeedMbps.toFixed(2)} Mbps`,
                            receivedLength,
                            fileSize,
                            formatTime(eta * 1000) // Show time remaining
                        );
                        
                        lastTime = now;
                        lastBytes = receivedLength;
                    }
                }
                
                // Check for content-length mismatch
                if (receivedLength !== fileSize) {
                    console.warn(`ERR_CONTENT_LENGTH_MISMATCH detected: expected ${fileSize}, received ${receivedLength}`);
                    throw new Error(`ERR_CONTENT_LENGTH_MISMATCH: Content-Length promised ${fileSize} bytes but only ${receivedLength} bytes received`);
                }
                
                // Create and download blob with optimizations
                const blob = new Blob(chunks, { 
                    type: 'application/octet-stream',
                    // Add explicit type to help Chrome's scanner
                    endings: 'native'
                });

                // Download assembled file with optimizations
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.style.display = 'none';
                document.body.appendChild(a);

                // Force immediate download
                setTimeout(() => {
                    a.click();
                    setTimeout(() => {
                        window.URL.revokeObjectURL(url);
                        a.remove();
                    }, 1000);
                }, 100);
                
                // Success
                clearInterval(downloadTimerInterval);
                const downloadTime = Date.now() - startTime;
                const downloadSize = blob.size;
                
                hideDownloadProgress(downloadTime, downloadSize);
                
                // Show average speed
                if (downloadTime > 0 && downloadSize > 0) {
                    const mb = downloadSize / 1024 / 1024;
                    const sec = downloadTime / 1000;
                    const speedMBs = mb / sec; // MB/s
                    const speedMbps = speedMBs * 8; // Convert to Mbps
                    document.getElementById('downloadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps (avg)`;
                }
                
                console.log(`Streaming download complete: ${formatFileSize(downloadSize)} in ${formatTime(downloadTime)}`);
                
                // Log download
                await logDownload(fileName, downloadSize, 'streaming', document.getElementById('downloadSpeed').textContent);
                
            } catch (error) {
                console.error('Streaming download error:', error);
                
                // Detect content-length mismatch errors
                if (error.message.includes('ERR_CONTENT_LENGTH_MISMATCH') || error.message.includes('Content-Length')) {
                    console.log('Content-Length mismatch detected, falling back to chunked download');
                    await chunkedDownload(fileName, publicUrl, fileSize, startTime);
                } else {
                    // Show error
                    hideDownloadProgressOnError();
                    clearInterval(downloadTimerInterval);
                    document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
                    alert(`Download failed: ${error.message}`);
                }
            }
        }

        // üß© CHUNKED DOWNLOAD: Last resort for ERR_CONTENT_LENGTH_MISMATCH
        async function chunkedDownload(fileName, publicUrl, fileSize, startTime) {
            try {
                const CHUNK_SIZE = 10 * 1024 * 1024; // 10MB chunks
                const totalChunks = Math.ceil(fileSize / CHUNK_SIZE);
                let chunks = new Array(totalChunks);
                let bytesDownloaded = 0;
                let lastTime = Date.now();
                let lastBytes = 0;
                let speeds = [];
                
                console.log(`Chunked download started: ${totalChunks} chunks of ${formatFileSize(CHUNK_SIZE)}`);
                
                async function downloadChunk(chunkIndex, retries = 3) {
                    const start = chunkIndex * CHUNK_SIZE;
                    const end = Math.min(start + CHUNK_SIZE - 1, fileSize - 1);
                    
                    for (let attempt = 1; attempt <= retries; attempt++) {
                        try {
                            const response = await fetch(publicUrl, {
                                headers: { 'Range': `bytes=${start}-${end}` }
                            });
                            
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            
                            const chunk = await response.arrayBuffer();
                            chunks[chunkIndex] = chunk;
                            
                            const chunkSize = chunk.byteLength;
                            bytesDownloaded += chunkSize;
                            
                            // Update progress
                            const percent = Math.round((bytesDownloaded / fileSize) * 100);
                            
                            // Calculate speed and ETA
                            const now = Date.now();
                            if (now - lastTime >= 500) {
                                const bytesSinceLast = bytesDownloaded - lastBytes;
                                const timeSinceLast = (now - lastTime) / 1000;
                                const currentSpeed = (bytesSinceLast / 1024 / 1024) / timeSinceLast; // MB/s
                                
                                speeds.push(currentSpeed);
                                if (speeds.length > 6) speeds.shift();
                                
                                const avgSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
                                const avgSpeedMbps = avgSpeed * 8; // Convert to Mbps
                                
                                const remainingBytes = fileSize - bytesDownloaded;
                                const eta = remainingBytes / (avgSpeed * 1024 * 1024);
                                const elapsedTime = now - startTime;
                                
                                // Update download circular progress
                                updateDownloadCircularProgress(
                                    percent,
                                    formatTime(elapsedTime), // Show elapsed time
                                    `${avgSpeedMbps.toFixed(2)} Mbps`,
                                    bytesDownloaded,
                                    fileSize,
                                    formatTime(eta * 1000) // Show time remaining
                                );
                                
                                lastTime = now;
                                lastBytes = bytesDownloaded;
                            }
                            
                            console.log(`Chunk ${chunkIndex + 1}/${totalChunks} complete (${formatFileSize(chunkSize)})`);
                            return;
                            
                        } catch (error) {
                            console.warn(`Chunk ${chunkIndex + 1} attempt ${attempt} failed:`, error.message);
                            
                            if (attempt === retries) {
                                throw new Error(`Chunk ${chunkIndex + 1} failed after ${retries} attempts: ${error.message}`);
                            }
                            
                            // Wait before retry
                            await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                        }
                    }
                }
                
                // Download all chunks in parallel (limited concurrency)
                const concurrency = 3;
                for (let i = 0; i < totalChunks; i += concurrency) {
                    const batch = [];
                    for (let j = 0; j < concurrency && i + j < totalChunks; j++) {
                        batch.push(downloadChunk(i + j));
                    }
                    await Promise.all(batch);
                }
                
                // Reassemble file
                const blob = new Blob(chunks.map(chunk => new Uint8Array(chunk)), { type: 'application/octet-stream' });
                
                // Download assembled file
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                a.remove();
                
                // Success
                clearInterval(downloadTimerInterval);
                const downloadTime = Date.now() - startTime;
                const downloadSize = blob.size;
                
                hideDownloadProgress(downloadTime, downloadSize);
                
                // Show average speed
                if (downloadTime > 0 && downloadSize > 0) {
                    const mb = downloadSize / 1024 / 1024;
                    const sec = downloadTime / 1000;
                    const speedMBs = mb / sec; // MB/s
                    const speedMbps = speedMBs * 8; // Convert to Mbps
                    document.getElementById('downloadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps (avg)`;
                }
                
                console.log(`Chunked download complete: ${formatFileSize(downloadSize)} in ${formatTime(downloadTime)}`);
                
                // Log download
                await logDownload(fileName, downloadSize, 'chunked', document.getElementById('downloadSpeed').textContent);
                
            } catch (error) {
                console.error('Chunked download error:', error);
                hideDownloadProgressOnError();
                clearInterval(downloadTimerInterval);
                document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
                alert(`Chunked download failed: ${error.message}`);
            }
        }

        // üìä Log download to backend
        async function logDownload(fileName, fileSize, method, speed) {
            try {
                const connectionQuality = typeof detectConnectionQuality === 'function' ? await detectConnectionQuality() : 'unknown';
                await fetch('/api/log-download', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileName,
                        fileSize,
                        method,
                        contentType: 'application/octet-stream',
                        connectionQuality,
                        speed,
                        userAgent: navigator.userAgent
                    })
                });
            } catch (error) {
                console.warn('Failed to log download:', error.message);
            }
        }

        // On page load, set timers to last value or 00:00:00
        window.onload = function() {
            // Clear any lingering intervals from previous sessions
            if (typeof uploadTimerInterval !== 'undefined') clearInterval(uploadTimerInterval);
            if (typeof downloadTimerInterval !== 'undefined') clearInterval(downloadTimerInterval);
            
            // Reset upload states to prevent infinite loops
            isUploadActive = false;
            isUploadCancelled = false;
            isDownloadActive = false;
            activeUploads = 0;
            
            if (lastUploadTime > 0 && lastUploadSize > 0) {
                const mb = lastUploadSize / 1024 / 1024;
                const sec = lastUploadTime / 1000;
                const speedMBs = mb / sec; // MB/s
                const speedMbps = speedMBs * 8; // Convert to Mbps
                document.getElementById('uploadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps`;
            } else {
                document.getElementById('uploadSpeed').textContent = '0.00 Mbps';
            }
            if (lastDownloadTime > 0 && lastDownloadSize > 0) {
                const mb = lastDownloadSize / 1024 / 1024;
                const sec = lastDownloadTime / 1000;
                const speedMBs = mb / sec; // MB/s
                const speedMbps = speedMBs * 8; // Convert to Mbps
                document.getElementById('downloadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps`;
            } else {
                document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
            }
        };

        // Initial file list load
        refreshFileList();

        // Simple static password protection
        (function() {
            var password = 'wnet';
            var entered = sessionStorage.getItem('wnet_auth');
            if (entered !== password) {
                while (true) {
                    var input = prompt('Enter password to access this page:');
                    if (input === null) {
                        document.body.innerHTML = '<h2>Access denied.</h2>';
                        throw new Error('Access denied');
                    }
                    if (input === password) {
                        sessionStorage.setItem('wnet_auth', password);
                        break;
                    }
                }
            }
        })();

        // UI Management Functions - keeping the beautiful UI
        function generatePackageId() {
            const now = new Date();
            const timestamp = now.getFullYear().toString() + 
                             (now.getMonth() + 1).toString().padStart(2, '0') + 
                             now.getDate().toString().padStart(2, '0') + 
                             now.getHours().toString().padStart(2, '0') + 
                             now.getMinutes().toString().padStart(2, '0') + 
                             now.getSeconds().toString().padStart(2, '0');
            return `WNET-R2-${timestamp}`;
        }

        function showProgressSection(fileName) {
            isUploadActive = true;
            isUploadCompleted = false;
            isUploadCancelled = false; // Reset cancellation flag for new upload
            activeXhrRequests = []; // Clear any previous requests
            performanceTracker.disabled = false; // Re-enable performance tracking for new upload
            console.log('Upload started - setting isUploadActive to true');
            document.getElementById('uploadSection').classList.add('hidden');
            document.getElementById('progressSection').classList.remove('hidden');
        }

        function hideProgressSection() {
            document.getElementById('uploadSection').classList.remove('hidden');
            document.getElementById('progressSection').classList.add('hidden');
        }

        function updateCircularProgress(percentage, elapsedTime, speed, uploaded, total, eta = null) {
            const progressCircle = document.getElementById('progressCircle');
            // Use percentage directly (0-100)
            progressCircle.style.setProperty('--progress', percentage);
            
            document.getElementById('progressPercentage').textContent = `${percentage}% completed`;
            document.getElementById('timeRemaining').textContent = elapsedTime; // Show elapsed time
            document.getElementById('uploadSpeed').textContent = speed;
            
            // Update time remaining ETA if provided
            if (eta) {
                document.getElementById('timeRemainingETA').textContent = eta;
            }
            
            const uploadedGB = (uploaded / (1024 * 1024 * 1024)).toFixed(2);
            const totalGB = (total / (1024 * 1024 * 1024)).toFixed(2);
            document.getElementById('uploadProgress').textContent = `${uploadedGB} GB / ${totalGB} GB`;
        }

        function showDownloadProgress(fileName) {
            // Set download active state and track current file
            isDownloadActive = true;
            isDownloadCompleted = false;
            currentDownloadFileName = fileName;
            console.log('Download started - setting isDownloadActive to true');
            
            // RESET PROGRESS BAR: Clear any previous green completion styling
            const progressCircle = document.getElementById('downloadProgressCircle');
            progressCircle.style.setProperty('--progress', 0);
            progressCircle.style.background = ''; // Reset to default blue gradient
            
            // Reset text content to default blue styling
            document.getElementById('downloadProgressPercentage').textContent = '0% completed';
            document.getElementById('downloadProgressPercentage').style.color = '#4A90E2'; // Blue text
            document.getElementById('downloadTimeRemaining').textContent = '00:00:00';
            document.getElementById('downloadTimeRemainingETA').textContent = 'Calculating...';
            document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
            
            // Hide completion screen if it's currently showing
            document.getElementById('downloadCompletionScreen').classList.add('hidden');
            // Show download section and progress
            document.getElementById('downloadSection').classList.remove('hidden');
            document.getElementById('downloadProgressSection').classList.remove('hidden');
            
            // Disable all download buttons and mark the active one
            disableAllDownloadButtons();
            markActiveDownloadButton(fileName);
        }

        // Function to mark the active download button
        function markActiveDownloadButton(fileName) {
            const downloadButtons = document.querySelectorAll('.download-btn');
            downloadButtons.forEach(button => {
                // Find the button for this specific file
                const fileItem = button.closest('.file-item');
                if (fileItem) {
                    const fileNameElement = fileItem.querySelector('.file-name');
                    if (fileNameElement && fileNameElement.textContent === fileName) {
                        button.textContent = 'Downloading...';
                        button.style.background = '#e0f2fe';
                        button.style.borderColor = '#0ea5e9';
                        button.style.color = '#0ea5e9';
                    }
                }
            });
        }

        function hideDownloadProgress(downloadTime = null, downloadSize = null) {
            // Reset download active state and clear current file
            isDownloadActive = false;
            currentDownloadFileName = null;
            console.log('Download completed - setting isDownloadActive to false');
            
            // Debug: Log the parameters being passed
            console.log('hideDownloadProgress called with:', {
                downloadTime,
                downloadSize,
                downloadTimeInSeconds: downloadTime ? downloadTime / 1000 : null,
                downloadSizeInMB: downloadSize ? downloadSize / 1024 / 1024 : null
            });
            
            // Update global variables if provided
            if (downloadTime !== null) {
                lastDownloadTime = downloadTime;
                console.log('Updated lastDownloadTime to:', lastDownloadTime);
            }
            if (downloadSize !== null) {
                lastDownloadSize = downloadSize;
                console.log('Updated lastDownloadSize to:', lastDownloadSize);
            }
            
            document.getElementById('downloadProgressSection').classList.add('hidden');
            // Show completion state instead of just hiding
            showDownloadCompletion();
        }

        function showDownloadCompletion() {
            // Set download completion state
            isDownloadCompleted = true;
            
            // Hide download section and show download completion screen
            document.getElementById('downloadSection').classList.add('hidden');
            document.getElementById('downloadCompletionScreen').classList.remove('hidden');
            
            // Debug: Log the values being used
            console.log('showDownloadCompletion called with:', {
                lastDownloadTime,
                lastDownloadSize,
                timeInSeconds: lastDownloadTime / 1000,
                sizeInMB: lastDownloadSize / 1024 / 1024
            });
            
            // Update completion stats
            if (lastDownloadTime > 0 && lastDownloadSize > 0) {
                // Format time as HH:MM:SS
                const totalSeconds = Math.floor(lastDownloadTime / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('downloadCompletionTimeFullScreen').textContent = `Total time ${timeString}`;                
                // Calculate speed in Mbps
                const mb = lastDownloadSize / 1024 / 1024;
                const sec = lastDownloadTime / 1000;
                const speedMBs = mb / sec;
                const speedMbps = speedMBs * 8;
                
                console.log('Speed calculation:', {
                    mb: mb.toFixed(2),
                    sec: sec.toFixed(2),
                    speedMBs: speedMBs.toFixed(2),
                    speedMbps: speedMbps.toFixed(2)
                });
                
                document.getElementById('downloadCompletionSpeedFullScreen').textContent = `${speedMbps.toFixed(2)} Mbps`;                
                // Format size in GB
                const sizeGB = (lastDownloadSize / (1024 * 1024 * 1024)).toFixed(2);
                document.getElementById('downloadCompletionDownloaded').textContent = `${sizeGB} GB`;
            } else {
                console.log('Download completion data missing:', {
                    lastDownloadTime,
                    lastDownloadSize
                });
            }
            
            // Populate file list in completion screen
            populateCompletionFileList();
            
            // Re-enable all download buttons
            enableAllDownloadButtons();
        }

        // Function to populate file list in completion screen
        async function populateCompletionFileList() {
            try {
                const response = await fetch('/api/files');
                const files = await response.json();
                
                const fileList = document.getElementById('completionFileList');
                fileList.innerHTML = '';

                if (files.length === 0) {
                    fileList.innerHTML = '<div style="text-align: center; color: #888; padding: 40px;">No files found.</div>';
                    return;
                }

                files.forEach(file => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.innerHTML = `
                        <div class="file-info">
                            <div class="file-name">${file.name}</div>
                            <div class="file-size">${formatFileSize(file.size)}</div>
                        </div>
                        <button class="download-btn" onclick="downloadFile('${file.name}')">Download</button>
                    `;
                    fileList.appendChild(fileItem);
                });
            } catch (error) {
                console.error('Error:', error);
                const fileList = document.getElementById('completionFileList');
                fileList.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">Error loading files.</div>';
            }
        }

        function updateDownloadCircularProgress(percentage, elapsedTime, speed, downloaded, total, eta = null) {
            // Update circular progress for downloads
            const progressCircle = document.getElementById('downloadProgressCircle');
            const roundedPercentage = Math.round(percentage);
            progressCircle.style.setProperty('--progress', roundedPercentage);
            
            // Update text content
            document.getElementById('downloadProgressPercentage').textContent = `${roundedPercentage}% completed`;
            document.getElementById('downloadTimeRemaining').textContent = elapsedTime; // Show elapsed time
            document.getElementById('downloadSpeed').textContent = speed;
            
            // Update time remaining ETA if provided
            if (eta) {
                document.getElementById('downloadTimeRemainingETA').textContent = eta;
            }
            
            // Update stats
            const downloadedGB = (downloaded / (1024 * 1024 * 1024)).toFixed(2);
            const totalGB = (total / (1024 * 1024 * 1024)).toFixed(2);
            document.getElementById('downloadProgressText').textContent = `${downloadedGB} GB / ${totalGB} GB`;
        }

        function cancelUpload() {
            // Set cancellation flag to stop new uploads IMMEDIATELY
            isUploadCancelled = true;
            console.log('Upload cancellation requested - stopping all active uploads');
            
            // Immediately disable performance tracking to prevent any more logging
            performanceTracker.disabled = true;
            
            // Abort all active XMLHttpRequest objects
            activeXhrRequests.forEach((xhr, index) => {
                if (xhr && xhr.readyState !== XMLHttpRequest.DONE) {
                    console.log(`Aborting active upload request ${index + 1}/${activeXhrRequests.length}`);
                    xhr.abort();
                }
            });
            activeXhrRequests = []; // Clear the array
            
            // Reset global upload state
            isUploadActive = false;
            isUploadCompleted = false;
            console.log('Upload cancelled - resetting global state');
            
            // Hide progress section and show upload section
            hideProgressSection();
            
            // Clear any running timers
            if (uploadTimerInterval) clearInterval(uploadTimerInterval);
            
            // Clear selected files
            if (selectedFiles && selectedFiles.length > 0) {
                selectedFiles = [];
                updateSelectedFilesDisplay();
                updateSendButton();
            }
            
            // Reset file input
            const fileInput = document.getElementById('fileInput');
            if (fileInput) fileInput.value = '';
            
            // Reset progress displays
            const progressCircle = document.getElementById('progressCircle');
            if (progressCircle) progressCircle.style.setProperty('--progress', 0);
            
            const progressPercentage = document.getElementById('progressPercentage');
            if (progressPercentage) progressPercentage.textContent = '0% completed';
            
            const timeRemaining = document.getElementById('timeRemaining');
            if (timeRemaining) timeRemaining.textContent = '00:00:00';
            
            const timeRemainingETA = document.getElementById('timeRemainingETA');
            if (timeRemainingETA) timeRemainingETA.textContent = 'Calculating...';
            
            const uploadSpeed = document.getElementById('uploadSpeed');
            if (uploadSpeed) uploadSpeed.textContent = '0.00 Mbps';
            
            const uploadProgress = document.getElementById('uploadProgress');
            if (uploadProgress) uploadProgress.textContent = '0 GB / 0 GB';
            
            // Reset upload tracking variables
            lastUploadTime = 0;
            lastUploadSize = 0;
            lastLoaded = 0;
            uploadStartTime = 0;
            etaHistory = [];
            speedHistory = [];
            
            // Reset cancellation flag after cleanup
            setTimeout(() => {
                isUploadCancelled = false;
                console.log('Upload cancellation cleanup complete');
            }, 1000);
            
            // No alert popup - silent cancellation
        }

        // Global variables
        let selectedFiles = [];
        let currentSection = 'upload'; // 'upload' or 'download'

        // Global upload state tracking
        let isUploadActive = false;
        let isUploadCompleted = false;
        let isUploadCancelled = false; // Add cancellation flag
        let isDownloadActive = false; // Add download active flag
        let isDownloadCompleted = false; // Add download completion flag
        let currentDownloadFileName = null; // Track currently downloading file
        let activeXhrRequests = []; // Track active XMLHttpRequest objects for cancellation

        // üõë CLEANUP - Reset states to stop any running intervals
        (function cleanup() {
            isUploadActive = false;
            isUploadCancelled = false;
            isDownloadActive = false;
            activeUploads = 0;
            console.log('üõë States reset - any running intervals will auto-stop');
        })();

        // Tab Management
        function switchTab(tabName) {
            const uploadSection = document.getElementById('uploadSection');
            const downloadSection = document.getElementById('downloadSection');
            const progressSection = document.getElementById('progressSection');
            const completionSection = document.getElementById('completionSection');
            const downloadCompletionScreen = document.getElementById('downloadCompletionScreen');
            const uploadTab = document.getElementById('uploadTab');
            const downloadTab = document.getElementById('downloadTab');
            
            // Update tab states
            uploadTab.classList.remove('active');
            downloadTab.classList.remove('active');
            
            // Show/hide sections
            if (tabName === 'upload') {
                downloadSection.classList.add('hidden');
                downloadCompletionScreen.classList.add('hidden'); // Hide download completion when switching to upload
                uploadTab.classList.add('active');
                currentSection = 'upload';
                
                // Check what state we should show in upload tab based on global state
                if (isUploadActive) {
                    // There's an active upload - show progress section
                    uploadSection.classList.add('hidden');
                    progressSection.classList.remove('hidden');
                    completionSection.classList.add('hidden');
                    console.log('Showing progress section - upload is active');
                } else if (isUploadCompleted) {
                    // There's a completion screen - show it
                    uploadSection.classList.add('hidden');
                    progressSection.classList.add('hidden');
                    completionSection.classList.remove('hidden');
                    console.log('Showing completion section - upload completed');
                } else {
                    // Normal state - show upload section
                    uploadSection.classList.remove('hidden');
                    progressSection.classList.add('hidden');
                    completionSection.classList.add('hidden');
                    console.log('Showing upload section - normal state');
                }
            } else if (tabName === 'download') {
                uploadSection.classList.add('hidden');
                progressSection.classList.add('hidden'); // Hide progress when switching to download (but don't change state)
                completionSection.classList.add('hidden'); // Hide upload completion when switching to download
                downloadTab.classList.add('active');
                currentSection = 'download';
                
                // Check what state we should show in download tab based on global state
                if (isDownloadActive) {
                    // There's an active download - show download section with progress
                    downloadSection.classList.remove('hidden');
                    downloadCompletionScreen.classList.add('hidden');
                    document.getElementById('downloadProgressSection').classList.remove('hidden');
                    console.log('Showing download progress - download is active');
                } else if (isDownloadCompleted) {
                    // Download completion is active - show full-screen completion
                    downloadSection.classList.add('hidden');
                    downloadCompletionScreen.classList.remove('hidden');
                    document.getElementById('downloadProgressSection').classList.add('hidden');
                    console.log('Showing download completion screen');
                } else {
                    // Normal state - show download section
                    downloadSection.classList.remove('hidden');
                    downloadCompletionScreen.classList.add('hidden');
                    document.getElementById('downloadProgressSection').classList.add('hidden');
                    refreshFileList(); // Refresh file list when switching to downloads
                    console.log('Showing download section - normal state');
                }
            }
        }

        // File Selection Management
        function updateSelectedFilesDisplay() {
            const uploadZone = document.getElementById('uploadZone');
            const uploadContent = document.getElementById('uploadContent');
            const uploadZoneFiles = document.getElementById('uploadZoneFiles');
            const selectedFilesDiv = document.getElementById('selectedFiles');
            
            // Hide the old selected files section
                selectedFilesDiv.style.display = 'none';
            
            if (selectedFiles.length === 0) {
                // No files - show normal upload content
                uploadZone.classList.remove('has-files');
                uploadContent.style.display = 'flex';
                uploadZoneFiles.innerHTML = '';
                return;
            }
            
            // Has files - show files inside upload zone
            uploadZone.classList.add('has-files');
            uploadContent.style.display = 'flex';
            uploadZoneFiles.innerHTML = '';
            
            selectedFiles.forEach((file, index) => {
                const fileDiv = document.createElement('div');
                fileDiv.className = 'upload-zone-file';
                fileDiv.innerHTML = `
                    <div class="upload-zone-file-info">
                        <div class="upload-zone-file-name">${file.name}</div>
                        <div class="upload-zone-file-size">${formatFileSize(file.size)}</div>
                    </div>
                    <button class="upload-zone-file-remove" onclick="removeFile(${index})" title="Remove file">‚úï</button>
                `;
                uploadZoneFiles.appendChild(fileDiv);
            });
        }

        function removeFile(index) {
            selectedFiles.splice(index, 1);
            updateSelectedFilesDisplay();
            updateSendButton();
        }

        function updateSendButton() {
            const sendButton = document.getElementById('sendButton');
            sendButton.disabled = selectedFiles.length === 0;
        }

        // Drag and Drop Functionality
        function setupDragAndDrop() {
            const uploadZone = document.getElementById('uploadZone');
            
            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('dragover');
            });
            
            uploadZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('dragover');
            });
            
            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('dragover');
                
                const files = Array.from(e.dataTransfer.files);
                if (files.length > 0) {
                    // Filter for video files only
                    const videoFiles = files.filter(file => isValidVideoFile(file));
                    if (videoFiles.length > 0) {
                        // Only allow 1 file at a time - replace existing selection
                        selectedFiles = [videoFiles[0]]; // Take only the first file
                        updateSelectedFilesDisplay();
                        updateSendButton();
                    } else {
                        alert('Please select video files only.');
                    }
                }
            });
        }

        // File Input Event Listeners
        function setupFileInputs() {
            const fileInput = document.getElementById('fileInput');
            const folderInput = document.getElementById('folderInput');
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    const files = Array.from(e.target.files);
                    const videoFiles = files.filter(file => isValidVideoFile(file));
                    if (videoFiles.length > 0) {
                        // Only allow 1 file at a time - replace existing selection
                        selectedFiles = [videoFiles[0]]; // Take only the first file
                        updateSelectedFilesDisplay();
                        updateSendButton();
                    } else {
                        alert('Please select video files only.');
                    }
                }
            });
            
            folderInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    const files = Array.from(e.target.files);
                    const videoFiles = files.filter(file => isValidVideoFile(file));
                    if (videoFiles.length > 0) {
                        // Only allow 1 file at a time - replace existing selection
                        selectedFiles = [videoFiles[0]]; // Take only the first file
                        updateSelectedFilesDisplay();
                        updateSendButton();
                    } else {
                        alert('No video files found in the selected folder(s).');
                    }
                }
            });
        }

        // Video file validation
        function isValidVideoFile(file) {
            // List of supported video formats
            const supportedFormats = {
                'video/mp4': '.mp4',
                'video/quicktime': '.mov',
                'video/x-msvideo': '.avi',
                'video/x-matroska': '.mkv',
                'video/webm': '.webm',
                'video/x-ms-wmv': '.wmv',
                'application/mxf': '.mxf'  // Added MXF format
            };

            // Check file extension
            const extension = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));
            const validExtension = Object.values(supportedFormats).includes(extension);

            // Check MIME type
            const validMimeType = Object.keys(supportedFormats).includes(file.type);

            if (!validExtension && !validMimeType) {
                const supportedList = Object.values(supportedFormats).join(', ');
                alert(`Unsupported video format. Please use one of these formats: ${supportedList}`);
                return false;
            }

            return true;
        }

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');
            const minutes = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0');
            const seconds = String(totalSeconds % 60).padStart(2, '0');
            return `${hours}:${minutes}:${seconds}`;
        }

        function formatFileSize(bytes) {
            if (bytes >= 1024 * 1024 * 1024) {
                return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
            } else if (bytes >= 1024 * 1024) {
                return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
            } else if (bytes >= 1024) {
                return (bytes / 1024).toFixed(2) + ' KB';
            }
            return bytes + ' bytes';
        }

        function getTimestampedFilename(filename) {
            const dotIndex = filename.lastIndexOf('.');
            const base = dotIndex !== -1 ? filename.substring(0, dotIndex) : filename;
            const ext = dotIndex !== -1 ? filename.substring(dotIndex) : '';
            const now = new Date();
            const timestamp = `${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}_${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}${String(now.getSeconds()).padStart(2,'0')}`;
            return `${base}_${timestamp}${ext}`;
        }

        // Smooth ETA calculation to prevent jumping
        function calculateSmoothETA(loaded, total, currentSpeed) {
            if (currentSpeed <= 0) return 'Calculating...';
            
            const remainingBytes = total - loaded;
            const rawEta = remainingBytes / (currentSpeed * 1024 * 1024); // seconds
            
            // Add to history for smoothing
            etaHistory.push(rawEta);
            if (etaHistory.length > 15) etaHistory.shift(); // Keep last 15 readings for more stability
            
            // Calculate weighted average (recent readings have more weight)
            let weightedSum = 0;
            let weightSum = 0;
            for (let i = 0; i < etaHistory.length; i++) {
                const weight = i + 1; // Newer readings get higher weight
                weightedSum += etaHistory[i] * weight;
                weightSum += weight;
            }
            
            const smoothedEta = weightedSum / weightSum;
            return formatTime(smoothedEta * 1000);
        }

        // Smooth speed calculation with better averaging
        function calculateSmoothSpeed(bytesSinceLast, timeSinceLast) {
            if (timeSinceLast <= 0) return 0;
            
            const currentSpeed = (bytesSinceLast / 1024 / 1024) / timeSinceLast; // MB/s
            
            // Add to history for smoothing
            speedHistory.push(currentSpeed);
            if (speedHistory.length > 12) speedHistory.shift(); // Keep last 12 readings for stability
            
            // Calculate weighted average with exponential smoothing
            let weightedSum = 0;
            let weightSum = 0;
            for (let i = 0; i < speedHistory.length; i++) {
                const weight = Math.pow(1.5, i); // Exponential weighting
                weightedSum += speedHistory[i] * weight;
                weightSum += weight;
            }
            
            return weightedSum / weightSum;
        }

        // Initialize the interface
        document.addEventListener('DOMContentLoaded', function() {
            setupDragAndDrop();
            setupFileInputs();
            updateSendButton();
            
            // Initial file list load for downloads
            refreshFileList();
        });

        function showCompletionScreen(totalTime, fileSize, avgSpeed, fileCount = 1) {
            isUploadActive = false;
            isUploadCompleted = true;
            console.log('Upload completed - setting isUploadCompleted to true');
            
            document.getElementById('progressSection').classList.add('hidden');
            document.getElementById('completionSection').classList.remove('hidden');
            
            // Update completion screen content
            document.getElementById('completionTime').textContent = `Total time ${formatTime(totalTime)}`;
            document.getElementById('completionSpeed').textContent = `${avgSpeed.toFixed(2)} Mbps`;
            
            const fileSizeGB = (fileSize / (1024 * 1024 * 1024)).toFixed(2);
            document.getElementById('completionUploaded').textContent = `${fileSizeGB} GB`;
        }

        function startNewUpload() {
            // Reset upload states
            isUploadActive = false;
            isUploadCompleted = false;
            
            // Hide completion screen and show upload section
            document.getElementById('completionSection').classList.add('hidden');
            document.getElementById('uploadSection').classList.remove('hidden');
            
            // Clear selected files
            if (selectedFiles && selectedFiles.length > 0) {
                        selectedFiles = [];
                        updateSelectedFilesDisplay();
                        updateSendButton();
            }
            
            // Reset file input
            const fileInput = document.getElementById('fileInput');
            if (fileInput) fileInput.value = '';
        }

        // Function to disable all download buttons
        function disableAllDownloadButtons() {
            const downloadButtons = document.querySelectorAll('.download-btn');
            downloadButtons.forEach(button => {
                button.disabled = true;
                button.style.opacity = '0.5';
                button.style.cursor = 'not-allowed';
                // Only change text for buttons that aren't the active download
                if (button.textContent === 'Download') {
                    button.textContent = 'Another Download in Progress...';
                }
            });
        }

        // Function to enable all download buttons
        function enableAllDownloadButtons() {
            const downloadButtons = document.querySelectorAll('.download-btn');
            downloadButtons.forEach(button => {
                button.disabled = false;
                button.style.opacity = '1';
                button.style.cursor = 'pointer';
                button.textContent = 'Download';
            });
        }

        function hideDownloadProgressOnError() {
            // Reset download active state on error
            isDownloadActive = false;
            isDownloadCompleted = false;
            currentDownloadFileName = null;
            console.log('Download error - resetting download states');
            
            document.getElementById('downloadProgressSection').classList.add('hidden');
            // Hide completion screen if it was shown
            document.getElementById('downloadCompletionScreen').classList.add('hidden');
            // Show download section
            document.getElementById('downloadSection').classList.remove('hidden');
            // Re-enable all download buttons without showing completion
            enableAllDownloadButtons();
        }

        function startNewDownload() {
            // Reset download completion state
            isDownloadCompleted = false;
            
            // Hide completion screen and show download section
            document.getElementById('downloadCompletionScreen').classList.add('hidden');
            document.getElementById('downloadSection').classList.remove('hidden');
            
            // Refresh file list in the main download section
            refreshFileList();
        }

        // üöÄ STREAMING DOWNLOAD WITHOUT BLOB - Bypasses Chrome's blob processing delays
        async function streamingDownloadNoBlobDelay(fileName, publicUrl, fileSize, startTime) {
            try {
                console.log('Starting real progress download...');
                
                const response = await fetch(publicUrl);
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                
                const reader = response.body.getReader();
                let receivedLength = 0;
                let chunks = [];
                let lastTime = Date.now();
                let lastBytes = 0;
                let speeds = [];
                
                console.log('Real download progress started');
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    chunks.push(value);
                    receivedLength += value.length;
                    
                    // Update progress every 500ms for responsive UI
                    const now = Date.now();
                    if (now - lastTime >= 500) {
                        const percent = Math.round((receivedLength / fileSize) * 100);
                        const bytesSinceLast = receivedLength - lastBytes;
                        const timeSinceLast = (now - lastTime) / 1000;
                        const currentSpeed = (bytesSinceLast / 1024 / 1024) / timeSinceLast; // MB/s
                        
                        speeds.push(currentSpeed);
                        if (speeds.length > 8) speeds.shift(); // Keep last 8 readings
                        
                        const avgSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
                        const avgSpeedMbps = avgSpeed * 8; // Convert to Mbps
                        
                        // Calculate ETA
                        const remainingBytes = fileSize - receivedLength;
                        const eta = remainingBytes / (avgSpeed * 1024 * 1024);
                        const elapsedTime = now - startTime;
                        
                        // Update download circular progress with real data
                        updateDownloadCircularProgress(
                            percent,
                            formatTime(elapsedTime),
                            `${avgSpeedMbps.toFixed(2)} Mbps`,
                            receivedLength,
                            fileSize,
                            formatTime(eta * 1000)
                        );
                        
                        lastTime = now;
                        lastBytes = receivedLength;
                    }
                }
                
                console.log('Download complete, creating optimized blob...');
                
                // Optimized blob creation with immediate download
                const blob = new Blob(chunks, { 
                    type: 'application/octet-stream'
                });
                
                // Immediate download trigger
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.style.display = 'none';
                document.body.appendChild(a);
                
                // Trigger download immediately
                a.click();
                
                // Clean up after short delay
                setTimeout(() => {
                    window.URL.revokeObjectURL(url);
                    a.remove();
                }, 1000);
                
                // Success with real timing
                clearInterval(downloadTimerInterval);
                const downloadTime = Date.now() - startTime;
                const downloadSize = blob.size;
                
                hideDownloadProgress(downloadTime, downloadSize);
                
                // Show real average speed
                if (downloadTime > 0 && downloadSize > 0) {
                    const mb = downloadSize / 1024 / 1024;
                    const sec = downloadTime / 1000;
                    const speedMBs = mb / sec;
                    const speedMbps = speedMBs * 8;
                    document.getElementById('downloadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps (avg)`;
                }
                
                console.log(`Real download complete: ${formatFileSize(downloadSize)} in ${formatTime(downloadTime)}`);
                
                // Log download
                await logDownload(fileName, downloadSize, 'real-progress', document.getElementById('downloadSpeed').textContent);
                
            } catch (error) {
                console.error('Download error:', error);
                hideDownloadProgressOnError();
                clearInterval(downloadTimerInterval);
                document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
                alert(`Download failed: ${error.message}`);
            }
        }

        // üåä STREAMING DOWNLOAD with ERR_CONTENT_LENGTH_MISMATCH detection
        async function streamingDownload(fileName, publicUrl, fileSize, startTime) {
            try {
                const response = await fetch(publicUrl);
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                
                const reader = response.body.getReader();
                let receivedLength = 0;
                let chunks = [];
                let lastTime = Date.now();
                let lastBytes = 0;
                let speeds = [];
                
                console.log('Streaming download started');
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    chunks.push(value);
                    receivedLength += value.length;
                    
                    // Update progress
                    const percent = Math.round((receivedLength / fileSize) * 100);
                    
                    // Calculate speed and ETA (update every 1 second for stability)
                    const now = Date.now();
                    if (now - lastTime >= 1000) {
                        const bytesSinceLast = receivedLength - lastBytes;
                        const timeSinceLast = (now - lastTime) / 1000;
                        const currentSpeed = (bytesSinceLast / 1024 / 1024) / timeSinceLast; // MB/s
                        
                        speeds.push(currentSpeed);
                        if (speeds.length > 6) speeds.shift(); // Keep fewer readings for stability
                        
                        const avgSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
                        const avgSpeedMbps = avgSpeed * 8; // Convert to Mbps
                        
                        // Calculate ETA with smoothing
                        const remainingBytes = fileSize - receivedLength;
                        const eta = remainingBytes / (avgSpeed * 1024 * 1024);
                        const elapsedTime = now - startTime;
                        
                        // Update download circular progress
                        updateDownloadCircularProgress(
                            percent,
                            formatTime(elapsedTime), // Show elapsed time
                            `${avgSpeedMbps.toFixed(2)} Mbps`,
                            receivedLength,
                            fileSize,
                            formatTime(eta * 1000) // Show time remaining
                        );
                        
                        lastTime = now;
                        lastBytes = receivedLength;
                    }
                }
                
                // Check for content-length mismatch
                if (receivedLength !== fileSize) {
                    console.warn(`ERR_CONTENT_LENGTH_MISMATCH detected: expected ${fileSize}, received ${receivedLength}`);
                    throw new Error(`ERR_CONTENT_LENGTH_MISMATCH: Content-Length promised ${fileSize} bytes but only ${receivedLength} bytes received`);
                }
                
                // Create and download blob with optimizations
                const blob = new Blob(chunks, { 
                    type: 'application/octet-stream',
                    // Add explicit type to help Chrome's scanner
                    endings: 'native'
                });

                // Download assembled file with optimizations
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.style.display = 'none';
                document.body.appendChild(a);

                // Force immediate download
                setTimeout(() => {
                    a.click();
                    setTimeout(() => {
                        window.URL.revokeObjectURL(url);
                        a.remove();
                    }, 1000);
                }, 100);
                
                // Success
                clearInterval(downloadTimerInterval);
                const downloadTime = Date.now() - startTime;
                const downloadSize = blob.size;
                
                hideDownloadProgress(downloadTime, downloadSize);
                
                // Show average speed
                if (downloadTime > 0 && downloadSize > 0) {
                    const mb = downloadSize / 1024 / 1024;
                    const sec = downloadTime / 1000;
                    const speedMBs = mb / sec; // MB/s
                    const speedMbps = speedMBs * 8; // Convert to Mbps
                    document.getElementById('downloadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps (avg)`;
                }
                
                console.log(`Streaming download complete: ${formatFileSize(downloadSize)} in ${formatTime(downloadTime)}`);
                
                // Log download
                await logDownload(fileName, downloadSize, 'streaming', document.getElementById('downloadSpeed').textContent);
                
            } catch (error) {
                console.error('Streaming download error:', error);
                
                // Detect content-length mismatch errors
                if (error.message.includes('ERR_CONTENT_LENGTH_MISMATCH') || error.message.includes('Content-Length')) {
                    console.log('Content-Length mismatch detected, falling back to chunked download');
                    await chunkedDownload(fileName, publicUrl, fileSize, startTime);
                } else {
                    // Show error
                    hideDownloadProgressOnError();
                    clearInterval(downloadTimerInterval);
                    document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
                    alert(`Download failed: ${error.message}`);
                }
            }
        }

        // üß© CHUNKED DOWNLOAD: Last resort for ERR_CONTENT_LENGTH_MISMATCH
        async function chunkedDownload(fileName, publicUrl, fileSize, startTime) {
            try {
                const CHUNK_SIZE = 10 * 1024 * 1024; // 10MB chunks
                const totalChunks = Math.ceil(fileSize / CHUNK_SIZE);
                let chunks = new Array(totalChunks);
                let bytesDownloaded = 0;
                let lastTime = Date.now();
                let lastBytes = 0;
                let speeds = [];
                
                console.log(`Chunked download started: ${totalChunks} chunks of ${formatFileSize(CHUNK_SIZE)}`);
                
                async function downloadChunk(chunkIndex, retries = 3) {
                    const start = chunkIndex * CHUNK_SIZE;
                    const end = Math.min(start + CHUNK_SIZE - 1, fileSize - 1);
                    
                    for (let attempt = 1; attempt <= retries; attempt++) {
                        try {
                            const response = await fetch(publicUrl, {
                                headers: { 'Range': `bytes=${start}-${end}` }
                            });
                            
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            
                            const chunk = await response.arrayBuffer();
                            chunks[chunkIndex] = chunk;
                            
                            const chunkSize = chunk.byteLength;
                            bytesDownloaded += chunkSize;
                            
                            // Update progress
                            const percent = Math.round((bytesDownloaded / fileSize) * 100);
                            
                            // Calculate speed and ETA
                            const now = Date.now();
                            if (now - lastTime >= 500) {
                                const bytesSinceLast = bytesDownloaded - lastBytes;
                                const timeSinceLast = (now - lastTime) / 1000;
                                const currentSpeed = (bytesSinceLast / 1024 / 1024) / timeSinceLast; // MB/s
                                
                                speeds.push(currentSpeed);
                                if (speeds.length > 6) speeds.shift();
                                
                                const avgSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
                                const avgSpeedMbps = avgSpeed * 8; // Convert to Mbps
                                
                                const remainingBytes = fileSize - bytesDownloaded;
                                const eta = remainingBytes / (avgSpeed * 1024 * 1024);
                                const elapsedTime = now - startTime;
                                
                                // Update download circular progress
                                updateDownloadCircularProgress(
                                    percent,
                                    formatTime(elapsedTime), // Show elapsed time
                                    `${avgSpeedMbps.toFixed(2)} Mbps`,
                                    bytesDownloaded,
                                    fileSize,
                                    formatTime(eta * 1000) // Show time remaining
                                );
                                
                                lastTime = now;
                                lastBytes = bytesDownloaded;
                            }
                            
                            console.log(`Chunk ${chunkIndex + 1}/${totalChunks} complete (${formatFileSize(chunkSize)})`);
                            return;
                            
                        } catch (error) {
                            console.warn(`Chunk ${chunkIndex + 1} attempt ${attempt} failed:`, error.message);
                            
                            if (attempt === retries) {
                                throw new Error(`Chunk ${chunkIndex + 1} failed after ${retries} attempts: ${error.message}`);
                            }
                            
                            // Wait before retry
                            await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                        }
                    }
                }
                
                // Download all chunks in parallel (limited concurrency)
                const concurrency = 3;
                for (let i = 0; i < totalChunks; i += concurrency) {
                    const batch = [];
                    for (let j = 0; j < concurrency && i + j < totalChunks; j++) {
                        batch.push(downloadChunk(i + j));
                    }
                    await Promise.all(batch);
                }
                
                // Reassemble file
                const blob = new Blob(chunks.map(chunk => new Uint8Array(chunk)), { type: 'application/octet-stream' });
                
                // Download assembled file
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                a.remove();
                
                // Success
                clearInterval(downloadTimerInterval);
                const downloadTime = Date.now() - startTime;
                const downloadSize = blob.size;
                
                hideDownloadProgress(downloadTime, downloadSize);
                
                // Show average speed
                if (downloadTime > 0 && downloadSize > 0) {
                    const mb = downloadSize / 1024 / 1024;
                    const sec = downloadTime / 1000;
                    const speedMBs = mb / sec; // MB/s
                    const speedMbps = speedMBs * 8; // Convert to Mbps
                    document.getElementById('downloadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps (avg)`;
                }
                
                console.log(`Chunked download complete: ${formatFileSize(downloadSize)} in ${formatTime(downloadTime)}`);
                
                // Log download
                await logDownload(fileName, downloadSize, 'chunked', document.getElementById('downloadSpeed').textContent);
                
            } catch (error) {
                console.error('Chunked download error:', error);
                hideDownloadProgressOnError();
                clearInterval(downloadTimerInterval);
                document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
                alert(`Chunked download failed: ${error.message}`);
            }
        }

        // üìä Log download to backend
        async function logDownload(fileName, fileSize, method, speed) {
            try {
                const connectionQuality = typeof detectConnectionQuality === 'function' ? await detectConnectionQuality() : 'unknown';
                await fetch('/api/log-download', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileName,
                        fileSize,
                        method,
                        contentType: 'application/octet-stream',
                        connectionQuality,
                        speed,
                        userAgent: navigator.userAgent
                    })
                });
            } catch (error) {
                console.warn('Failed to log download:', error.message);
            }
        }

        // üîó DIRECT URL DOWNLOAD: For HTTP environments without File System Access API
        async function directUrlDownload(fileName, publicUrl, fileSize, startTime) {
            try {
                console.log('Starting direct URL download (HTTP environment)...');
                
                // Show fake progress for UI while browser handles download
                let fakeProgress = 0;
                const progressInterval = setInterval(() => {
                    if (fakeProgress < 95) {
                        fakeProgress += Math.random() * 15;
                        const elapsedTime = Date.now() - startTime;
                        
                        updateDownloadCircularProgress(
                            Math.round(Math.min(fakeProgress, 95)),
                            formatTime(elapsedTime),
                            'Preparing...',
                            (fakeProgress / 100) * fileSize,
                            fileSize,
                            'Calculating...'
                        );
                    }
                }, 200);
                
                // Create download link with direct URL
                const a = document.createElement('a');
                a.href = publicUrl;
                a.download = fileName;
                a.style.display = 'none';
                a.rel = 'noopener';
                document.body.appendChild(a);
                
                // Trigger download
                a.click();
                
                // Clean up
                setTimeout(() => {
                    a.remove();
                    clearInterval(progressInterval);
                    
                    // Go directly to completion screen
                    const downloadTime = Date.now() - startTime;
                    
                    // Show final speed for small files
                    const estimatedSpeed = (fileSize / 1024 / 1024) / (downloadTime / 1000) * 8; // Rough estimate in Mbps
                    document.getElementById('downloadSpeed').textContent = `${estimatedSpeed.toFixed(2)} Mbps (est)`;
                    
                    // Go directly to completion screen without delay
                        hideDownloadProgress(downloadTime, fileSize);
                        console.log(`Direct URL download initiated: ${formatFileSize(fileSize)}`);
                }, 2000);
                
            } catch (error) {
                console.error('Direct URL download error:', error);
                hideDownloadProgressOnError();
                clearInterval(downloadTimerInterval);
                alert(`Download failed: ${error.message}`);
            }
        }

        // üìä Log download to backend
        async function logDownload(fileName, fileSize, method, speed) {
            try {
                const connectionQuality = typeof detectConnectionQuality === 'function' ? await detectConnectionQuality() : 'unknown';
                await fetch('/api/log-download', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileName,
                        fileSize,
                        method,
                        contentType: 'application/octet-stream',
                        connectionQuality,
                        speed,
                        userAgent: navigator.userAgent
                    })
                });
            } catch (error) {
                console.warn('Failed to log download:', error.message);
            }
        }

        // On page load, set timers to last value or 00:00:00
        window.onload = function() {
            if (lastUploadTime > 0 && lastUploadSize > 0) {
                const mb = lastUploadSize / 1024 / 1024;
                const sec = lastUploadTime / 1000;
                const speedMBs = mb / sec; // MB/s
                const speedMbps = speedMBs * 8; // Convert to Mbps
                document.getElementById('uploadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps`;
            } else {
                document.getElementById('uploadSpeed').textContent = '0.00 Mbps';
            }
            if (lastDownloadTime > 0 && lastDownloadSize > 0) {
                const mb = lastDownloadSize / 1024 / 1024;
                const sec = lastDownloadTime / 1000;
                const speedMBs = mb / sec; // MB/s
                const speedMbps = speedMBs * 8; // Convert to Mbps
                document.getElementById('downloadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps`;
            } else {
                document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
            }
        };

        // Initial file list load
        refreshFileList();

        // Simple static password protection
        (function() {
            var password = 'wnet';
            var entered = sessionStorage.getItem('wnet_auth');
            if (entered !== password) {
                while (true) {
                    var input = prompt('Enter password to access this page:');
                    if (input === null) {
                        document.body.innerHTML = '<h2>Access denied.</h2>';
                        throw new Error('Access denied');
                    }
                    if (input === password) {
                        sessionStorage.setItem('wnet_auth', password);
                        break;
                    }
                }
            }
        })();

        // UI Management Functions - keeping the beautiful UI
        function generatePackageId() {
            const now = new Date();
            const timestamp = now.getFullYear().toString() + 
                             (now.getMonth() + 1).toString().padStart(2, '0') + 
                             now.getDate().toString().padStart(2, '0') + 
                             now.getHours().toString().padStart(2, '0') + 
                             now.getMinutes().toString().padStart(2, '0') + 
                             now.getSeconds().toString().padStart(2, '0');
            return `WNET-R2-${timestamp}`;
        }

        function showProgressSection(fileName) {
            isUploadActive = true;
            isUploadCompleted = false;
            isUploadCancelled = false; // Reset cancellation flag for new upload
            activeXhrRequests = []; // Clear any previous requests
            performanceTracker.disabled = false; // Re-enable performance tracking for new upload
            console.log('Upload started - setting isUploadActive to true');
            document.getElementById('uploadSection').classList.add('hidden');
            document.getElementById('progressSection').classList.remove('hidden');
        }

        function hideProgressSection() {
            document.getElementById('uploadSection').classList.remove('hidden');
            document.getElementById('progressSection').classList.add('hidden');
        }

        function updateCircularProgress(percentage, elapsedTime, speed, uploaded, total, eta = null) {
            const progressCircle = document.getElementById('progressCircle');
            // Use percentage directly (0-100)
            progressCircle.style.setProperty('--progress', percentage);
            
            document.getElementById('progressPercentage').textContent = `${percentage}% completed`;
            document.getElementById('timeRemaining').textContent = elapsedTime; // Show elapsed time
            document.getElementById('uploadSpeed').textContent = speed;
            
            // Update time remaining ETA if provided
            if (eta) {
                document.getElementById('timeRemainingETA').textContent = eta;
            }
            
            const uploadedGB = (uploaded / (1024 * 1024 * 1024)).toFixed(2);
            const totalGB = (total / (1024 * 1024 * 1024)).toFixed(2);
            document.getElementById('uploadProgress').textContent = `${uploadedGB} GB / ${totalGB} GB`;
        }

        function showDownloadProgress(fileName) {
            // Set download active state and track current file
            isDownloadActive = true;
            isDownloadCompleted = false;
            currentDownloadFileName = fileName;
            console.log('Download started - setting isDownloadActive to true');
            
            // RESET PROGRESS BAR: Clear any previous green completion styling
            const progressCircle = document.getElementById('downloadProgressCircle');
            progressCircle.style.setProperty('--progress', 0);
            progressCircle.style.background = ''; // Reset to default blue gradient
            
            // Reset text content to default blue styling
            document.getElementById('downloadProgressPercentage').textContent = '0% completed';
            document.getElementById('downloadProgressPercentage').style.color = '#4A90E2'; // Blue text
            document.getElementById('downloadTimeRemaining').textContent = '00:00:00';
            document.getElementById('downloadTimeRemainingETA').textContent = 'Calculating...';
            document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
            
            // Hide completion screen if it's currently showing
            document.getElementById('downloadCompletionScreen').classList.add('hidden');
            // Show download section and progress
            document.getElementById('downloadSection').classList.remove('hidden');
            document.getElementById('downloadProgressSection').classList.remove('hidden');
            
            // Disable all download buttons and mark the active one
            disableAllDownloadButtons();
            markActiveDownloadButton(fileName);
        }

        // Function to mark the active download button
        function markActiveDownloadButton(fileName) {
            const downloadButtons = document.querySelectorAll('.download-btn');
            downloadButtons.forEach(button => {
                // Find the button for this specific file
                const fileItem = button.closest('.file-item');
                if (fileItem) {
                    const fileNameElement = fileItem.querySelector('.file-name');
                    if (fileNameElement && fileNameElement.textContent === fileName) {
                        button.textContent = 'Downloading...';
                        button.style.background = '#e0f2fe';
                        button.style.borderColor = '#0ea5e9';
                        button.style.color = '#0ea5e9';
                    }
                }
            });
        }

        function hideDownloadProgress(downloadTime = null, downloadSize = null) {
            // Reset download active state and clear current file
            isDownloadActive = false;
            currentDownloadFileName = null;
            console.log('Download completed - setting isDownloadActive to false');
            
            // Debug: Log the parameters being passed
            console.log('hideDownloadProgress called with:', {
                downloadTime,
                downloadSize,
                downloadTimeInSeconds: downloadTime ? downloadTime / 1000 : null,
                downloadSizeInMB: downloadSize ? downloadSize / 1024 / 1024 : null
            });
            
            // Update global variables if provided
            if (downloadTime !== null) {
                lastDownloadTime = downloadTime;
                console.log('Updated lastDownloadTime to:', lastDownloadTime);
            }
            if (downloadSize !== null) {
                lastDownloadSize = downloadSize;
                console.log('Updated lastDownloadSize to:', lastDownloadSize);
            }
            
            document.getElementById('downloadProgressSection').classList.add('hidden');
            // Show completion state instead of just hiding
            showDownloadCompletion();
        }

        function showDownloadCompletion() {
            // Set download completion state
            isDownloadCompleted = true;
            
            // Hide download section and show download completion screen
            document.getElementById('downloadSection').classList.add('hidden');
            document.getElementById('downloadCompletionScreen').classList.remove('hidden');
            
            // Debug: Log the values being used
            console.log('showDownloadCompletion called with:', {
                lastDownloadTime,
                lastDownloadSize,
                timeInSeconds: lastDownloadTime / 1000,
                sizeInMB: lastDownloadSize / 1024 / 1024
            });
            
            // Update completion stats
            if (lastDownloadTime > 0 && lastDownloadSize > 0) {
                // Format time as HH:MM:SS
                const totalSeconds = Math.floor(lastDownloadTime / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('downloadCompletionTimeFullScreen').textContent = `Total time ${timeString}`;                
                // Calculate speed in Mbps
                const mb = lastDownloadSize / 1024 / 1024;
                const sec = lastDownloadTime / 1000;
                const speedMBs = mb / sec;
                const speedMbps = speedMBs * 8;
                
                console.log('Speed calculation:', {
                    mb: mb.toFixed(2),
                    sec: sec.toFixed(2),
                    speedMBs: speedMBs.toFixed(2),
                    speedMbps: speedMbps.toFixed(2)
                });
                
                document.getElementById('downloadCompletionSpeedFullScreen').textContent = `${speedMbps.toFixed(2)} Mbps`;                
                // Format size in GB
                const sizeGB = (lastDownloadSize / (1024 * 1024 * 1024)).toFixed(2);
                document.getElementById('downloadCompletionDownloaded').textContent = `${sizeGB} GB`;
            } else {
                console.log('Download completion data missing:', {
                    lastDownloadTime,
                    lastDownloadSize
                });
            }
            
            // Populate file list in completion screen
            populateCompletionFileList();
            
            // Re-enable all download buttons
            enableAllDownloadButtons();
        }

        // Function to populate file list in completion screen
        async function populateCompletionFileList() {
            try {
                const response = await fetch('/api/files');
                const files = await response.json();
                
                const fileList = document.getElementById('completionFileList');
                fileList.innerHTML = '';

                if (files.length === 0) {
                    fileList.innerHTML = '<div style="text-align: center; color: #888; padding: 40px;">No files found.</div>';
                    return;
                }

                files.forEach(file => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.innerHTML = `
                        <div class="file-info">
                            <div class="file-name">${file.name}</div>
                            <div class="file-size">${formatFileSize(file.size)}</div>
                        </div>
                        <button class="download-btn" onclick="downloadFile('${file.name}')">Download</button>
                    `;
                    fileList.appendChild(fileItem);
                });
            } catch (error) {
                console.error('Error:', error);
                const fileList = document.getElementById('completionFileList');
                fileList.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">Error loading files.</div>';
            }
        }

        function updateDownloadCircularProgress(percentage, elapsedTime, speed, downloaded, total, eta = null) {
            // Update circular progress for downloads
            const progressCircle = document.getElementById('downloadProgressCircle');
            const roundedPercentage = Math.round(percentage);
            progressCircle.style.setProperty('--progress', roundedPercentage);
            
            // Update text content
            document.getElementById('downloadProgressPercentage').textContent = `${roundedPercentage}% completed`;
            document.getElementById('downloadTimeRemaining').textContent = elapsedTime; // Show elapsed time
            document.getElementById('downloadSpeed').textContent = speed;
            
            // Update time remaining ETA if provided
            if (eta) {
                document.getElementById('downloadTimeRemainingETA').textContent = eta;
            }
            
            // Update stats
            const downloadedGB = (downloaded / (1024 * 1024 * 1024)).toFixed(2);
            const totalGB = (total / (1024 * 1024 * 1024)).toFixed(2);
            document.getElementById('downloadProgressText').textContent = `${downloadedGB} GB / ${totalGB} GB`;
        }
        
        // üöÄ EARLY CONNECTION ESTABLISHMENT: Trigger on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üîß WNET OPTIMIZED v2.2-EMERGENCY - Aggressive High-Latency Fix Active - ' + new Date().toISOString());
            console.log('üöÄ Triggering early connection establishment...');
            
            // Fire early connection requests to warm up the pipeline
            const earlyWarmupPromises = [];
            
            // Ping endpoints immediately
            earlyWarmupPromises.push(
                fetch('/api/ping', { method: 'HEAD', keepalive: true }).catch(() => {})
            );
            
            // Warm up upload endpoints
            earlyWarmupPromises.push(
                fetch('/api/multipart/start', { method: 'OPTIONS', keepalive: true }).catch(() => {})
            );
            
            // Additional connection triggers
            const img1 = new Image();
            img1.src = '/favicon.ico';
            const img2 = new Image();
            img2.src = '/1x1.png';
            
            Promise.allSettled(earlyWarmupPromises).then(() => {
                console.log('üî• Early connection establishment complete');
            });
        });
    </script>
</body>
</html> 