<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WNET File Transfer</title>
    
    <!-- üöÄ ULTRA-FAST CONNECTION HINTS: Browser-level preconnect -->
    <link rel="preconnect" href="/" crossorigin>
    <link rel="dns-prefetch" href="/">
    <!-- Removed preload links to avoid 404s -->
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8fafc;
            color: #333;
            min-height: 100vh;
        }
        
        /* Wide white background - only for content area */
        .wide-background {
            background-color: #f8fafc;
            width: 100%;
            margin: 0;
            padding: 0;
        }
        
        .background-white {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            width: 80%;
            margin: 0px auto 0px auto;
        }
        
        .container {
            max-width: 600px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.06);
            padding: 0;
            text-align: center;
            position: relative;
        }
        
        /* Wide white background that extends beyond container - only for content sections */
        .container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100vw;
            height: 100%;
            background: white;
            z-index: -1;
            border-radius: 16px;
        }
        
        /* Tab Navigation */
        .tabs {
            display: flex;
            border-bottom: 1px solid #e2e8f0;
            border-radius: 16px 16px 0 0;
            background: #f8fafc;
        }
        .tab {
            flex: 1;
            padding: 18px;
            background: none;
            border: none;
            font-size: 15px;
            font-weight: 600;
            color: #000;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 16px 16px 0 0;
        }
        .tab:first-child {
            border-radius: 16px 0 0 0;
        }
        .tab:last-child {
            border-radius: 0 16px 0 0;
        }
        .tab.active {
            background: white;
            color: #4A90E2;
            border-bottom: 2px solid #4A90E2;
            margin-bottom: -1px;
        }
        .tab:hover:not(.active) {
            background: #f1f5f9;
            color: #475569;
        }
        
        /* Content area */
        .content {
            padding: 60px 40px 40px 40px;
        }
        
        .header {
            margin-bottom: 30px;
        }
        .title {
            font-size: 22px;
            color: #1a1a1a;
            margin-bottom: 12px;
            font-family: Arial, sans-serif;
            font-weight: 600;
        }
        .subtitle {
            font-size: 16px;
            color: #000;
            margin-bottom: 30px;
            font-weight: 400;
        }
        
        /* Large drag and drop area */
        .upload-zone {
            border: 2px dashed #d1d5db;
            border-radius: 12px;
            background: #f9fafb;
            padding: 45px 40px 40px 40px;
            margin-bottom: 0px;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .upload-zone:hover {
            border-color: #1890ff;
            background: #f0f8ff;
        }
        .upload-zone.dragover {
            border-color: #1890ff;
            background: #e6f3ff;
            transform: scale(1.02);
        }
        .upload-zone.has-files {
            padding: 40px;
            justify-content: flex-start;
            align-items: stretch;
        }
        .upload-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
        }
        .upload-icon {
            font-size: 48px;
            color: #1890ff;
            margin-bottom: 20px;
        }
        .upload-text {
            font-size: 20px;
            color: #374151;
            margin-bottom: 8px;
            font-weight: 500;
        }
        .upload-subtext {
            font-size: 14px;
            color: #6b7280;
            margin-bottom: 30px;
        }
        
        /* Files inside upload zone */
        .upload-zone-files {
            width: 100%;
            margin-top: 20px;
        }
        .upload-zone-file {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .upload-zone-file:last-child {
            margin-bottom: 0;
        }
        .upload-zone-file-info {
            flex: 1;
        }
        .upload-zone-file-name {
            font-weight: 500;
            color: #374151;
            margin-bottom: 4px;
            word-break: break-word;
        }
        .upload-zone-file-size {
            font-size: 14px;
            color: #6b7280;
        }
        .upload-zone-file-remove {
            background: none;
            border: none;
            cursor: pointer;
            color: #9ca3af;
            font-size: 18px;
            padding: 4px;
            margin-left: 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        .upload-zone-file-remove:hover {
            color: #ef4444;
            background: #fef2f2;
        }
        
        /* Hidden file inputs */
        .file-inputs {
            display: none;
        }
        
        /* Action buttons */
        .action-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 20px;
        }
        .btn {
            padding: 10px 20px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
            color: #000;
            display: inline-block;
            text-align: center;
        }
        .btn:hover {
            border-color: #4A90E2;
            color: #4A90E2;
        }
        .btn-primary {
            background: white;
            color: #000;
            border-color: #e2e8f0;
            font-size: 13px;
            padding: 10px 40px;
            font-weight: 500;
        }
        .btn-primary:hover {
            background: white;
            border-color: #4A90E2;
            color: #4A90E2;
        }
        .btn-primary:disabled {
            background: #f8fafc;
            border-color: #e2e8f0;
            color: #cbd5e1;
            cursor: not-allowed;
        }
        .btn-primary:disabled:hover {
            background: #f8fafc;
            border-color: #e2e8f0;
            color: #cbd5e1;
        }
        
        /* Selected files display */
        .selected-files {
            margin-top: 20px;
            text-align: left;
            display: none;
        }
        .selected-file {
            padding: 12px 16px;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .file-info {
            flex: 1;
        }
        .file-name {
            font-weight: 500;
            color: #374151;
        }
        .file-size {
            font-size: 12px;
            color: #6b7280;
        }
        
        /* Progress Section */
        .progress-wrapper {
            border: 1px solid #e2e8f0;
            border-radius: 16px;
            padding: 30px;
            margin: 0 auto 30px auto;
            width: 380px;
            background: white;
            box-sizing: border-box;
        }
        .progress-container {
            position: relative;
            width: 280px;
            height: 280px;
            margin: 0 auto 20px auto;
        }
        .progress-circle {
            width: 280px;
            height: 280px;
            border-radius: 50%;
            background: #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        .progress-circle::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 280px;
            height: 280px;
            border-radius: 50%;
            background: conic-gradient(
                #4A90E2 0deg,
                #4A90E2 calc(var(--progress) * 3.6deg),
                transparent calc(var(--progress) * 3.6deg),
                transparent 360deg
            );
        }
        .progress-circle::after {
            content: '';
            position: absolute;
            width: 272px;
            height: 272px;
            background: white;
            border-radius: 50%;
            top: 4px;
            left: 4px;
        }
        .progress-content {
            position: relative;
            z-index: 3;
            text-align: center;
            padding: 30px;
            width: 180px;
        }
        .progress-percentage {
            font-size: 20px;
            font-weight: 700;
            color: #4A90E2;
            margin-bottom: 15px;
            line-height: 1.2;
        }
        .time-remaining-label {
            font-size: 11px;
            color: #000;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 500;
        }
        .time-remaining {
            font-size: 20px;
            font-weight: 700;
            color: #1a1a1a;
            line-height: 1;
        }
        
        .file-status {
            font-size: 14px;
            color: #666;
            margin-bottom: 30px;
        }
        
        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 35px;
            text-align: center;
            max-width: 380px;
            margin-left: auto;
            margin-right: auto;
        }
        .stat-item {
            padding: 18px;
            
            border-radius: 12px;
            border: 1px solid #e2e8f0;
        }
        .stat-label {
            font-size: 13px;
            color: #000;
            margin-bottom: 6px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .stat-value {
            font-size: 14px;
            font-weight: 700;
            color: #1e293b;
        }
        
        /* Brand */
        
        
        /* Hidden states */
        .upload-section.hidden { display: none; }
        .progress-section.hidden { display: none; }
        .download-section.hidden { display: none; }
        

        
        /* Navigation */
        .nav-button {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .nav-button:hover {
            background: #e5e7eb;
        }
        
        /* Download section - simplified */
        .download-section {
            margin-top: 0;
            padding-top: 0;
        }
        
        /* Ensure download section has same padding as upload */
        .download-section.content {
            padding: 60px 40px 10px 40px;
        }
        
        .download-section h3 {
            font-size: 24px;
            margin-bottom: 30px;
            color: #1a1a1a;
            font-weight: 300;
        }
        .file-list {
            text-align: left;
            margin-top: 30px;
            margin-bottom: 40px; /* Add bottom spacing to match upload section */
        }
        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; /* Changed from center to flex-start for better alignment */
            padding: 20px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 12px;
            background: white;
            transition: all 0.2s;
            min-height: 80px; /* Ensure consistent height */
        }
        .file-item:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .file-info {
            flex: 1;
            margin-right: 20px; /* Add space between file info and button */
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-height: 40px; /* Ensure minimum height for content */
        }
        .file-name {
            font-weight: 500;
            color: #374151;
            margin-bottom: 5px;
            word-break: break-word; /* Handle long filenames */
            line-height: 1.4;
        }
        .file-size {
            font-size: 12px;
            color: #6b7280;
            margin-top: auto; /* Push to bottom of file-info */
        }
        .download-btn {
            padding: 10px 20px;
            background: white;
            color: #000;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            align-self: center;
            height: fit-content;
        }
        .download-btn:hover {
            background: white;
            border-color: #4A90E2;
            color: #4A90E2;
        }
        .download-btn:disabled {
            background: #f3f4f6;
            color: #9ca3af;
            border-color: #e5e7eb;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .download-btn:disabled:hover {
            background: #f3f4f6;
            color: #9ca3af;
            border-color: #e5e7eb;
        }
        
        /* Download Progress */
        .download-progress.hidden { display: none; }
        
        .brand {
           margin: 20px auto -5px auto;
           display: flex;
           justify-content: center;
           align-items: center;
           
        }

        /* Progress section specific styling */
        .progress-section .header {
            margin-bottom: 30px;
        }
        .progress-section .title {
            font-size: 24px;
            margin-bottom: 8px;
        }
        .progress-section .subtitle {
            font-size: 14px;
            margin-bottom: 20px;
        }

        /* Download progress styling - consistent with upload */
        .download-progress .progress-container {
            margin-bottom: 30px;
        }
        
        /* Download progress wrapper - same styling as upload progress wrapper */
        .download-progress-wrapper {
            border: 1px solid #e2e8f0;
            border-radius: 16px;
            padding: 30px;
            margin: 0 auto 30px auto;
            width: 380px;
            background: white;
            box-sizing: border-box;
        }
        
        .download-progress-wrapper .progress-container {
            margin-bottom: 20px;
        }

        /* Completion Screen */
        .completion-screen {
            display: none;
            text-align: center;
            padding: 40px;
        }
        .completion-screen:not(.hidden) {
            display: block;
        }
        
        /* Completion wrapper - same styling as progress wrapper */
        .completion-wrapper {
            border: 1px solid #e2e8f0;
            border-radius: 16px;
            padding: 30px;
            margin: 0 auto 30px auto;
            width: 380px;
            background: white;
            box-sizing: border-box;
        }
        
        .completion-circle {
            width: 280px;
            height: 280px;
            border-radius: 50%;
            background: #22c55e;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 20px auto;
            position: relative;
        }
        .completion-circle::after {
            content: '';
            position: absolute;
            width: 272px;
            height: 272px;
            background: white;
            border-radius: 50%;
            top: 4px;
            left: 4px;
        }
        .completion-checkmark {
            font-size: 60px;
            color: #22c55e;
            font-weight: 300;
            position: relative;
            z-index: 3;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        .completion-message {
            font-size: 18px;
            color: #6b7280;
            margin-bottom: 8px;
            font-weight: 500;
        }
        .completion-time {
            font-size: 16px;
            color: #1f2937;
            font-weight: 700;
            margin-bottom: 20px;
        }
        .completion-files {
            font-size: 16px;
            color: #6b7280;
            margin-bottom: 40px;
        }
        
        /* Brand logo in completion screen */
        
        
        /* Download Progress */
        .download-progress.hidden { display: none; }
        
        /* Download Completion Bar */
        .download-completion-bar.hidden { display: none; }
        .download-completion-bar {
            margin-bottom: 20px;
        }
        .completion-container {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 20px;
            background: #f8fdf9;
            border: 1px solid #d1fae5;
            border-radius: 12px;
        }
        .completion-circle-small {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #22c55e;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            flex-shrink: 0;
        }
        .completion-circle-small::after {
            content: '';
            position: absolute;
            width: 42px;
            height: 42px;
            background: white;
            border-radius: 50%;
            top: 4px;
            left: 4px;
        }
        .completion-checkmark-small {
            font-size: 24px;
            color: #22c55e;
            font-weight: 600;
            position: relative;
            z-index: 3;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        .completion-content {
            flex: 1;
        }
        .completion-message-small {
            font-size: 16px;
            color: #065f46;
            font-weight: 600;
            margin-bottom: 4px;
        }
        .completion-stats {
            font-size: 14px;
            color: #6b7280;
        }
        .btn-small {
            background: none;
            border: none;
            font-size: 18px;
            color: #9ca3af;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        .btn-small:hover {
            background: #f3f4f6;
            color: #6b7280;
        }
    </style>
</head>
<body>
    <div class="wide-background">
        <div class="background-white">
    <div class="container">
        <!-- Tab Navigation -->
        <div class="tabs">
            <button class="tab active" id="uploadTab" onclick="switchTab('upload')">Upload Files</button>
            <button class="tab" id="downloadTab" onclick="switchTab('download')">Downloads</button>
        </div>
        
        <!-- Upload Section -->
        <div class="upload-section content" id="uploadSection">
            <div class="header">
                <div class="title">WNET File Transfer</div>
                    <div class="subtitle">Upload large video files securely</div>
            </div>
            
            <div class="upload-zone" id="uploadZone" onclick="document.getElementById('fileInput').click()">
                    <div class="upload-content" id="uploadContent">
                <div class="upload-icon">‚¨á</div>
                <div class="upload-text">Drag Files/Folders Here</div>
                    </div>
                    <div class="upload-zone-files" id="uploadZoneFiles"></div>
            </div>
            
            <div class="file-inputs">
                <input type="file" id="fileInput" accept=".mp4,.mov,.avi,.mkv,.webm,.wmv,.mxf,video/*" multiple>
                <input type="file" id="folderInput" webkitdirectory multiple>
            </div>
            
            <div class="selected-files" id="selectedFiles"></div>
            
                <div style="text-align: center; padding-top:20px;">
            <button class="btn btn-primary" id="sendButton" onclick="uploadFile()" disabled>Upload</button>
                </div>
        </div>

        <!-- Progress Section -->
        <div class="progress-section content hidden" id="progressSection">
            <div class="header">
                <div class="title">WNET File Transfer</div>
                <div class="subtitle">Upload and download large video files securely</div>
            </div>

            <div class="progress-wrapper">
            <div class="progress-container">
                <div class="progress-circle" id="progressCircle">
                    <div class="progress-content">
                            <div class="progress-percentage" id="progressPercentage">0% completed</div>
                            <div class="time-remaining-label">Time elapsed</div>
                        <div class="time-remaining" id="timeRemaining">00:00:00</div>
                            <div class="time-remaining-label" style="margin-top: 15px;">Time remaining</div>
                            <div class="time-remaining" id="timeRemainingETA">Calculating...</div>
                    </div>
                </div>
            </div>

                <div class="file-status" id="fileStatus">Sending 1 file(s)</div>
            </div>

            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">Speed</div>
                    <div class="stat-value" id="uploadSpeed">0.00 Mbps</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Uploaded</div>
                    <div class="stat-value" id="uploadProgress">0 GB / 0 GB</div>
                </div>
            </div>

            <div class="action-buttons">
                    <button class="btn" onclick="cancelUpload()">Cancel Upload</button>
            </div>
        </div>

            <!-- Completion Section -->
            <div class="completion-screen content hidden" id="completionSection">
            <div class="header">
                    <div class="title">WNET File Transfer</div>
                    <div class="subtitle">Upload and download large video files securely</div>
            </div>
            
            <div class="completion-wrapper">
                <div class="completion-circle">
                    <div class="completion-checkmark">‚úì</div>
                </div>

                <div class="completion-time" id="completionTime">Total time 00:00:00</div>
            </div>

                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">Speed</div>
                        <div class="stat-value" id="completionSpeed">0.00 Mbps</div>
                </div>
                    <div class="stat-item">
                        <div class="stat-label">Uploaded</div>
                        <div class="stat-value" id="completionUploaded">0 GB</div>
                    </div>
                </div>

                <div class="action-buttons" style="margin-top: 40px;">
                    <button class="btn" onclick="startNewUpload()">Upload More</button>
                </div>
                
            </div>

            <!-- Download Section -->
            <div class="download-section content hidden" id="downloadSection">
                <div class="header">
                    <div class="title">Available Downloads</div>
                    <div class="subtitle">Download your transferred files</div>
            </div>

            <!-- Download Progress -->
            <div class="download-progress hidden" id="downloadProgressSection">
                <div class="download-progress-wrapper">
                    <div class="progress-container">
                        <div class="progress-circle" id="downloadProgressCircle">
                            <div class="progress-content">
                                    <div class="progress-percentage" id="downloadProgressPercentage">0% completed</div>
                                    <div class="time-remaining-label">Time elapsed</div>
                                <div class="time-remaining" id="downloadTimeRemaining">00:00:00</div>
                                    <div class="time-remaining-label" style="margin-top: 15px;">Time remaining</div>
                                    <div class="time-remaining" id="downloadTimeRemainingETA">Calculating...</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="file-status">Downloading file</div>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">Speed</div>
                        <div class="stat-value" id="downloadSpeed">0.00 Mbps</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Downloaded</div>
                        <div class="stat-value" id="downloadProgressText">0 GB / 0 GB</div>
                    </div>
                </div>
            </div>
                
                <!-- Download Completion Bar - Above Refresh Button -->
                <div class="download-completion-bar hidden" id="downloadCompletionSection">
                    <div class="completion-container">
                        <div class="completion-circle-small">
                            <div class="completion-checkmark-small">‚úì</div>
                        </div>
                        <div class="completion-content">
                            <div class="completion-message-small">Download completed successfully!</div>
                            <div class="completion-stats" id="downloadCompletionStats">
                                <span id="downloadCompletionTime">Total time: 00:00:00</span> ‚Ä¢ 
                                <span id="downloadCompletionSpeed">0.00 Mbps avg</span> ‚Ä¢ 
                                <span id="downloadCompletionSize">0 GB</span>
                            </div>
                        </div>
                        <button class="btn-small" onclick="startNewDownload()">√ó</button>
                    </div>
                </div>
                
                <button class="btn btn-primary" onclick="refreshFileList()">Refresh File List</button>
                
                <div class="file-list" id="fileList">
                    <div style="text-align: center; color: #888; padding: 40px;">
                        Loading files...
                </div>
            </div>
        </div>

        <!-- Download Completion Screen -->
        <div class="completion-screen content hidden" id="downloadCompletionScreen">
            <div class="header">
                <div class="title">Available Downloads</div>
                <div class="subtitle">Download your transferred files</div>
            </div>
            
            <div class="completion-wrapper">
                <div class="completion-circle">
                    <div class="completion-checkmark">‚úì</div>
                </div>

                <div class="completion-message">Download completed successfully!</div>
                <div class="completion-time" id="downloadCompletionTimeFullScreen">Total time 00:00:00</div>
            </div>

            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">Speed</div>
                    <div class="stat-value" id="downloadCompletionSpeedFullScreen">0.00 Mbps</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Downloaded</div>
                    <div class="stat-value" id="downloadCompletionDownloaded">0 GB</div>
                </div>
            </div>
            
            <!-- Show file list below completion -->
            <div style="margin-top: 40px;">
                <button class="btn btn-primary" onclick="refreshFileList()">Refresh File List</button>
                
                <div class="file-list" id="completionFileList">
                    <div style="text-align: center; color: #888; padding: 40px;">
                        Loading files...
                    </div>
                </div>
            </div>
            
        </div>

        </div>

        <div class="brand">
        <img src="https://wavelengthpublicmedia.org/wp-content/themes/wnet-theme/assets/images/logo.jpg" width="200px" alt="WNET" />
        </div>
    </div>
    
    <!-- Brand logo outside all containers, centered on full page -->
   

    <!-- Hidden elements for legacy compatibility -->
    <div style="display: none;">
        <div id="uploadProgressContainer"></div>
        <progress id="uploadProgress" value="0" max="100"></progress>
        <span id="uploadProgressText"></span>
        <div id="uploadTimer">00:00:00</div>
        <div id="uploadFileSize"></div>
        <div id="uploadETA"></div>
        <div id="downloadProgressContainer"></div>
        <progress id="downloadProgress" value="0" max="100"></progress>
        <span id="downloadProgressText"></span>
        <div id="downloadTimer">00:00:00</div>
        <div id="downloadSavingMsg"></div>
        <div id="downloadETA"></div>
    </div>

    <!-- Load Network Profile Scripts -->
    <script src="network-profiles/gigabit.js"></script>
    <script src="network-profiles/ultra.js"></script>
    <script src="network-profiles/fiber.js"></script>
    <script src="network-profiles/cable.js"></script>
    <script src="network-profiles/dsl.js"></script>
    <script src="network-profiles/enterprise.js"></script>

    <script>
        // Replace these with your actual R2 credentials and bucket name
        const R2_ACCOUNT_ID = 'YOUR_ACCOUNT_ID';
        const R2_ACCESS_KEY_ID = 'YOUR_ACCESS_KEY_ID';
        const R2_SECRET_ACCESS_KEY = 'YOUR_SECRET_ACCESS_KEY';
        const R2_BUCKET_NAME = 'YOUR_BUCKET_NAME';

        // Set your R2 Public Development URL base here
        const R2_PUBLIC_URL_BASE = 'https://pub-2078a13599a74a339318b659bb618965.r2.dev'; // <-- Your actual public URL base

        // Connection quality detection and chunk size configuration
        const CHUNK_SIZES = {
            slow: 100 * 1024 * 1024,    // 100MB chunks for slow connections (increased from 50MB)
            medium: 200 * 1024 * 1024,  // 200MB chunks for medium connections (increased from 100MB)
            fast: 500 * 1024 * 1024     // 500MB chunks for fast connections (increased from 250MB)
        };

        // üîí PROFILE ISOLATION SYSTEM - Prevent state pollution between uploads
        class UploadSessionManager {
            constructor() {
                this.currentSession = null;
                this.globalTimers = new Set();
                this.globalState = new Map();
            }
            
            // Generate unique session ID for each upload
            createSession(profileTier) {
                const sessionId = `upload_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                this.currentSession = {
                    id: sessionId,
                    profileTier: profileTier,
                    startTime: Date.now(),
                    timers: new Set(),
                    state: new Map(),
                    isActive: true
                };
                
                console.log(`üÜî NEW SESSION: ${sessionId} (${profileTier} profile)`);
                return this.currentSession;
            }
            
            // Register timer with current session
            registerTimer(timerId, timerType = 'interval') {
                if (this.currentSession) {
                    this.currentSession.timers.add({ id: timerId, type: timerType });
                }
                this.globalTimers.add({ id: timerId, type: timerType });
            }
            
            // Store session-scoped state
            setState(key, value) {
                if (this.currentSession) {
                    this.currentSession.state.set(key, value);
                }
            }
            
            // Get session-scoped state
            getState(key, defaultValue = null) {
                if (this.currentSession && this.currentSession.state.has(key)) {
                    return this.currentSession.state.get(key);
                }
                return defaultValue;
            }
            
            // Clear all timers for current session
            clearSessionTimers() {
                if (this.currentSession) {
                    this.currentSession.timers.forEach(timer => {
                        try {
                            if (timer.type === 'interval') {
                                clearInterval(timer.id);
                            } else if (timer.type === 'timeout') {
                                clearTimeout(timer.id);
                            }
                        } catch (e) {
                            console.warn(`Failed to clear timer ${timer.id}:`, e.message);
                        }
                    });
                    this.currentSession.timers.clear();
                }
            }
            
            // Clear ALL timers (emergency cleanup)
            clearAllTimers() {
                this.globalTimers.forEach(timer => {
                    try {
                        if (timer.type === 'interval') {
                            clearInterval(timer.id);
                        } else if (timer.type === 'timeout') {
                            clearTimeout(timer.id);
                        }
                    } catch (e) {
                        console.warn(`Failed to clear global timer ${timer.id}:`, e.message);
                    }
                });
                this.globalTimers.clear();
            }
            
            // Reset all upload state variables
            resetUploadState() {
                // Reset global upload variables
                uploadStartTime = 0;
                totalUploaded = 0;
                activeUploads = 0;
                lastUploadTime = 0;
                lastUploadSize = 0;
                lastEtaUpdate = 0;
                lastLoaded = 0;
                
                etaHistory = [];
                speedHistory = [];
                
                // Reset performance tracker
                performanceTracker.reset();
                
                // Clear any active XHR requests
                if (typeof activeXhrRequests !== 'undefined') {
                    activeXhrRequests.forEach(xhr => {
                        try {
                            xhr.abort();
                        } catch (e) { /* ignore */ }
                    });
                    activeXhrRequests.length = 0;
                }
                
                console.log(`üßπ STATE RESET: All upload variables cleared`);
            }
            
            // End current session and cleanup
            endSession() {
                if (this.currentSession) {
                    console.log(`üèÅ ENDING SESSION: ${this.currentSession.id} (${this.currentSession.profileTier})`);
                    
                    // Clear session timers
                    this.clearSessionTimers();
                    
                    // Reset state
                    this.resetUploadState();
                    
                    // Mark session as inactive
                    this.currentSession.isActive = false;
                    this.currentSession = null;
                }
            }
            
            // Check if current session is valid
            isSessionActive() {
                return this.currentSession && this.currentSession.isActive;
            }
            
            // Get current session info
            getSessionInfo() {
                if (this.currentSession) {
                    return {
                        id: this.currentSession.id,
                        profileTier: this.currentSession.profileTier,
                        duration: Date.now() - this.currentSession.startTime,
                        timersCount: this.currentSession.timers.size
                    };
                }
                return null;
            }
        }
        
        // Create global session manager
        const uploadSessionManager = new UploadSessionManager();
        
        // Enhanced profile configuration with deep cloning
        function createIsolatedProfile(baseProfile) {
            // Deep clone to prevent reference sharing
            const isolatedProfile = JSON.parse(JSON.stringify(baseProfile));
            
            // Add session-specific properties
            isolatedProfile.sessionId = uploadSessionManager.currentSession?.id || 'unknown';
            isolatedProfile.createdAt = Date.now();
            
            // Runtime state is now handled by external profile modules
            
            // Thresholds are now handled by external profile modules
            
            console.log(`üîí ISOLATED PROFILE: ${isolatedProfile.tier} (session: ${isolatedProfile.sessionId})`);
            return isolatedProfile;
        }

        // Global state variables (will be reset between sessions)
        let currentChunkSize = CHUNK_SIZES.medium; // Default to medium
        let uploadRetryCount = 0;

        // Timer variables (will be tracked and cleared)
        let uploadTimerInterval = null;
        let downloadTimerInterval = null;
        let lastUploadTime = 0;
        let lastDownloadTime = 0;
        let lastUploadSize = 0;
        let lastDownloadSize = 0;
        let lastEtaUpdate = 0; // Track last ETA update time
        let uploadStartTime = 0; // Track upload start time for avg speed
        let etaHistory = []; // Store ETA history for smoothing
        let speedHistory = []; // Store speed history for smoothing
        let lastLoaded = 0; // Track last loaded bytes for resume functionality

        // Global Performance tracking object
        const performanceTracker = {
            startTime: 0,
            partTimes: [],
            parallelPeaks: 0,
            retryCount: 0,
            bytesPerSecond: [],
            connectionUtilization: [],
            disabled: false, // Add disabled flag
            
            reset: function() {
                this.startTime = Date.now();
                this.partTimes = [];
                this.parallelPeaks = 0;
                this.retryCount = 0;
                this.bytesPerSecond = [];
                this.connectionUtilization = [];
                this.disabled = false; // Reset disabled flag
            },
            
            showPerformancePanel: function() {
                if (this.disabled) return;
                const panel = document.getElementById('uploadPerformance');
                if (panel) panel.style.display = 'block';
            },
            
            updateConnection: function(info) {
                if (this.disabled) return;
                const msg = `üîó Connection: ${info.latency}ms latency, ${(info.bandwidth * 8).toFixed(2)} Mbps bandwidth (${info.type})`;
                console.log(msg);
                const elem = document.getElementById('perfConnection');
                if (elem) elem.textContent = msg;
            },
            
            updateStrategy: function(partSize, maxParallel, partCount) {
                if (this.disabled) return;
                const msg = `üì¶ Strategy: ${partCount} parts √ó ${(partSize/1024/1024).toFixed(1)}MB, ${maxParallel} max parallel`;
                console.log(msg);
                const elem = document.getElementById('perfStrategy');
                if (elem) elem.textContent = msg;
            },
            
            logPartComplete: function(partNum, bytes, timeMs, parallel) {
                // Don't log if disabled or upload was cancelled
                if (this.disabled || isUploadCancelled) {
                    return;
                }
                
                const speed = (bytes / 1024 / 1024) / (timeMs / 1000);
                const speedMbps = speed * 8; // Convert to Mbps
                this.partTimes.push({ part: partNum, timeMs, speed, parallel });
                this.parallelPeaks = Math.max(this.parallelPeaks, parallel);
                
                const msg = `‚úÖ Part ${partNum}: ${(timeMs/1000).toFixed(1)}s, ${speedMbps.toFixed(2)} Mbps, ${parallel} active`;
                console.log(msg);
                
                // Add to UI (show last 10 parts)
                const elem = document.getElementById('perfParts');
                if (elem) {
                    const div = document.createElement('div');
                    div.textContent = msg;
                    div.style.color = speedMbps > 24 ? '#28a745' : speedMbps > 8 ? '#ffc107' : '#dc3545'; // Adjusted thresholds for Mbps
                    elem.appendChild(div);
                    
                    // Keep only last 10 entries
                    while (elem.children.length > 10) {
                        elem.removeChild(elem.firstChild);
                    }
                    elem.scrollTop = elem.scrollHeight;
                }
            },
            
            logProgress: function(completed, total, totalBytes, elapsedMs) {
                // Don't log if disabled or upload was cancelled
                if (this.disabled || isUploadCancelled) {
                    return;
                }
                
                const progress = (completed / total * 100).toFixed(1);
                const avgSpeed = (totalBytes / 1024 / 1024) / (elapsedMs / 1000);
                const avgSpeedMbps = avgSpeed * 8; // Convert to Mbps
                const eta = ((total - completed) * (elapsedMs / completed)) / 1000;
                
                const msg = `üìä Progress: ${progress}% (${completed}/${total} parts), ${avgSpeedMbps.toFixed(2)} Mbps avg, ETA: ${eta.toFixed(0)}s`;
                console.log(msg);
                
                const elem = document.getElementById('perfProgress');
                if (elem) elem.textContent = msg;
            },
            
            logRetry: function(partNum, attempt, maxAttempts, delay, error) {
                if (this.disabled) return;
                this.retryCount++;
                const msg = `‚ö†Ô∏è Part ${partNum} retry ${attempt}/${maxAttempts} after ${delay}ms: ${error}`;
                console.log(msg);
                
                const elem = document.getElementById('perfParts');
                if (elem) {
                    const div = document.createElement('div');
                    div.textContent = msg;
                    div.style.color = '#dc3545';
                    elem.appendChild(div);
                    elem.scrollTop = elem.scrollHeight;
                }
            },
            
            logFinalSummary: function(totalTime, partCount, partSize) {
                if (this.disabled) return;
                if (this.partTimes.length === 0) return; // No parts completed
                
                const avgPartTime = this.partTimes.reduce((a, b) => a + b.timeMs, 0) / this.partTimes.length;
                const fastestPart = Math.min(...this.partTimes.map(p => p.timeMs));
                const slowestPart = Math.max(...this.partTimes.map(p => p.timeMs));
                const avgPartSpeed = this.partTimes.reduce((a, b) => a + b.speed, 0) / this.partTimes.length;
                const avgPartSpeedMbps = avgPartSpeed * 8; // Convert to Mbps
                
                const summary = [
                    `üèÅ UPLOAD COMPLETE - Performance Summary:`,
                    `üìà Total time: ${(totalTime/1000).toFixed(1)}s`,
                    `‚ö° Peak parallel: ${this.parallelPeaks} connections`,
                    `üîÑ Retries: ${this.retryCount}`,
                    `üìä Part timing: avg=${(avgPartTime/1000).toFixed(1)}s, fastest=${(fastestPart/1000).toFixed(1)}s, slowest=${(slowestPart/1000).toFixed(1)}s`,
                    `üöÄ Part speeds: avg=${avgPartSpeedMbps.toFixed(2)} Mbps per part`,
                    `üí° ${this.parallelPeaks < 50 ? 'Browser/network limited connections' : 'Reached high parallelism'}`
                ];
                
                // üîß RELIABILITY IMPROVEMENT - Add error and bandwidth info
                if (this.errorLog && this.errorLog.length > 0) {
                    const errorTypes = [...new Set(this.errorLog.map(e => e.error))];
                    summary.push(`‚ö†Ô∏è Error types: ${errorTypes.join(', ')}`);
                }
                
                summary.forEach(line => console.log(line));
                
                const elem = document.getElementById('perfSummary');
                if (elem) {
                    elem.innerHTML = summary.map(line => `<div style="margin:2px 0;">${line}</div>`).join('');
                }
            }
        };

        // Configuration flag for new upload speed detection
        const USE_UPLOAD_SPEED_DETECTION = true; // Re-enabled with CORS fixes

        // Hybrid speed detection: Use latency estimate + test file validation
        async function detectRealUploadSpeed() {
            try {
                console.log(`üß™ Running quick upload validation test...`);
                
                // Quick 1MB test for fast startup
                const testSize = 1 * 1024 * 1024; // Keep 1MB for fast startup
                const testResult = await performSingleSpeedTest(testSize, 1, 1);
                
                if (testResult && testResult > 3) { // Lowered threshold from 5 to 3
                    console.log(`‚úÖ Upload validation: ${testResult.toFixed(1)} Mbps measured`);
                    return testResult;
                } else {
                    console.warn('‚ö†Ô∏è Upload test gave low result, using latency-based fallback');
                    return null;
                }
                
            } catch (error) {
                console.warn('‚ùå Upload validation failed, using latency-based fallback:', error.message);
                return null;
            }
        }
        
        // Helper function for single speed test
        async function performSingleSpeedTest(testSize, attempt, connectionNum) {
            // Create test chunk
            const testChunk = new Blob([new ArrayBuffer(testSize)]);
            
            // Get test upload URL (use same endpoint as main upload)
            const testFileName = `test-upload-${Date.now()}-${connectionNum}.bin`;
            const presignResponse = await fetch('/api/presign', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    fileName: testFileName,
                    contentType: 'application/octet-stream'
                })
            });
            
            if (!presignResponse.ok) throw new Error('Failed to get test upload URL');
            const { url } = await presignResponse.json();
            
            // Measure upload speed
            const startTime = Date.now();
            
            const speedMbps = await new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                const timeout = setTimeout(() => {
                    xhr.abort();
                    reject(new Error('Test upload timeout'));
                }, 15000); // 15 second timeout for test file
                
                xhr.open('PUT', url, true);
                xhr.setRequestHeader('Content-Type', 'application/octet-stream');
                // Remove custom headers that might cause CORS issues
                
                xhr.onload = function() {
                    clearTimeout(timeout);
                    if (xhr.status >= 200 && xhr.status < 300) {
                        const uploadTime = (Date.now() - startTime) / 1000; // seconds
                        const speedMbps = (testSize * 8) / (uploadTime * 1000000); // Convert to Mbps
                        console.log(`‚úÖ Connection ${connectionNum} speed: ${speedMbps.toFixed(2)} Mbps (${(testSize/1024/1024).toFixed(1)}MB in ${uploadTime.toFixed(1)}s)`);
                        resolve(speedMbps);
                    } else {
                        reject(new Error(`Test upload failed: ${xhr.status}`));
                    }
                };
                
                xhr.onerror = function() {
                    clearTimeout(timeout);
                    reject(new Error('Test upload network error'));
                };
                
                xhr.send(testChunk);
            });
            
            return speedMbps;
        }

        // Enhanced connection quality detection - considers both latency AND bandwidth
        async function detectConnectionQuality() {
            try {
                // Step 1: PARALLEL latency and bandwidth testing for speed
                console.log('üöÄ Running parallel connection tests...');
                
                const latencyPromises = [];
                for (let i = 0; i < 2; i++) { // Reduced from 3 to 2 samples
                    latencyPromises.push(
                        (async () => {
                const latencyStart = Date.now();
                            await fetch('/api/ping');
                            return Date.now() - latencyStart;
                        })()
                    );
                }
                
                // Run bandwidth test in parallel with latency tests
                const bandwidthPromise = (async () => {
                    try {
                        console.log('üß™ Running connection bandwidth test...');
                        const testSize = 512 * 1024; // Reduced from 1MB to 512KB for speed
                        return await performSingleSpeedTest(testSize, 1, 'bandwidth');
                    } catch (error) {
                        console.log('‚ö†Ô∏è Bandwidth test failed:', error.message);
                        return null;
                    }
                })();
                
                // Wait for all tests to complete in parallel
                const [latencySamples, bandwidthResult] = await Promise.all([
                    Promise.all(latencyPromises),
                    bandwidthPromise
                ]);
                
                // Use median latency for more reliable detection
                latencySamples.sort((a, b) => a - b);
                const latency = latencySamples[Math.floor(latencySamples.length / 2)]; // Median
                
                console.log(`Latency samples: [${latencySamples.join(', ')}]ms, using median: ${latency}ms`);

                // Step 2: Process bandwidth results
                let bandwidthMBps = 2.5; // Default assumption
                let actualBandwidthTest = null;
                
                if (bandwidthResult && bandwidthResult > 1) {
                    actualBandwidthTest = bandwidthResult;
                    bandwidthMBps = bandwidthResult / 8; // Convert Mbps to MB/s
                    console.log(`‚úÖ Bandwidth test: ${bandwidthResult.toFixed(1)} Mbps measured`);
                }
                
                // More reliable bandwidth estimates - prioritize high-speed detection
                if (latency < 20) {
                    bandwidthMBps = 25;  // ULTRA - Very fast local connections
                } else if (latency < 100) {
                    bandwidthMBps = 20;   // ULTRA - Fast connections with some routing delay
                } else if (latency < 250) {
                    bandwidthMBps = 18;   // ULTRA - Good connections like yours (expanded range)
                } else if (latency < 400) {
                    bandwidthMBps = 12;   // FAST - Moderate connections with geographic routing
                } else if (latency < 600) {
                    bandwidthMBps = 6;    // MODERATE - Slower connections
                } else {
                    bandwidthMBps = 3;    // SLOW/MOBILE - Very slow connections
                }

                console.log(`Connection test: ${latency}ms latency, ${(bandwidthMBps * 8).toFixed(2)} Mbps bandwidth (${bandwidthMBps > 2.5 ? 'estimated' : 'measured'})`);

                // Step 3: Classify connection type (optimized for high-performance connections)
                let connectionType;
                if (latency < 50 && bandwidthMBps >= 8) {
                    connectionType = 'fast-unlimited'; // Low latency + high bandwidth
                    currentChunkSize = CHUNK_SIZES.fast;
                } else if (latency < 150 && bandwidthMBps >= 5) {
                    connectionType = 'fast-limited'; // Your connection type - good latency + high bandwidth
                    currentChunkSize = CHUNK_SIZES.medium;
                } else if (latency >= 150 && bandwidthMBps > 3) {
                    connectionType = 'slow-unlimited'; // High latency + decent bandwidth
                    currentChunkSize = CHUNK_SIZES.medium;
                } else {
                    connectionType = 'slow-limited'; // High latency + limited bandwidth
                    currentChunkSize = CHUNK_SIZES.slow;
                }

                return { type: connectionType, latency, bandwidth: bandwidthMBps, actualBandwidthTest };
            } catch (error) {
                console.error('Connection quality detection failed:', error);
                currentChunkSize = CHUNK_SIZES.slow;
                return { type: 'slow-limited', latency: 999, bandwidth: 0.5 };
            }
        }

        // üîß RELIABILITY IMPROVEMENTS - Enhanced retry with jitter
        function getRetryDelayWithJitter(attempt) {
            const baseDelay = Math.pow(2, attempt) * 1000; // 1s, 2s, 4s, 8s, 16s...
            const jitter = Math.random() * 1000; // 0-1000ms random jitter
            return Math.min(30000, baseDelay + jitter); // Cap at 30 seconds
        }

        // üîß RELIABILITY IMPROVEMENTS - Enhanced error logging
        function logPartError(partNumber, attempt, status, error, delay = null) {
            const errorType = status || error.code || error.name || 'network';
            const logMessage = delay ? 
                `‚ö†Ô∏è Part ${partNumber} retry ${attempt}/5 in ${(delay/1000).toFixed(1)}s due to: ${errorType}` :
                `‚ùå Part ${partNumber} failed after 5 retries. Last error: ${errorType}`;
            
            console.warn(logMessage);
            
            // Add to performance tracker for analytics
            if (!performanceTracker.errorLog) performanceTracker.errorLog = [];
            performanceTracker.errorLog.push({
                part: partNumber,
                attempt,
                error: errorType,
                timestamp: Date.now()
            });
            
            // Also log to existing retry tracking
            if (delay) {
                performanceTracker.logRetry(partNumber, attempt, 5, delay, errorType);
            }
        }

        // üîß RELIABILITY IMPROVEMENTS - Token expiry detection
        function handleTokenExpiry(error, partNumber) {
            if (error.status === 403 || error.status === 401) {
                console.error(`üîê Token expired for part ${partNumber}. Status: ${error.status}`);
                alert('Your upload session has expired. Please refresh the page and try again.');
                return true; // Indicates token expiry was handled
            }
            return false; // Not a token expiry issue
        }

        // Calculate estimated time remaining
        function calculateETA(loaded, total, speed) {
            if (speed <= 0) return 'Calculating...';
            const remainingBytes = total - loaded;
            const remainingSeconds = remainingBytes / (speed * 1024 * 1024);
            return formatTime(remainingSeconds * 1000);
        }

        // Exponential backoff delay calculation
        function getRetryDelay(retryCount) {
            return Math.min(1000 * Math.pow(2, retryCount), 30000); // Max 30 seconds delay
        }

        // Error recovery and retry mechanism
        async function logUploadFailure(details) {
            try {
                await fetch('/api/log-upload-failure', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(details)
                });
            } catch (e) {
                // Ignore logging errors
            }
        }

        async function handleUploadError(error, file, uniqueFilename, progressBar, progressText, progressContainer, timerDisplay, startTime, partNumber = null) {
            console.error('Upload error:', error);
            // Gather log details
            const connectionQuality = typeof detectConnectionQuality === 'function' ? await detectConnectionQuality() : 'unknown';
            const speed = document.getElementById('uploadSpeed')?.textContent || 'unknown';
            const details = {
                fileName: uniqueFilename,
                fileSize: file.size,
                partNumber,
                error: error.message || error.toString(),
                connectionQuality,
                speed,
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent
            };
            logUploadFailure(details);
            
            if (uploadRetryCount < MAX_RETRIES) {
                const delay = getRetryDelay(uploadRetryCount);
                console.log(`Retrying upload in ${delay/1000} seconds... (Attempt ${uploadRetryCount + 1}/${MAX_RETRIES})`);
                
                if (progressText) progressText.textContent = `Upload failed. Retrying in ${delay/1000} seconds... (Attempt ${uploadRetryCount + 1}/${MAX_RETRIES})`;
                
                await new Promise(resolve => setTimeout(resolve, delay));
                uploadRetryCount++;
                
                // Resume from last successful position
                if (lastLoaded > 0) {
                    console.log(`Resuming from position: ${lastLoaded}`);
                    return await uploadFileWithResume(file, uniqueFilename, lastLoaded, progressBar, progressText, progressContainer, timerDisplay, startTime);
                } else {
                    return await uploadFile();
                }
            } else {
                console.error('Max retries reached. Upload failed.');
                if (progressText) progressText.textContent = 'Upload failed after multiple attempts. Please try again.';
                if (progressContainer) progressContainer.style.display = 'none';
                clearInterval(uploadTimerInterval);
                uploadRetryCount = 0;
                throw new Error('Max retries reached');
            }
        }

        // Upload with resume capability
        async function uploadFileWithResume(file, uniqueFilename, startPosition, progressBar, progressText, progressContainer, timerDisplay, startTime) {
            try {
                const presignResponse = await fetch('/api/presign', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileName: uniqueFilename,
                        contentType: file.type || 'application/octet-stream',
                        startPosition: startPosition
                    })
                });

                if (!presignResponse.ok) {
                    throw new Error('Failed to get pre-signed URL for resume');
                }

                const { url } = await presignResponse.json();
                const xhr = new XMLHttpRequest();
                xhr.open('PUT', url, true);
                xhr.setRequestHeader('Content-Type', file.type || 'application/octet-stream');
                xhr.setRequestHeader('Content-Range', `bytes ${startPosition}-${file.size-1}/${file.size}`);

                let lastLoaded = startPosition;
                let lastTime = Date.now();

                xhr.upload.onprogress = function(event) {
                    if (event.lengthComputable) {
                        const totalLoaded = startPosition + event.loaded;
                        const percent = Math.round((totalLoaded / file.size) * 100);
                        
                        const now = Date.now();
                        const bytesSinceLast = event.loaded - lastLoaded;
                        const timeSinceLast = (now - lastTime) / 1000;
                        if (timeSinceLast > 0 && bytesSinceLast > 0) {
                            const smoothSpeed = calculateSmoothSpeed(bytesSinceLast, timeSinceLast);
                            const speedMbps = smoothSpeed * 8; // Convert to Mbps
                            
                            // Only update ETA every 2 seconds to prevent jumping
                            let etaText = document.getElementById('timeRemaining').textContent;
                            if (now - lastEtaUpdate > 2000) { // Update every 2 seconds
                                etaText = calculateSmoothETA(event.loaded, event.total, smoothSpeed);
                                lastEtaUpdate = now;
                            }
                            
                            // Update circular progress
                            updateCircularProgress(
                                percent,
                                etaText,
                                `${speedMbps.toFixed(2)} Mbps`,
                                event.loaded,
                                event.total
                            );
                        }
                        // Update both local and global lastLoaded for resume functionality
                        lastLoaded = event.loaded; // Global variable for resume
                        const localLastLoaded = event.loaded; // Local variable for this function
                        lastTime = now;
                    }
                };

                return new Promise((resolve, reject) => {
                    xhr.onload = function() {
                        if (xhr.status >= 200 && xhr.status < 300) {
                            uploadRetryCount = 0;
                            resolve();
                        } else {
                            reject(new Error(`Upload failed with status ${xhr.status}`));
                        }
                    };
                    xhr.onerror = function() {
                        reject(new Error('Network error during upload'));
                    };
                    xhr.send(file.slice(startPosition));
                });
            } catch (error) {
                return handleUploadError(error, file, uniqueFilename, progressBar, progressText, progressContainer, timerDisplay, startTime);
            }
        }

        async function uploadFile() {
            // Check for selected files first, then fallback to file input
            let file;
            if (selectedFiles && selectedFiles.length > 0) {
                file = selectedFiles[0];
            } else {
            const fileInput = document.getElementById('fileInput');
                file = fileInput.files[0];
            }

            if (!file) {
                alert('Please select a file first');
                return;
            }

            if (!isValidVideoFile(file)) {
                return;
            }

            // Detect connection quality before starting upload
            const connectionInfo = await detectConnectionQuality();
            console.log(`Connection quality: ${connectionInfo.type}, Chunk size: ${currentChunkSize / (1024 * 1024)}MB`);

            // Generate a unique filename with timestamp
            const uniqueFilename = getTimestampedFilename(file.name);

            // Show progress section
            showProgressSection(file.name);

            let startTime = Date.now();
            if (uploadTimerInterval) clearInterval(uploadTimerInterval);
            uploadTimerInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                document.getElementById('timeRemaining').textContent = formatTime(elapsed);
            }, 100);

            // Use multipart upload for files over 1GB (1 * 1024 * 1024 * 1024 bytes)
            if (file.size > 1 * 1024 * 1024 * 1024) {
                await multipartUpload(file, uniqueFilename, null, null, null, null, startTime);
                return;
            }

            // Step 1: Get pre-signed URL from backend
            let presignResponse;
            try {
                presignResponse = await fetch('/api/presign', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileName: uniqueFilename,
                        contentType: file.type || 'application/octet-stream'
                    })
                });
            } catch (err) {
                hideProgressSection();
                clearInterval(uploadTimerInterval);
                alert('Failed to get pre-signed URL');
                return;
            }

            if (!presignResponse.ok) {
                hideProgressSection();
                clearInterval(uploadTimerInterval);
                alert('Failed to get pre-signed URL');
                return;
            }

            const { url } = await presignResponse.json();

            // Step 2: Upload file directly to R2 using the pre-signed URL
            let lastLoaded = 0;
            let lastTime = Date.now();
            const xhr = new XMLHttpRequest();
            
            // Track this XMLHttpRequest for cancellation
            activeXhrRequests.push(xhr);
            
            xhr.open('PUT', url, true);
            xhr.setRequestHeader('Content-Type', file.type || 'application/octet-stream');

            xhr.upload.onprogress = function (event) {
                // Check for cancellation during progress
                if (isUploadCancelled) {
                    console.log('Regular upload cancelled - aborting');
                    xhr.abort();
                    return;
                }
                
                if (event.lengthComputable) {
                    const percent = Math.round((event.loaded / event.total) * 100);
                    const timeElapsed = Date.now() - startTime;
                    
                    // Real-time speed calculation with smoothing - update less frequently
                    const now = Date.now();
                    const bytesSinceLast = event.loaded - lastLoaded;
                    const timeSinceLast = (now - lastTime) / 1000; // seconds
                    
                    // Only update every 2 seconds for much smoother display
                    if (timeSinceLast >= 2.0 && bytesSinceLast > 0) {
                        const smoothSpeed = calculateSmoothSpeed(bytesSinceLast, timeSinceLast);
                        const speedMbps = smoothSpeed * 8; // Convert to Mbps
                        
                        // Calculate time remaining ETA
                        const eta = calculateSmoothETA(event.loaded, event.total, smoothSpeed);
                        
                        // Update circular progress with elapsed time and ETA
                        updateCircularProgress(
                            percent,
                            formatTime(timeElapsed), // Show elapsed time
                            `${speedMbps.toFixed(2)} Mbps`,
                            event.loaded,
                            event.total,
                            eta // Show time remaining
                        );
                        
                    lastLoaded = event.loaded;
                    lastTime = now;
                    } else if (timeSinceLast < 2.0) {
                        // Still update progress percentage but not speed/time
                        const progressCircle = document.getElementById('progressCircle');
                        progressCircle.style.setProperty('--progress', percent);
                        document.getElementById('progressPercentage').textContent = `${percent}% completed`;
                        
                        const uploadedGB = (event.loaded / (1024 * 1024 * 1024)).toFixed(2);
                        const totalGB = (event.total / (1024 * 1024 * 1024)).toFixed(2);
                        document.getElementById('uploadProgress').textContent = `${uploadedGB} GB / ${totalGB} GB`;
                    }
                }
            };

            xhr.onload = async function () {
                // Remove from active requests when done
                const index = activeXhrRequests.indexOf(xhr);
                if (index > -1) activeXhrRequests.splice(index, 1);
                
                clearInterval(uploadTimerInterval);
                lastUploadTime = Date.now() - startTime;
                lastUploadSize = file.size;
                
                // Show final stats
                if (lastUploadTime > 0 && lastUploadSize > 0) {
                    const mb = lastUploadSize / 1024 / 1024;
                    const sec = lastUploadTime / 1000;
                    const speedMBs = mb / sec; // MB/s
                    const speedMbps = speedMBs * 8; // Convert to Mbps
                    
                    // Show 100% completion with final elapsed time
                    updateCircularProgress(
                        100,
                        formatTime(lastUploadTime), // Show total elapsed time
                        `${speedMbps.toFixed(2)} Mbps`,
                        file.size,
                        file.size
                    );
                }
                
                // Notify backend after upload
                await fetch('/api/notify-upload', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileName: uniqueFilename,
                        size: file.size,
                        contentType: file.type || 'application/octet-stream'
                    })
                });

                setTimeout(() => {
                    const mb = lastUploadSize / 1024 / 1024;
                    const sec = lastUploadTime / 1000;
                    const speedMBs = mb / sec; // MB/s
                    const speedMbps = speedMBs * 8; // Convert to Mbps
                    
                    // Show completion screen instead of alert
                    showCompletionScreen(lastUploadTime, file.size, speedMbps);
                    
                    // Clear selected files after successful upload
                    if (selectedFiles && selectedFiles.length > 0) {
                    selectedFiles = [];
                    updateSelectedFilesDisplay();
                    updateSendButton();
                    }
                }, 2000);
            };

            xhr.onerror = function() {
                // Remove from active requests on error
                const index = activeXhrRequests.indexOf(xhr);
                if (index > -1) activeXhrRequests.splice(index, 1);
                
                // Check if error is due to cancellation
                if (isUploadCancelled) {
                    console.log('Regular upload cancelled during upload');
                    return; // Exit silently for cancellation
                }
                
                handleUploadError(new Error('Network error during upload'), file, uniqueFilename, null, null, null, null, startTime);
            };
            
            xhr.onabort = function() {
                // Remove from active requests on abort
                const index = activeXhrRequests.indexOf(xhr);
                if (index > -1) activeXhrRequests.splice(index, 1);
                
                console.log('Regular upload aborted');
                // Exit silently for cancellation - no error handling needed
            };

            xhr.send(file);
        }

        // Multipart upload logic for files > 1GB
        async function multipartUpload(file, uniqueFilename, progressBar, progressText, progressContainer, timerDisplay, startTime) {
            try {
                // üîí STEP 1: End any previous session and start fresh
                uploadSessionManager.endSession();
                
                // Detect connection quality (reuse logic from uploadFile)
                let connectionInfo = { type: 'medium', latency: 200, bandwidth: 2 };
                if (typeof detectConnectionQuality === 'function') {
                    connectionInfo = await detectConnectionQuality();
                }
                
                // Optimized part size and parallelism based on connection type
                let partSize;
                let maxParallel;
                
                // üéØ NEW: Real-world upload speed based profiles using external modules
                function getUploadProfile(uploadMbps) {
                    if (uploadMbps < 8) {
                        return DSL_PROFILE; // Rural DSL, very slow connections
                    } else if (uploadMbps < 75) {
                        return CABLE_PROFILE; // Most cable internet (8-75 Mbps typical)
                    } else if (uploadMbps < 120) {
                        return ENTERPRISE_PROFILE; // Business-class connections
                    } else if (uploadMbps < 300) {
                        return ULTRA_PROFILE; // High-speed fiber (120-300 Mbps)
                    } else if (uploadMbps < 600) {
                        return FIBER_PROFILE; // Very high-speed fiber
                    } else {
                        return GIGABIT_PROFILE; // 600+ Mbps - True gigabit speeds
                    }
                }

                // üéØ LEGACY: Latency-based profiles using external modules
                function getLatencyBasedProfile(bandwidth) {
                    if (bandwidth >= 100) {
                        return GIGABIT_PROFILE; // Gigabit (800+ Mbps) - true gigabit speeds
                    } else if (bandwidth >= 15) {
                        return ULTRA_PROFILE; // Ultra Fast (120+ Mbps)
                    } else if (bandwidth >= 8) {
                        return FIBER_PROFILE; // Very Fast (64+ Mbps) - use FIBER profile
                    } else if (bandwidth >= 4) {
                        return CABLE_PROFILE; // Moderate (32+ Mbps) - use CABLE profile
                    } else if (bandwidth >= 2) {
                        return DSL_PROFILE; // Slow (16+ Mbps) - use DSL profile
                    } else {
                        return DSL_PROFILE; // Very Slow (<16 Mbps) - use DSL profile
                    }
                }

                // üéØ SMART DUAL-TEST PROFILE SELECTION: Run both tests, use the best result
                async function getOptimalProfile(bandwidth, connectionInfo) {
                    if (!USE_UPLOAD_SPEED_DETECTION) {
                        console.log('üì° Using latency-based detection (legacy mode)');
                        return getLatencyBasedProfile(bandwidth);
                    }

                    // Collect all available speed measurements
                    const latencyEstimate = bandwidth * 8; // Convert to Mbps
                    const bandwidthTest = connectionInfo?.actualBandwidthTest || null; // From detectConnectionQuality
                    
                    console.log(`üì° Latency estimate: ${latencyEstimate.toFixed(1)} Mbps`);
                    if (bandwidthTest) {
                        console.log(`üì° Bandwidth test: ${bandwidthTest.toFixed(1)} Mbps`);
                    }
                    
                    try {
                        // Additional validation test (skip if we already have good bandwidth data)
                        let validationTest = null;
                        if (!bandwidthTest || bandwidthTest < 10) {
                            validationTest = await detectRealUploadSpeed();
                        if (validationTest) {
                            console.log(`üì° Validation test: ${validationTest.toFixed(1)} Mbps`);
                            }
                        } else {
                            console.log(`üì° Skipping validation test - bandwidth test sufficient: ${bandwidthTest.toFixed(1)} Mbps`);
                        }
                        
                        // Collect all valid measurements
                        // Smart selection: prefer latency estimate when it's significantly higher than small tests
                        const actualMeasurements = [];
                        if (bandwidthTest && bandwidthTest > 1) actualMeasurements.push(bandwidthTest);
                        if (validationTest && validationTest > 1) actualMeasurements.push(validationTest);
                        
                        let finalSpeed;
                        if (actualMeasurements.length > 0) {
                            const maxActualSpeed = Math.max(...actualMeasurements);
                            // If latency estimate is much higher than small test results, trust the latency estimate
                            // This handles cases where 1MB tests don't allow TCP to ramp up properly
                            if (latencyEstimate > maxActualSpeed * 3 && latencyEstimate >= 100) {
                                finalSpeed = Math.min(latencyEstimate, 200); // Cap but allow higher speeds
                                console.log(`üìä Using latency estimate (${latencyEstimate.toFixed(1)} Mbps) over small test results (${maxActualSpeed.toFixed(1)} Mbps) - TCP ramp-up factor detected`);
                            } else {
                                finalSpeed = maxActualSpeed;
                                console.log(`üìä Using actual measurements: [${actualMeasurements.join(', ')}] Mbps`);
                            }
                        } else {
                            // Fallback to latency estimate only if no actual measurements
                            finalSpeed = Math.min(latencyEstimate, 150); // Cap latency estimates
                            console.log(`üìä Using latency estimate fallback: ${finalSpeed} Mbps`);
                        }
                        
                        // Always use upload speed-based profile selection for consistency
                        const profile = getUploadProfile(finalSpeed);
                        console.log(`üéØ BEST OF ALL TESTS: ${finalSpeed.toFixed(1)} Mbps (latency: ${latencyEstimate.toFixed(1)}, bandwidth: ${bandwidthTest?.toFixed(1) || 'N/A'}, validation: ${validationTest?.toFixed(1) || 'N/A'}) ‚Üí ${profile.tier} (${(profile.partSize/1024/1024).toFixed(0)}MB parts, ${profile.parallel} parallel)`);
                        return profile;
                        
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Using latency-based profile:', error.message);
                        const fallbackProfile = getLatencyBasedProfile(bandwidth);
                        console.log(`üì° LATENCY FALLBACK: ${latencyEstimate.toFixed(1)} Mbps ‚Üí ${fallbackProfile.tier}`);
                        return fallbackProfile;
                    }
                }
                
                const profile = await getOptimalProfile(connectionInfo.bandwidth, connectionInfo);
                
                // üîç DEBUG: Validate profile object
                console.log('üîç Selected upload profile:', profile);
                if (!profile || !profile.partSize || !profile.parallel || !profile.maxCap) {
                    throw new Error(`Invalid profile returned: ${JSON.stringify(profile)}`);
                }
                
                partSize = profile.partSize;
                maxParallel = profile.parallel;
                const maxParallelCap = profile.maxCap;
                
                // üîç DEBUG: Validate calculated values
                const partsCount = Math.ceil(file.size / partSize);
                console.log('üîç Parts count calculation:', { fileSize: file.size, partSize, partsCount });
                if (partsCount <= 0 || isNaN(partsCount)) {
                    throw new Error(`Invalid parts count: ${partsCount}`);
                }
                
                console.log(`üéØ ${profile.tier} PROFILE: ${(connectionInfo.bandwidth * 8).toFixed(1)} Mbps ‚Üí ${(partSize/1024/1024).toFixed(0)}MB parts, ${maxParallel} parallel (cap: ${maxParallelCap})`);
                
                console.log(`üöÄ UNIVERSAL OPTIMIZATION: ${connectionInfo.type} ‚Üí ${partSize / (1024*1024)}MB parts, ${maxParallel} parallel (${profile.tier} tier)`);
                
                // Show performance panel and log initial info
                performanceTracker.reset();
                performanceTracker.showPerformancePanel();
                performanceTracker.updateConnection(connectionInfo);
                performanceTracker.updateStrategy(partSize, maxParallel, Math.ceil(file.size / partSize));
                
                // üîÑ PROFILE-SPECIFIC ADAPTIVE MONITORING: Use external profile monitors
                let adaptiveMonitor;
                
                // Create profile-specific adaptive monitor
                const strategy = {
                    partSize: partSize,
                    maxParallel: maxParallel,
                    maxParallelCap: maxParallelCap,
                    profile: profile
                };
                
                // üîÑ PROFILE-SPECIFIC ADAPTIVE MONITORING: Will be set up after variables are initialized
                
                // üöÄ PROFILE-AWARE PRE-WARMING: Connection establishment
                console.log('üöÄ Profile-aware connection pre-warming...');
                const warmupCount = profile.warmupCount || 16; // Use profile-specific warmup count
                const warmupPromises = [];
                
                // üéØ ENHANCED: Multiple preload triggers for connection establishment
                try {
                    const uploadHost = window.location.origin;
                    // Use data URLs to avoid 404s while still triggering connections
                    const img1 = new Image();
                    img1.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; // 1x1 transparent GIF
                    const img2 = new Image();
                    img2.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=='; // 1x1 transparent PNG
                } catch (e) { /* Ignore errors */ }
                
                // üîó AGGRESSIVE PARALLEL WARM-UP: All endpoints, no delays
                const uploadEndpoints = ['/api/multipart/start', '/api/multipart/presign-part'];
                
                for (let i = 0; i < warmupCount; i++) {
                    // Fire all warmup fetches immediately (no staggering for warmup)
                    warmupPromises.push(
                        fetch('/api/ping', { method: 'HEAD', keepalive: true })
                        .catch(() => {}) // Ignore errors, just warming
                    );
                    
                    // Warm up ALL real upload endpoints (not just every 3rd)
                    for (const endpoint of uploadEndpoints) {
                        warmupPromises.push(
                            fetch(endpoint, { method: 'OPTIONS', keepalive: true })
                        .catch(() => {}) // Ignore errors, just warming
                    );
                }
                }
                
                await Promise.allSettled(warmupPromises);
                console.log('üî• CONNECTIONS PRE-WARMED: Proceeding to launch parts...');
                
                // Provider limits
                const MIN_PART_SIZE = 5 * 1024 * 1024; // 5MB
                const MAX_NUM_PARTS = 10000;
                
                // Step 1: Start multipart upload
                const startRes = await fetch('/api/multipart/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileName: uniqueFilename,
                        contentType: file.type || 'application/octet-stream'
                    })
                });
                if (!startRes.ok) throw new Error('Failed to start multipart upload');
                const { uploadId } = await startRes.json();

                // Persistent checkpointing
                const checkpointKey = `multipart_${uniqueFilename}_${uploadId}`;
                let checkpoint = localStorage.getItem(checkpointKey);
                let completedPartsCheckpoint = checkpoint ? JSON.parse(checkpoint) : [];
                
                // Adjust part size upward if too many parts
                let partCount = Math.ceil(file.size / partSize);
                if (partCount > MAX_NUM_PARTS) {
                    partSize = Math.ceil(file.size / MAX_NUM_PARTS);
                    // Ensure partSize is at least MIN_PART_SIZE
                    if (partSize < MIN_PART_SIZE) partSize = MIN_PART_SIZE;
                    partCount = Math.ceil(file.size / partSize);
                }

                // üîí SAFETY CHECK: Validate partCount to prevent "Invalid array length" errors
                if (partCount <= 0 || partCount > MAX_NUM_PARTS || !isFinite(partCount)) {
                    throw new Error(`Invalid part count calculated: ${partCount}. File size: ${file.size}, Part size: ${partSize}`);
                }

                console.log(`üìä Upload strategy: ${partCount} parts of ${(partSize/1024/1024).toFixed(1)}MB each`);

                let parts = [];
                let completedParts = 0;
                let totalUploaded = 0; // Track total bytes uploaded across all parts
                let lastReportedTime = Date.now();
                let lastReportedBytes = 0;
                
                // üîß FIX: Use Map instead of Array to avoid "Invalid array length" errors
                // This is safer for large part counts and doesn't pre-allocate memory
                const uploadedBytesPerPart = new Map(); // Track per-part progress safely

                // Prepare all part blobs and numbers with error handling
                const partBlobs = [];
                for (let partNumber = 1; partNumber <= partCount; partNumber++) {
                    try {
                    const start = (partNumber - 1) * partSize;
                    const end = Math.min(start + partSize, file.size);
                        const blob = file.slice(start, end);
                        
                        // Validate blob
                        if (!blob || blob.size === 0) {
                            throw new Error(`Invalid blob for part ${partNumber}: size=${blob?.size}`);
                        }
                        
                    partBlobs.push({
                        partNumber,
                            blob,
                        index: partNumber - 1
                    });
                    } catch (error) {
                        console.error(`Failed to create blob for part ${partNumber}:`, error);
                        throw new Error(`File reading failed at part ${partNumber}: ${error.message}`);
                    }
                }

                // Restore completed parts from checkpoint
                for (const cp of completedPartsCheckpoint) {
                    parts[cp.PartNumber - 1] = { ETag: cp.ETag, PartNumber: cp.PartNumber };
                }

                // Parallel upload logic - More aggressive for video files
                let currentIndex = 0;
                let activeUploads = 0;
                let errorOccurred = false;

                uploadStartTime = Date.now();

                // üîÑ NOW SET UP PROFILE-SPECIFIC ADAPTIVE MONITORING: All variables are now initialized
                // Create context object with all necessary variables for monitoring
                const monitoringContext = {
                    get maxParallel() { return maxParallel; },
                    set maxParallel(value) { maxParallel = value; },
                    get totalUploaded() { return totalUploaded; },
                    get uploadStartTime() { return uploadStartTime; },
                    get activeUploads() { return activeUploads; },
                    get isUploadActive() { return isUploadActive; },
                    get isUploadCancelled() { return isUploadCancelled; },
                    get file() { return file; },
                    get fileSize() { return file.size; }
                };
                
                // Use profile-specific monitoring function
                if (profile.tier === 'GIGABIT') {
                    adaptiveMonitor = createGigabitAdaptiveMonitor(strategy, performanceTracker, monitoringContext);
                } else if (profile.tier === 'ULTRA') {
                    adaptiveMonitor = createUltraAdaptiveMonitor(strategy, performanceTracker, monitoringContext);
                } else if (profile.tier === 'FIBER') {
                    adaptiveMonitor = createFiberAdaptiveMonitor(strategy, performanceTracker, monitoringContext);
                } else if (profile.tier === 'CABLE') {
                    adaptiveMonitor = createCableAdaptiveMonitor(strategy, performanceTracker, monitoringContext);
                } else if (profile.tier === 'DSL') {
                    adaptiveMonitor = createDslAdaptiveMonitor(strategy, performanceTracker, monitoringContext);
                } else if (profile.tier === 'ENTERPRISE') {
                    adaptiveMonitor = createEnterpriseAdaptiveMonitor(strategy, performanceTracker, monitoringContext);
                } else {
                    // Fallback to CABLE monitor for unknown profiles
                    adaptiveMonitor = createCableAdaptiveMonitor(strategy, performanceTracker, monitoringContext);
                }
                
                // Register the adaptive monitor with session manager
                uploadSessionManager.registerTimer(adaptiveMonitor, 'interval');

                // üöÄ OPTIMIZED: Generate URLs on-demand for faster startup
                console.log('üöÄ Starting upload with on-demand URL generation...');
                const presignedUrls = {}; // Cache for generated URLs

                async function uploadPart(partBlob) {
                    if (errorOccurred || isUploadCancelled) return; // Check for cancellation
                    const { partNumber, blob, index } = partBlob;
                    // Skip if already completed in checkpoint
                    if (parts[partNumber - 1]) {
                        completedParts++;
                        return;
                    }
                    
                    // Check for cancellation before upload
                    if (isUploadCancelled) {
                        console.log(`Part ${partNumber} cancelled before upload`);
                        return;
                    }
                    
                    // üöÄ GENERATE URL ON-DEMAND: Faster startup, generate as needed
                    let url = presignedUrls[partNumber];
                    if (!url) {
                        try {
                            const presignPartRes = await fetch('/api/multipart/presign-part', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    fileName: uniqueFilename,
                                    uploadId,
                                    partNumber,
                                    contentType: file.type || 'application/octet-stream'
                                })
                            });
                            if (!presignPartRes.ok) throw new Error('Failed to get part pre-signed URL');
                            const { url: newUrl } = await presignPartRes.json();
                            presignedUrls[partNumber] = newUrl; // Cache for potential retries
                            url = newUrl;
                        } catch (error) {
                            console.error(`Failed to generate URL for part ${partNumber}:`, error);
                            throw error;
                        }
                    }

                    // Step 4: Upload part with retry logic
                    let etag = null;
                    let attempt = 0;
                    const maxAttempts = 5; // Increased from 3 to 5 for video files

                    while (attempt < maxAttempts && !etag && !errorOccurred && !isUploadCancelled) {
                        attempt++;
                        try {
                            const partStartTime = Date.now();
                            etag = await new Promise((resolve, reject) => {
                                // Check for cancellation before creating XMLHttpRequest
                                if (isUploadCancelled) {
                                    console.log(`Part ${partNumber} cancelled before XMLHttpRequest creation`);
                                    reject(new Error('Upload cancelled'));
                                    return;
                                }
                                
                                const partXhr = new XMLHttpRequest();
                                
                                // Track this XMLHttpRequest for cancellation
                                activeXhrRequests.push(partXhr);
                                
                                partXhr.open('PUT', url, true);
                                partXhr.setRequestHeader('Content-Type', file.type || 'application/octet-stream');

                                partXhr.upload.onprogress = function (event) {
                                    // Check for cancellation during progress
                                    if (isUploadCancelled) {
                                        console.log(`Part ${partNumber} progress cancelled - aborting`);
                                        partXhr.abort();
                                        return;
                                    }
                                    
                                    if (event.lengthComputable) {
                                        // Calculate delta for this part
                                        const prev = uploadedBytesPerPart.get(index) || 0;
                                        uploadedBytesPerPart.set(index, event.loaded);
                                        const delta = event.loaded - prev;
                                        totalUploaded += delta;

                                        // Calculate progress percentage
                                        const percent = Math.round((totalUploaded / file.size) * 100);
                                        
                                        // Real-time speed calculation (aggregate) with smoothing - less frequent updates
                                        const now = Date.now();
                                        const elapsedSec = (now - uploadStartTime) / 1000;
                                        let avgSpeed = 0;
                                        
                                        if (elapsedSec > 0) {
                                            avgSpeed = (totalUploaded / 1024 / 1024) / elapsedSec; // MB/s
                                        }
                                        
                                        const avgSpeedMbps = avgSpeed * 8; // Convert to Mbps
                                        
                                        // Only update display every 3 seconds for multipart uploads (smoother)
                                        if (now - lastEtaUpdate > 3000) {
                                            // Calculate time remaining ETA
                                            const remainingBytes = file.size - totalUploaded;
                                            const eta = remainingBytes / (avgSpeed * 1024 * 1024);
                                            
                                            // Update circular progress with elapsed time and ETA
                                        updateCircularProgress(
                                            percent,
                                                formatTime(now - uploadStartTime), // Show elapsed time
                                            `${avgSpeedMbps.toFixed(2)} Mbps`,
                                            totalUploaded,
                                                file.size,
                                                formatTime(eta * 1000) // Show time remaining
                                            );
                                            lastEtaUpdate = now;
                                        } else {
                                            // Still update progress percentage but not speed/time
                                            const progressCircle = document.getElementById('progressCircle');
                                            progressCircle.style.setProperty('--progress', percent);
                                            document.getElementById('progressPercentage').textContent = `${percent}% completed`;
                                            
                                            const uploadedGB = (totalUploaded / (1024 * 1024 * 1024)).toFixed(2);
                                            const totalGB = (file.size / (1024 * 1024 * 1024)).toFixed(2);
                                            document.getElementById('uploadProgress').textContent = `${uploadedGB} GB / ${totalGB} GB`;
                                        }

                                        lastReportedBytes = totalUploaded;
                                        lastReportedTime = now;
                                    }
                                };

                                partXhr.onload = function () {
                                    // Remove from active requests when done
                                    const index = activeXhrRequests.indexOf(partXhr);
                                    if (index > -1) activeXhrRequests.splice(index, 1);
                                    
                                    // Don't process completion if upload was cancelled
                                    if (isUploadCancelled) {
                                        console.log(`Part ${partNumber} completed but upload was cancelled - ignoring`);
                                        return;
                                    }
                                    
                                    if (partXhr.status === 200) {
                                        const etag = partXhr.getResponseHeader('ETag')?.replaceAll('"', '');
                                        // Ensure final progress for this part is counted
                                                            uploadedBytesPerPart.set(index, blob.size);
                    totalUploaded = Array.from(uploadedBytesPerPart.values()).reduce((a, b) => a + b, 0);
                                        
                                        // Track part completion
                                        const partTime = Date.now() - partStartTime;
                                        performanceTracker.logPartComplete(partNumber, blob.size, partTime, activeUploads);
                                        
                                        resolve(etag);
                                    } else {
                                        const error = new Error('Part upload failed: ' + partXhr.statusText);
                                        error.status = partXhr.status;
                                        reject(error);
                                    }
                                };
                                
                                partXhr.onerror = function () {
                                    // Remove from active requests on error
                                    const index = activeXhrRequests.indexOf(partXhr);
                                    if (index > -1) activeXhrRequests.splice(index, 1);
                                    
                                    reject(new Error('Part upload failed: Network error'));
                                };
                                
                                partXhr.onabort = function () {
                                    // Remove from active requests on abort
                                    const index = activeXhrRequests.indexOf(partXhr);
                                    if (index > -1) activeXhrRequests.splice(index, 1);
                                    
                                    console.log(`Part ${partNumber} upload aborted`);
                                    reject(new Error('Upload cancelled'));
                                };
                                
                                partXhr.send(blob);
                            });
                        } catch (err) {
                            // Check if error is due to cancellation
                            if (isUploadCancelled || err.message === 'Upload cancelled') {
                                console.log(`Part ${partNumber} cancelled during upload`);
                                return; // Exit silently for cancellation
                            }
                            
                            // Check for token expiry first
                            if (handleTokenExpiry(err, partNumber)) {
                                errorOccurred = true;
                                return; // Exit upload on token expiry
                            }
                            
                            // Enhanced error logging
                            const delay = getRetryDelayWithJitter(attempt - 1);
                            logPartError(partNumber, attempt, err.status, err, attempt < maxAttempts ? delay : null);
                            
                            if (attempt >= maxAttempts) {
                                errorOccurred = true;
                                throw new Error(`Part ${partNumber} failed after ${maxAttempts} attempts: ${err.message}`);
                            }
                            
                            // Wait with jittered delay before retry
                            await new Promise(res => setTimeout(res, delay));
                        }
                    }
                    
                    // Check for cancellation before completing part
                    if (isUploadCancelled) {
                        console.log(`Part ${partNumber} cancelled before completion`);
                        return;
                    }
                    
                    parts[partNumber - 1] = { ETag: etag, PartNumber: partNumber };
                    completedParts++;
                    
                    // Log progress every 10 parts
                    if (completedParts % 10 === 0 || completedParts === partCount) {
                        // Don't log progress if upload was cancelled
                        if (!isUploadCancelled) {
                        performanceTracker.logProgress(completedParts, partCount, totalUploaded, Date.now() - uploadStartTime);
                        }
                    }
                    
                    // Update checkpoint in localStorage
                    localStorage.setItem(checkpointKey, JSON.stringify(parts.filter(Boolean)));
                }

                // Function to manage parallel uploads - Smart staggered initiation
                async function runParallelUploads() {
                    return new Promise((resolve, reject) => {
                        let finished = 0;
                        
                        // Helper functions for part completion handling
                        function handlePartCompletion() {
                                        finished++;
                                        activeUploads--;
                                        
                                        // Check for cancellation before starting next batch
                                        if (isUploadCancelled) {
                                            console.log('Upload cancelled - stopping batch processing');
                                            reject(new Error('Upload cancelled'));
                                            return;
                                        }
                                        
                                        // Immediately start next part with aggressive scheduling
                                        if (currentIndex < partBlobs.length) {
                                            startNextBatch(); // No delay - immediate execution
                                        } else if (finished === partBlobs.length) {
                                            resolve();
                                        }
                        }
                        
                        function handlePartError(err) {
                                        if (isUploadCancelled || err.message === 'Upload cancelled') {
                                            console.log('Upload cancelled during part upload');
                                            reject(new Error('Upload cancelled'));
                                        } else {
                                        errorOccurred = true;
                                        reject(err);
                                        }
                        }
                        
                        // üéØ TCP-SMART STAGED LAUNCH: Respect bandwidth-delay product and TCP ramp-up
                        let stagingState = {
                            phase: 1,
                            lastLaunchTime: 0,
                            activeParts: 0,
                            realThroughput: 0,
                            partSpeeds: []
                        };
                        
                        function launchUploadParts() {
                            console.log(`üöÄ Starting ${profile.tier} profile launch strategy...`);
                            
                            // üéØ PROFILE-AWARE LAUNCH STRATEGY: Respect each profile's complete configuration
                            const stagingConfig = profile.stagingConfig || {};
                            
                            // Check if profile wants immediate full capacity launch
                            if (strategy.immediateFullCapacity || stagingConfig.immediateFullCapacity || stagingConfig.skipStaging) {
                                console.log(`‚ö° ${profile.tier} IMMEDIATE LAUNCH: Skipping all staging - launching at maximum capacity!`);
                                const allParts = Math.min(maxParallel, partBlobs.length);
                                const partSizeMB = (partSize/1024/1024).toFixed(0);
                                launchNextBatch(allParts, `${profile.tier} IMMEDIATE: ${allParts} parts at ${partSizeMB}MB each for maximum throughput`);
                                
                                console.log(`üöÄ ${profile.tier}: All parts launched immediately - no staging needed`);
                                return;
                            }
                            
                            // Profile uses staged launch strategy
                            console.log(`üìä ${profile.tier} STAGED LAUNCH: Using intelligent TCP-aware staging with profile-specific thresholds`);
                            console.log(`üìä ${profile.tier} CONFIG: Initial batch ${initialBatch}, monitoring every ${monitoringInterval}ms`);
                            
                            // Profile-specific initial batch size
                            const initialBatch = stagingConfig.initialBatch || 
                                               (profile.tier === 'GIGABIT' ? 6 :
                                                profile.tier === 'ULTRA' ? 4 : 
                                                profile.tier === 'FIBER' ? 3 : 
                                                profile.tier === 'ENTERPRISE' ? 2 : 2);
                            
                            launchNextBatch(initialBatch, `${(partSize/1024/1024).toFixed(0)}MB ${profile.tier} parts for TCP ramp-up`);
                            
                            // Profile-specific monitoring interval
                            const monitoringInterval = stagingConfig.timingInterval || 3000;
                            
                            // Start monitoring for staged scaling
                            const stageMonitor = setInterval(() => {
                                if (isUploadCancelled || errorOccurred) {
                                    clearInterval(stageMonitor);
                                    return;
                                }
                                
                                updateStagingMetrics();
                                checkForNextStage();
                            }, monitoringInterval);
                        }
                        
                        function updateStagingMetrics() {
                            // Calculate real throughput from actual part speeds
                            const recentParts = performanceTracker.partTimes.slice(-5);
                            if (recentParts.length > 0) {
                                const currentPartSpeeds = recentParts.map(part => part.speed * 8); // Convert to Mbps
                                stagingState.partSpeeds = currentPartSpeeds;
                                stagingState.realThroughput = currentPartSpeeds.reduce((sum, speed) => sum + speed, 0);
                                stagingState.activeParts = activeUploads;
                                
                                console.log(`üìä REAL THROUGHPUT: ${stagingState.realThroughput.toFixed(1)} Mbps (${stagingState.activeParts} active parts, avg ${(stagingState.realThroughput/stagingState.activeParts).toFixed(1)} Mbps each)`);
                            }
                        }
                        
                        function checkForNextStage() {
                            const now = Date.now();
                            const timeSinceLastLaunch = now - stagingState.lastLaunchTime;
                            const avgPartSpeed = stagingState.realThroughput / Math.max(stagingState.activeParts, 1);
                            
                            // üéØ USE PROFILE'S OWN STAGING CONFIGURATION
                            const stagingConfig = profile.stagingConfig || {};
                            
                            // Use profile's own thresholds if available, otherwise fallback to defaults
                            const thresholds = {
                                stage2: stagingConfig.stage2Threshold || (profile.tier === 'GIGABIT' ? 50 :
                                                                         profile.tier === 'ULTRA' ? 15 : 
                                                                         profile.tier === 'FIBER' ? 12 : 
                                                                         profile.tier === 'ENTERPRISE' ? 10 : 8),
                                stage3: stagingConfig.stage3Threshold || (profile.tier === 'GIGABIT' ? 200 :
                                                                         profile.tier === 'ULTRA' ? 80 : 
                                                                         profile.tier === 'FIBER' ? 50 : 
                                                                         profile.tier === 'ENTERPRISE' ? 40 : 30),
                                stage4: stagingConfig.stage4Threshold || (profile.tier === 'GIGABIT' ? 500 :
                                                                         profile.tier === 'ULTRA' ? 120 : 
                                                                         profile.tier === 'FIBER' ? 80 : 
                                                                         profile.tier === 'ENTERPRISE' ? 60 : 50),
                                batchSize: stagingConfig.batchSize || (profile.tier === 'GIGABIT' ? 6 :
                                                                      profile.tier === 'ULTRA' ? 4 : 
                                                                      profile.tier === 'FIBER' ? 3 : 2)
                            };
                            
                            // Stage 2: When parts hit threshold, launch more
                            if (stagingState.phase === 1 && avgPartSpeed > thresholds.stage2 && timeSinceLastLaunch > 3000) {
                                stagingState.phase = 2;
                                launchNextBatch(thresholds.batchSize, `Stage 2: Parts averaging ${avgPartSpeed.toFixed(1)} Mbps`);
                            }
                            // Stage 3: When total throughput hits threshold, launch more
                            else if (stagingState.phase === 2 && stagingState.realThroughput > thresholds.stage3 && timeSinceLastLaunch > 3000) {
                                stagingState.phase = 3;
                                launchNextBatch(thresholds.batchSize, `Stage 3: Total throughput ${stagingState.realThroughput.toFixed(1)} Mbps`);
                            }
                            // Stage 4: When total hits high threshold, launch remaining parts
                            else if (stagingState.phase === 3 && stagingState.realThroughput > thresholds.stage4 && timeSinceLastLaunch > 3000) {
                                stagingState.phase = 4;
                                const remaining = Math.min(thresholds.batchSize * 2, partBlobs.length - currentIndex);
                                launchNextBatch(remaining, `Stage 4: Scaling to maximum (${stagingState.realThroughput.toFixed(1)} Mbps sustained)`);
                            }
                            // Backpressure: Don't launch if speeds are dropping (profile-aware threshold)
                            else if (avgPartSpeed < profile.backpressureThreshold && stagingState.activeParts > 2) {
                                console.log(`‚ö†Ô∏è BACKPRESSURE: Part speed ${avgPartSpeed.toFixed(1)} Mbps < ${profile.backpressureThreshold} Mbps (${profile.tier}) - pausing new launches`);
                            }
                        }
                        
                        function launchNextBatch(count, reason) {
                            console.log(`üöÄ ${reason} - launching ${count} more parts`);
                            stagingState.lastLaunchTime = Date.now();
                            
                            // Use profile's configured part size consistently
                            
                            for (let i = 0; i < count && currentIndex < partBlobs.length; i++) {
                                const partBlob = partBlobs[currentIndex++];
                                activeUploads++;
                                
                                uploadPart(partBlob)
                                    .then(() => handlePartCompletion())
                                    .catch(err => handlePartError(err));
                            }
                        }
                        
                        // üîÑ CONTINUOUS LAUNCH: Handle remaining parts as slots free up
                        function startNextBatch() {
                            while (activeUploads < maxParallel && currentIndex < partBlobs.length && !isUploadCancelled) {
                                if (errorOccurred || isUploadCancelled) {
                                    console.log('Upload cancelled or error occurred - stopping new uploads');
                                    return reject(new Error(isUploadCancelled ? 'Upload cancelled' : 'Upload failed'));
                                }
                                
                                activeUploads++;
                                const partBlob = partBlobs[currentIndex++];
                                
                                // Parts 9+ launch immediately as threads free up (0.8s+)
                                uploadPart(partBlob)
                                    .then(() => handlePartCompletion())
                                    .catch(err => handlePartError(err));
                            }
                        }
                        
                        // üî• TRIGGER OPTIMIZED LAUNCH SEQUENCE
                        launchUploadParts();
                    });
                }

                await runParallelUploads();
                if (errorOccurred && !isUploadCancelled) throw new Error('Multipart upload failed');

                // Final performance analysis
                const totalTime = Date.now() - uploadStartTime;
                performanceTracker.logFinalSummary(totalTime, partCount, partSize);

                // Step 5: Complete multipart upload
                const completeRes = await fetch('/api/multipart/complete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileName: uniqueFilename,
                        uploadId,
                        parts
                    })
                });
                if (!completeRes.ok) throw new Error('Failed to complete multipart upload');

                // Notify backend after upload
                await fetch('/api/notify-upload', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileName: uniqueFilename,
                        size: file.size,
                        contentType: file.type || 'application/octet-stream'
                    })
                });

                clearInterval(uploadTimerInterval);
                lastUploadTime = Date.now() - startTime;
                lastUploadSize = file.size;
                
                setTimeout(() => {
                    const mb = lastUploadSize / 1024 / 1024;
                    const sec = lastUploadTime / 1000;
                    const speedMBs = mb / sec; // MB/s
                    const speedMbps = speedMBs * 8; // Convert to Mbps
                    
                    // Show completion screen instead of alert
                    showCompletionScreen(lastUploadTime, file.size, speedMbps);
                    
                    // Clear selected files after successful upload
                    if (selectedFiles && selectedFiles.length > 0) {
                    selectedFiles = [];
                    updateSelectedFilesDisplay();
                    updateSendButton();
                    }
                }, 2000);

                // Clear checkpoint on complete
                localStorage.removeItem(checkpointKey);
                
                // Performance monitoring cleanup handled by session manager
                
                // Clean up adaptive monitoring
                if (typeof adaptiveMonitor !== 'undefined') {
                    clearInterval(adaptiveMonitor);
                }
            } catch (error) {
                // Check if this is a cancellation - handle silently
                if (isUploadCancelled || error.message === 'Upload cancelled') {
                    console.log('Upload cancelled - cleaning up silently');
                    clearInterval(uploadTimerInterval);
                    // Don't show progress section or alert for cancellation
                    // The cancelUpload() function already handled the UI cleanup
                    
                    // Performance monitoring cleanup handled by session manager
                    
                    // Adaptive monitoring cleanup handled by session manager
                    return; // Exit silently
                }
                
                // On actual error (not cancellation), log details and show alert
                const connectionQuality = typeof detectConnectionQuality === 'function' ? await detectConnectionQuality() : 'unknown';
                const speed = document.getElementById('uploadSpeed')?.textContent || 'unknown';
                const details = {
                    fileName: uniqueFilename,
                    fileSize: file.size,
                    error: error.message || error.toString(),
                    connectionQuality,
                    speed,
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent
                };
                logUploadFailure(details);
                
                clearInterval(uploadTimerInterval);
                hideProgressSection();
                alert('Multipart upload failed: ' + error.message);
                
                // Clean up performance monitoring on error
                if (typeof performanceCheckInterval !== 'undefined') {
                    clearInterval(performanceCheckInterval);
                }
                
                // Clean up adaptive monitoring on error
                if (typeof adaptiveMonitor !== 'undefined') {
                    clearInterval(adaptiveMonitor);
                }
            }
        }

        async function refreshFileList() {
            try {
                const response = await fetch('/api/files');
                const files = await response.json();
                
                // Update main file list
                const fileList = document.getElementById('fileList');
                if (fileList) {
                    fileList.innerHTML = '';

                    if (files.length === 0) {
                        fileList.innerHTML = '<div style="text-align: center; color: #888; padding: 40px;">No files found.</div>';
                    } else {
                        files.forEach(file => {
                            const fileItem = document.createElement('div');
                            fileItem.className = 'file-item';
                            fileItem.innerHTML = `
                                <div class="file-info">
                                    <div class="file-name">${file.name}</div>
                                    <div class="file-size">${formatFileSize(file.size)}</div>
                                </div>
                                <button class="download-btn" onclick="downloadFile('${file.name}')">Download</button>
                            `;
                            fileList.appendChild(fileItem);
                        });
                        
                        // If download is active, disable all buttons and mark active one
                        if (isDownloadActive) {
                            disableAllDownloadButtons();
                            // Mark the specific downloading file if we know which one
                            if (currentDownloadFileName) {
                                markActiveDownloadButton(currentDownloadFileName);
                            }
                        }
                    }
                }
                
                // Also update completion file list if it exists and is visible
                const completionFileList = document.getElementById('completionFileList');
                if (completionFileList) {
                    completionFileList.innerHTML = '';

                    if (files.length === 0) {
                        completionFileList.innerHTML = '<div style="text-align: center; color: #888; padding: 40px;">No files found.</div>';
                    } else {
                        files.forEach(file => {
                            const fileItem = document.createElement('div');
                            fileItem.className = 'file-item';
                            fileItem.innerHTML = `
                                <div class="file-info">
                                    <div class="file-name">${file.name}</div>
                                    <div class="file-size">${formatFileSize(file.size)}</div>
                                </div>
                                <button class="download-btn" onclick="downloadFile('${file.name}')">Download</button>
                            `;
                            completionFileList.appendChild(fileItem);
                        });
                        
                        // If download is active, disable all buttons in completion list too
                        if (isDownloadActive) {
                            const completionButtons = completionFileList.querySelectorAll('.download-btn');
                            completionButtons.forEach(button => {
                                button.disabled = true;
                                button.style.opacity = '0.5';
                                button.style.cursor = 'not-allowed';
                                
                                // Check if this is the currently downloading file
                                const fileItem = button.closest('.file-item');
                                const fileNameElement = fileItem ? fileItem.querySelector('.file-name') : null;
                                const fileName = fileNameElement ? fileNameElement.textContent : '';
                                
                                if (fileName === currentDownloadFileName) {
                                    button.textContent = 'Downloading...';
                                    button.style.background = '#e0f2fe';
                                    button.style.borderColor = '#0ea5e9';
                                    button.style.color = '#0ea5e9';
                                } else {
                                    button.textContent = 'Another Download in Progress...';
                                }
                            });
                        }
                    }
                }
            } catch (error) {
                console.error('Error:', error);
                const fileList = document.getElementById('fileList');
                if (fileList) {
                    fileList.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">Error loading files.</div>';
                }
                const completionFileList = document.getElementById('completionFileList');
                if (completionFileList) {
                    completionFileList.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">Error loading files.</div>';
                }
            }
        }

        async function downloadFile(fileName) {
            // Show download progress section in new UI
            showDownloadProgress(fileName);
            
            let startTime = Date.now();
            if (downloadTimerInterval) clearInterval(downloadTimerInterval);
            downloadTimerInterval = setInterval(() => {
                // Update timer in download progress section
                const elapsed = Date.now() - startTime;
                document.getElementById('downloadTimeRemaining').textContent = formatTime(elapsed);
            }, 100);

            // üöÄ SPEED FIX: Use direct R2 public URLs for maximum speed (no backend throttling)
            const publicUrl = `${R2_PUBLIC_URL_BASE}/${encodeURIComponent(fileName)}`;

            // Step 1: Get file size with HEAD request
            let fileSize = 0;
            try {
                const headRes = await fetch(publicUrl, { method: 'HEAD' });
                if (!headRes.ok) throw new Error('Failed to get file size');
                fileSize = parseInt(headRes.headers.get('content-length'), 10);
                console.log(`File size: ${formatFileSize(fileSize)}`);
            } catch (err) {
                hideDownloadProgressOnError();
                clearInterval(downloadTimerInterval);
                alert('Failed to get file size: ' + err.message);
                return;
            }

            // üéØ DIRECT-TO-DISK DOWNLOAD: File System Access API (zero Chrome delay)
            if (fileSize > 1024 * 1024 * 1024 && 'showSaveFilePicker' in window) { // 1GB+ and supports File System Access API
                console.log(`Large file detected (${formatFileSize(fileSize)}) - using direct-to-disk streaming (zero Chrome delay)`);
                await directToDiskDownload(fileName, publicUrl, fileSize, startTime);
                return;
            }

            // For large files (1GB+), always use real progress streaming even in HTTP environments
            if (fileSize > 1024 * 1024 * 1024) {
                console.log(`Large file detected (${formatFileSize(fileSize)}) - using real progress streaming (HTTP environment)`);
                await streamingDownloadNoBlobDelay(fileName, publicUrl, fileSize, startTime);
                return;
            }

            // For smaller files, use direct URL download (fast but no real progress)
            console.log(`Small file detected (${formatFileSize(fileSize)}) - using direct URL download`);
            await directUrlDownload(fileName, publicUrl, fileSize, startTime);
        }

        // üéØ DIRECT-TO-DISK DOWNLOAD: File System Access API (zero Chrome delay) - SPEED OPTIMIZED
        async function directToDiskDownload(fileName, publicUrl, fileSize, startTime) {
            try {
                console.log('üéØ Starting TURBO DIRECT-TO-DISK download - maximum speed!');
                
                // Show save dialog
                const fileHandle = await window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{
                        description: 'Video Files',
                        accept: {
                            'video/*': ['.mp4', '.mov', '.avi', '.mkv', '.webm', '.wmv', '.mxf'],
                            'application/octet-stream': ['.mp4', '.mov', '.avi', '.mkv', '.webm', '.wmv', '.mxf']
                        }
                    }]
                });

                console.log('‚úÖ Save dialog completed, starting TURBO streaming...');
                const writable = await fileHandle.createWritable();
                
                let bytesWritten = 0;
                let lastTime = Date.now();
                let lastBytes = 0;
                let speeds = [];
                
                // üöÄ SPEED OPTIMIZATION: Dynamic parallel downloads based on connection speed
                const connectionInfo = await detectConnectionQuality();
                let CHUNK_SIZE, MAX_PARALLEL;
                
                // üéØ DYNAMIC PARALLELISM: Based on actual connection speed (File System Access API optimized)
                if (connectionInfo.bandwidth >= 20) {
                    // Ultra-fast connections (160+ Mbps) - Conservative for File System API
                    CHUNK_SIZE = 15 * 1024 * 1024; // 15MB chunks
                    MAX_PARALLEL = 3; // Reduced for stability
                    console.log(`üöÄ ULTRA MODE: ${MAX_PARALLEL} parallel streams for ${(connectionInfo.bandwidth * 8).toFixed(0)} Mbps connection`);
                } else if (connectionInfo.bandwidth >= 15) {
                    // Very fast connections (120+ Mbps) - Your connection level
                    CHUNK_SIZE = 20 * 1024 * 1024; // 20MB chunks
                    MAX_PARALLEL = 3; // Safe for File System API
                    console.log(`üöÄ TURBO MODE: ${MAX_PARALLEL} parallel streams for ${(connectionInfo.bandwidth * 8).toFixed(0)} Mbps connection`);
                } else if (connectionInfo.bandwidth >= 8) {
                    // Fast connections (64+ Mbps)
                    CHUNK_SIZE = 25 * 1024 * 1024; // 25MB chunks
                    MAX_PARALLEL = 2; // Conservative parallelism
                    console.log(`üöÄ FAST MODE: ${MAX_PARALLEL} parallel streams for ${(connectionInfo.bandwidth * 8).toFixed(0)} Mbps connection`);
                } else if (connectionInfo.bandwidth >= 3) {
                    // Medium connections (24+ Mbps)
                    CHUNK_SIZE = 30 * 1024 * 1024; // 30MB chunks
                    MAX_PARALLEL = 2; // Conservative parallelism
                    console.log(`üöÄ MEDIUM MODE: ${MAX_PARALLEL} parallel streams for ${(connectionInfo.bandwidth * 8).toFixed(0)} Mbps connection`);
                } else {
                    // Slower connections (<24 Mbps)
                    CHUNK_SIZE = 50 * 1024 * 1024; // 50MB chunks
                    MAX_PARALLEL = 1; // Single stream for safety
                    console.log(`üöÄ SAFE MODE: ${MAX_PARALLEL} stream for ${(connectionInfo.bandwidth * 8).toFixed(0)} Mbps connection`);
                }
                
                if (fileSize > 100 * 1024 * 1024) { // For files > 100MB, use parallel downloading
                    console.log(`üéØ ADAPTIVE TURBO: Using ${MAX_PARALLEL} parallel streams optimized for your connection`);
                    // await parallelDirectToDisk(publicUrl, fileSize, writable, startTime, fileName, CHUNK_SIZE, MAX_PARALLEL);
                    // DISABLED: Parallel downloads cause freezing - using single stream instead
                    await singleStreamDirectToDisk(publicUrl, fileSize, writable, startTime);
                } else {
                    // üöÄ FILE SYSTEM ACCESS API: Single stream only (prevents freezing)
                    // Parallel downloads cause browser freezing - disabled for stability
                    console.log('üéØ STABLE MODE: Using single stream direct-to-disk (no freezing, instant completion)');
                    await singleStreamDirectToDisk(publicUrl, fileSize, writable, startTime);
                }
                
                // Show "Finalizing..." message before the potentially long close operation
                document.getElementById('downloadProgressPercentage').textContent = 'Finalizing file...';
                document.getElementById('downloadProgressPercentage').style.color = '#4A90E2'; // Blue text
                console.log('üîÑ Finalizing file write to disk...');

                await writable.close();
                console.log('üéâ TURBO DIRECT-TO-DISK COMPLETE - file saved at maximum speed!');

                // Success - Go directly to completion screen
                clearInterval(downloadTimerInterval);
                const downloadTime = Date.now() - startTime;

                // Go directly to completion screen without delay
                    hideDownloadProgress(downloadTime, fileSize);
                // Show final speed
                if (downloadTime > 0 && fileSize > 0) {
                    const mb = fileSize / 1024 / 1024;
                    const sec = downloadTime / 1000;
                    const speedMBs = mb / sec;
                    const speedMbps = speedMBs * 8;
                    document.getElementById('downloadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps (avg)`;
                }
                
                console.log(`‚úÖ TURBO download complete: ${formatFileSize(fileSize)} in ${formatTime(downloadTime)} - MAXIMUM SPEED!`);
                await logDownload(fileName, fileSize, 'turbo-direct-to-disk', document.getElementById('downloadSpeed').textContent);
                
            } catch (error) {
                console.error('‚ùå Turbo direct-to-disk download error:', error);
                
                // For large files (3GB+), DO NOT fall back to blob methods - show error instead
                if (fileSize > 1024 * 1024 * 1024) {
                    hideDownloadProgressOnError();
                    clearInterval(downloadTimerInterval);
                    document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
                    
                    if (error.name === 'AbortError' || error.message.includes('user aborted')) {
                        console.log('User cancelled turbo direct-to-disk download');
                        return;
                    }
                    
                    alert(`Large file download failed: ${error.message}\n\nFor files over 1GB, please use a modern browser with File System Access API support.`);
                    return;
                }
                
                // Only for smaller files, fall back to streaming
                console.log('Falling back to streaming download for smaller file');
                await streamingDownloadNoBlobDelay(fileName, publicUrl, fileSize, startTime);
            }
        }

        // üöÄ PARALLEL DIRECT-TO-DISK: Adaptive speed with dynamic parallel connections
        async function parallelDirectToDisk(publicUrl, fileSize, writable, startTime, fileName, CHUNK_SIZE, MAX_PARALLEL) {
            const totalChunks = Math.ceil(fileSize / CHUNK_SIZE);
            
            let completedChunks = 0;
            let bytesWritten = 0;
            let lastTime = Date.now();
            let speeds = [];
            
            console.log(`üéØ ADAPTIVE PARALLEL: ${totalChunks} chunks (${(CHUNK_SIZE/1024/1024).toFixed(0)}MB each) with ${MAX_PARALLEL} connections`);
            
            // Download chunk function
            async function downloadChunk(chunkIndex) {
                const start = chunkIndex * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE - 1, fileSize - 1);
                
                const response = await fetch(publicUrl, {
                    headers: { 'Range': `bytes=${start}-${end}` }
                });
                
                if (!response.ok) throw new Error(`Chunk ${chunkIndex} failed: ${response.status}`);
                
                const reader = response.body.getReader();
                const chunks = [];
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    chunks.push(value);
                }
                
                // Combine chunk data
                const chunkData = new Uint8Array(chunks.reduce((acc, chunk) => acc + chunk.length, 0));
                let offset = 0;
                for (const chunk of chunks) {
                    chunkData.set(chunk, offset);
                    offset += chunk.length;
                }
                
                return { chunkIndex, data: chunkData, start };
            }
            
            // Process chunks in order and write to file
            const chunkPromises = [];
            const chunkResults = new Map();
            let nextChunkToWrite = 0;
            
            // Start parallel downloads
            for (let i = 0; i < Math.min(MAX_PARALLEL, totalChunks); i++) {
                chunkPromises.push(downloadChunk(i));
            }
            
            let activeDownloads = Math.min(MAX_PARALLEL, totalChunks);
            let nextChunkToStart = activeDownloads;
            
            while (completedChunks < totalChunks) {
                // Wait for next chunk to complete
                const result = await Promise.race(chunkPromises.filter(p => p));
                const chunkIndex = chunkPromises.findIndex(p => p === result);
                
                const { chunkIndex: completedIndex, data, start } = await result;
                chunkResults.set(completedIndex, data);
                
                // Write chunks in order
                while (chunkResults.has(nextChunkToWrite)) {
                    const chunkData = chunkResults.get(nextChunkToWrite);
                    await writable.write(chunkData);
                    
                    bytesWritten += chunkData.length;
                    completedChunks++;
                    chunkResults.delete(nextChunkToWrite);
                    nextChunkToWrite++;
                    
                    // Update progress
                    const now = Date.now();
                    if (now - lastTime >= 300) { // Update every 300ms for responsiveness
                        const percent = Math.round((bytesWritten / fileSize) * 100);
                        const bytesSinceLast = bytesWritten - (speeds.length > 0 ? speeds[speeds.length - 1].bytes : 0);
                        const timeSinceLast = (now - lastTime) / 1000;
                        const currentSpeed = (bytesSinceLast / 1024 / 1024) / timeSinceLast;
                        
                        speeds.push({ speed: currentSpeed, bytes: bytesWritten });
                        if (speeds.length > 8) speeds.shift();
                        
                        const avgSpeed = speeds.reduce((a, b) => a + b.speed, 0) / speeds.length;
                        const avgSpeedMbps = avgSpeed * 8;
                        
                        const remainingBytes = fileSize - bytesWritten;
                        const eta = remainingBytes / (avgSpeed * 1024 * 1024);
                        const elapsedTime = now - startTime;
                        
                        updateDownloadCircularProgress(
                            percent,
                            formatTime(elapsedTime),
                            `${avgSpeedMbps.toFixed(2)} Mbps`,
                            bytesWritten,
                            fileSize,
                            formatTime(eta * 1000)
                        );
                        
                        lastTime = now;
                    }
                }
                
                // Start next chunk download if available
                if (nextChunkToStart < totalChunks) {
                    chunkPromises[chunkIndex] = downloadChunk(nextChunkToStart);
                    nextChunkToStart++;
                } else {
                    chunkPromises[chunkIndex] = null;
                    activeDownloads--;
                }
            }
            
            console.log(`üéâ Parallel download complete: ${completedChunks} chunks processed`);
        }

        // üöÄ SINGLE STREAM DIRECT-TO-DISK: Optimized for smaller files
        async function singleStreamDirectToDisk(publicUrl, fileSize, writable, startTime) {
            let bytesWritten = 0;
            let lastTime = Date.now();
            let speeds = [];
            
            const response = await fetch(publicUrl);
            if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            
            const reader = response.body.getReader();
            
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                
                // Write directly to file system - maximum speed
                await writable.write(value);
                bytesWritten += value.length;
                
                // Update progress every 200ms for maximum responsiveness
                const now = Date.now();
                if (now - lastTime >= 200) {
                    const percent = Math.round((bytesWritten / fileSize) * 100);
                    const bytesSinceLast = bytesWritten - (speeds.length > 0 ? speeds[speeds.length - 1].bytes : 0);
                    const timeSinceLast = (now - lastTime) / 1000;
                    const currentSpeed = (bytesSinceLast / 1024 / 1024) / timeSinceLast;
                    
                    speeds.push({ speed: currentSpeed, bytes: bytesWritten });
                    if (speeds.length > 10) speeds.shift();
                    
                    const avgSpeed = speeds.reduce((a, b) => a + b.speed, 0) / speeds.length;
                    const avgSpeedMbps = avgSpeed * 8;
                    
                    const remainingBytes = fileSize - bytesWritten;
                    const eta = remainingBytes / (avgSpeed * 1024 * 1024);
                    const elapsedTime = now - startTime;
                    
                    updateDownloadCircularProgress(
                        percent,
                        formatTime(elapsedTime),
                        `${avgSpeedMbps.toFixed(2)} Mbps`,
                        bytesWritten,
                        fileSize,
                        formatTime(eta * 1000)
                    );
                    
                    lastTime = now;
                }
            }
            
            // Show 100% completion with "Finalizing..." message when streaming completes
            const progressCircle = document.getElementById('downloadProgressCircle');
            progressCircle.style.setProperty('--progress', 100);
            
            document.getElementById('downloadProgressPercentage').textContent = 'Finalizing...';
            document.getElementById('downloadProgressPercentage').style.color = '#4A90E2'; // Blue text
            document.getElementById('downloadTimeRemainingETA').textContent = '00:00:00';
        }

        // üåä STREAMING DOWNLOAD with ERR_CONTENT_LENGTH_MISMATCH detection
        async function streamingDownload(fileName, publicUrl, fileSize, startTime) {
            try {
                const response = await fetch(publicUrl);
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                
                const reader = response.body.getReader();
                let receivedLength = 0;
                let chunks = [];
                let lastTime = Date.now();
                let lastBytes = 0;
                let speeds = [];
                
                console.log('Streaming download started');
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    chunks.push(value);
                    receivedLength += value.length;
                    
                    // Update progress
                    const percent = Math.round((receivedLength / fileSize) * 100);
                    
                    // Calculate speed and ETA (update every 1 second for stability)
                    const now = Date.now();
                    if (now - lastTime >= 1000) {
                        const bytesSinceLast = receivedLength - lastBytes;
                        const timeSinceLast = (now - lastTime) / 1000;
                        const currentSpeed = (bytesSinceLast / 1024 / 1024) / timeSinceLast; // MB/s
                        
                        speeds.push(currentSpeed);
                        if (speeds.length > 6) speeds.shift(); // Keep fewer readings for stability
                        
                        const avgSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
                        const avgSpeedMbps = avgSpeed * 8; // Convert to Mbps
                        
                        // Calculate ETA with smoothing
                        const remainingBytes = fileSize - receivedLength;
                        const eta = remainingBytes / (avgSpeed * 1024 * 1024);
                        const elapsedTime = now - startTime;
                        
                        // Update download circular progress
                        updateDownloadCircularProgress(
                            percent,
                            formatTime(elapsedTime), // Show elapsed time
                            `${avgSpeedMbps.toFixed(2)} Mbps`,
                            receivedLength,
                            fileSize,
                            formatTime(eta * 1000) // Show time remaining
                        );
                        
                        lastTime = now;
                        lastBytes = receivedLength;
                    }
                }
                
                // Check for content-length mismatch
                if (receivedLength !== fileSize) {
                    console.warn(`ERR_CONTENT_LENGTH_MISMATCH detected: expected ${fileSize}, received ${receivedLength}`);
                    throw new Error(`ERR_CONTENT_LENGTH_MISMATCH: Content-Length promised ${fileSize} bytes but only ${receivedLength} bytes received`);
                }
                
                // Create and download blob with optimizations
                const blob = new Blob(chunks, { 
                    type: 'application/octet-stream',
                    // Add explicit type to help Chrome's scanner
                    endings: 'native'
                });

                // Download assembled file with optimizations
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.style.display = 'none';
                document.body.appendChild(a);

                // Force immediate download
                setTimeout(() => {
                    a.click();
                    setTimeout(() => {
                        window.URL.revokeObjectURL(url);
                        a.remove();
                    }, 1000);
                }, 100);
                
                // Success
                clearInterval(downloadTimerInterval);
                const downloadTime = Date.now() - startTime;
                const downloadSize = blob.size;
                
                hideDownloadProgress(downloadTime, downloadSize);
                
                // Show average speed
                if (downloadTime > 0 && downloadSize > 0) {
                    const mb = downloadSize / 1024 / 1024;
                    const sec = downloadTime / 1000;
                    const speedMBs = mb / sec; // MB/s
                    const speedMbps = speedMBs * 8; // Convert to Mbps
                    document.getElementById('downloadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps (avg)`;
                }
                
                console.log(`Streaming download complete: ${formatFileSize(downloadSize)} in ${formatTime(downloadTime)}`);
                
                // Log download
                await logDownload(fileName, downloadSize, 'streaming', document.getElementById('downloadSpeed').textContent);
                
            } catch (error) {
                console.error('Streaming download error:', error);
                
                // Detect content-length mismatch errors
                if (error.message.includes('ERR_CONTENT_LENGTH_MISMATCH') || error.message.includes('Content-Length')) {
                    console.log('Content-Length mismatch detected, falling back to chunked download');
                    await chunkedDownload(fileName, publicUrl, fileSize, startTime);
                } else {
                    // Show error
                    hideDownloadProgressOnError();
                    clearInterval(downloadTimerInterval);
                    document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
                    alert(`Download failed: ${error.message}`);
                }
            }
        }

        // üß© CHUNKED DOWNLOAD: Last resort for ERR_CONTENT_LENGTH_MISMATCH
        async function chunkedDownload(fileName, publicUrl, fileSize, startTime) {
            try {
                const CHUNK_SIZE = 10 * 1024 * 1024; // 10MB chunks
                const totalChunks = Math.ceil(fileSize / CHUNK_SIZE);
                let chunks = new Array(totalChunks);
                let bytesDownloaded = 0;
                let lastTime = Date.now();
                let lastBytes = 0;
                let speeds = [];
                
                console.log(`Chunked download started: ${totalChunks} chunks of ${formatFileSize(CHUNK_SIZE)}`);
                
                async function downloadChunk(chunkIndex, retries = 3) {
                    const start = chunkIndex * CHUNK_SIZE;
                    const end = Math.min(start + CHUNK_SIZE - 1, fileSize - 1);
                    
                    for (let attempt = 1; attempt <= retries; attempt++) {
                        try {
                            const response = await fetch(publicUrl, {
                                headers: { 'Range': `bytes=${start}-${end}` }
                            });
                            
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            
                            const chunk = await response.arrayBuffer();
                            chunks[chunkIndex] = chunk;
                            
                            const chunkSize = chunk.byteLength;
                            bytesDownloaded += chunkSize;
                            
                            // Update progress
                            const percent = Math.round((bytesDownloaded / fileSize) * 100);
                            
                            // Calculate speed and ETA
                            const now = Date.now();
                            if (now - lastTime >= 500) {
                                const bytesSinceLast = bytesDownloaded - lastBytes;
                                const timeSinceLast = (now - lastTime) / 1000;
                                const currentSpeed = (bytesSinceLast / 1024 / 1024) / timeSinceLast; // MB/s
                                
                                speeds.push(currentSpeed);
                                if (speeds.length > 6) speeds.shift();
                                
                                const avgSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
                                const avgSpeedMbps = avgSpeed * 8; // Convert to Mbps
                                
                                const remainingBytes = fileSize - bytesDownloaded;
                                const eta = remainingBytes / (avgSpeed * 1024 * 1024);
                                const elapsedTime = now - startTime;
                                
                                // Update download circular progress
                                updateDownloadCircularProgress(
                                    percent,
                                    formatTime(elapsedTime), // Show elapsed time
                                    `${avgSpeedMbps.toFixed(2)} Mbps`,
                                    bytesDownloaded,
                                    fileSize,
                                    formatTime(eta * 1000) // Show time remaining
                                );
                                
                                lastTime = now;
                                lastBytes = bytesDownloaded;
                            }
                            
                            console.log(`Chunk ${chunkIndex + 1}/${totalChunks} complete (${formatFileSize(chunkSize)})`);
                            return;
                            
                        } catch (error) {
                            console.warn(`Chunk ${chunkIndex + 1} attempt ${attempt} failed:`, error.message);
                            
                            if (attempt === retries) {
                                throw new Error(`Chunk ${chunkIndex + 1} failed after ${retries} attempts: ${error.message}`);
                            }
                            
                            // Wait before retry
                            await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                        }
                    }
                }
                
                // Download all chunks in parallel (limited concurrency)
                const concurrency = 3;
                for (let i = 0; i < totalChunks; i += concurrency) {
                    const batch = [];
                    for (let j = 0; j < concurrency && i + j < totalChunks; j++) {
                        batch.push(downloadChunk(i + j));
                    }
                    await Promise.all(batch);
                }
                
                // Reassemble file
                const blob = new Blob(chunks.map(chunk => new Uint8Array(chunk)), { type: 'application/octet-stream' });
                
                // Download assembled file
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                a.remove();
                
                // Success
                clearInterval(downloadTimerInterval);
                const downloadTime = Date.now() - startTime;
                const downloadSize = blob.size;
                
                hideDownloadProgress(downloadTime, downloadSize);
                
                // Show average speed
                if (downloadTime > 0 && downloadSize > 0) {
                    const mb = downloadSize / 1024 / 1024;
                    const sec = downloadTime / 1000;
                    const speedMBs = mb / sec; // MB/s
                    const speedMbps = speedMBs * 8; // Convert to Mbps
                    document.getElementById('downloadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps (avg)`;
                }
                
                console.log(`Chunked download complete: ${formatFileSize(downloadSize)} in ${formatTime(downloadTime)}`);
                
                // Log download
                await logDownload(fileName, downloadSize, 'chunked', document.getElementById('downloadSpeed').textContent);
                
            } catch (error) {
                console.error('Chunked download error:', error);
                hideDownloadProgressOnError();
                clearInterval(downloadTimerInterval);
                document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
                alert(`Chunked download failed: ${error.message}`);
            }
        }

        // üìä Log download to backend
        async function logDownload(fileName, fileSize, method, speed) {
            try {
                const connectionQuality = typeof detectConnectionQuality === 'function' ? await detectConnectionQuality() : 'unknown';
                await fetch('/api/log-download', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileName,
                        fileSize,
                        method,
                        contentType: 'application/octet-stream',
                        connectionQuality,
                        speed,
                        userAgent: navigator.userAgent
                    })
                });
            } catch (error) {
                console.warn('Failed to log download:', error.message);
            }
        }

        // On page load, set timers to last value or 00:00:00
        window.onload = function() {
            // Clear any lingering intervals from previous sessions
            if (typeof uploadTimerInterval !== 'undefined') clearInterval(uploadTimerInterval);
            if (typeof downloadTimerInterval !== 'undefined') clearInterval(downloadTimerInterval);
            
            // Reset upload states to prevent infinite loops
            isUploadActive = false;
            isUploadCancelled = false;
            isDownloadActive = false;
            activeUploads = 0;
            
            if (lastUploadTime > 0 && lastUploadSize > 0) {
                const mb = lastUploadSize / 1024 / 1024;
                const sec = lastUploadTime / 1000;
                const speedMBs = mb / sec; // MB/s
                const speedMbps = speedMBs * 8; // Convert to Mbps
                document.getElementById('uploadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps`;
            } else {
                document.getElementById('uploadSpeed').textContent = '0.00 Mbps';
            }
            if (lastDownloadTime > 0 && lastDownloadSize > 0) {
                const mb = lastDownloadSize / 1024 / 1024;
                const sec = lastDownloadTime / 1000;
                const speedMBs = mb / sec; // MB/s
                const speedMbps = speedMBs * 8; // Convert to Mbps
                document.getElementById('downloadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps`;
            } else {
                document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
            }
        };

        // Initial file list load
        refreshFileList();

        // Simple static password protection
        (function() {
            var password = 'wnet';
            var entered = sessionStorage.getItem('wnet_auth');
            if (entered !== password) {
                while (true) {
                    var input = prompt('Enter password to access this page:');
                    if (input === null) {
                        document.body.innerHTML = '<h2>Access denied.</h2>';
                        throw new Error('Access denied');
                    }
                    if (input === password) {
                        sessionStorage.setItem('wnet_auth', password);
                        break;
                    }
                }
            }
        })();

        // UI Management Functions - keeping the beautiful UI
        function generatePackageId() {
            const now = new Date();
            const timestamp = now.getFullYear().toString() + 
                             (now.getMonth() + 1).toString().padStart(2, '0') + 
                             now.getDate().toString().padStart(2, '0') + 
                             now.getHours().toString().padStart(2, '0') + 
                             now.getMinutes().toString().padStart(2, '0') + 
                             now.getSeconds().toString().padStart(2, '0');
            return `WNET-R2-${timestamp}`;
        }

        function showProgressSection(fileName) {
            isUploadActive = true;
            isUploadCompleted = false;
            isUploadCancelled = false; // Reset cancellation flag for new upload
            activeXhrRequests = []; // Clear any previous requests
            performanceTracker.disabled = false; // Re-enable performance tracking for new upload
            console.log('Upload started - setting isUploadActive to true');
            document.getElementById('uploadSection').classList.add('hidden');
            document.getElementById('progressSection').classList.remove('hidden');
        }

        function hideProgressSection() {
            document.getElementById('uploadSection').classList.remove('hidden');
            document.getElementById('progressSection').classList.add('hidden');
        }

        function updateCircularProgress(percentage, elapsedTime, speed, uploaded, total, eta = null) {
            const progressCircle = document.getElementById('progressCircle');
            // Use percentage directly (0-100)
            progressCircle.style.setProperty('--progress', percentage);
            
            document.getElementById('progressPercentage').textContent = `${percentage}% completed`;
            document.getElementById('timeRemaining').textContent = elapsedTime; // Show elapsed time
            document.getElementById('uploadSpeed').textContent = speed;
            
            // Update time remaining ETA if provided
            if (eta) {
                document.getElementById('timeRemainingETA').textContent = eta;
            }
            
            const uploadedGB = (uploaded / (1024 * 1024 * 1024)).toFixed(2);
            const totalGB = (total / (1024 * 1024 * 1024)).toFixed(2);
            document.getElementById('uploadProgress').textContent = `${uploadedGB} GB / ${totalGB} GB`;
        }

        function showDownloadProgress(fileName) {
            // Set download active state and track current file
            isDownloadActive = true;
            isDownloadCompleted = false;
            currentDownloadFileName = fileName;
            console.log('Download started - setting isDownloadActive to true');
            
            // RESET PROGRESS BAR: Clear any previous green completion styling
            const progressCircle = document.getElementById('downloadProgressCircle');
            progressCircle.style.setProperty('--progress', 0);
            progressCircle.style.background = ''; // Reset to default blue gradient
            
            // Reset text content to default blue styling
            document.getElementById('downloadProgressPercentage').textContent = '0% completed';
            document.getElementById('downloadProgressPercentage').style.color = '#4A90E2'; // Blue text
            document.getElementById('downloadTimeRemaining').textContent = '00:00:00';
            document.getElementById('downloadTimeRemainingETA').textContent = 'Calculating...';
            document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
            
            // Hide completion screen if it's currently showing
            document.getElementById('downloadCompletionScreen').classList.add('hidden');
            // Show download section and progress
            document.getElementById('downloadSection').classList.remove('hidden');
            document.getElementById('downloadProgressSection').classList.remove('hidden');
            
            // Disable all download buttons and mark the active one
            disableAllDownloadButtons();
            markActiveDownloadButton(fileName);
        }

        // Function to mark the active download button
        function markActiveDownloadButton(fileName) {
            const downloadButtons = document.querySelectorAll('.download-btn');
            downloadButtons.forEach(button => {
                // Find the button for this specific file
                const fileItem = button.closest('.file-item');
                if (fileItem) {
                    const fileNameElement = fileItem.querySelector('.file-name');
                    if (fileNameElement && fileNameElement.textContent === fileName) {
                        button.textContent = 'Downloading...';
                        button.style.background = '#e0f2fe';
                        button.style.borderColor = '#0ea5e9';
                        button.style.color = '#0ea5e9';
                    }
                }
            });
        }

        function hideDownloadProgress(downloadTime = null, downloadSize = null) {
            // Reset download active state and clear current file
            isDownloadActive = false;
            currentDownloadFileName = null;
            console.log('Download completed - setting isDownloadActive to false');
            
            // Debug: Log the parameters being passed
            console.log('hideDownloadProgress called with:', {
                downloadTime,
                downloadSize,
                downloadTimeInSeconds: downloadTime ? downloadTime / 1000 : null,
                downloadSizeInMB: downloadSize ? downloadSize / 1024 / 1024 : null
            });
            
            // Update global variables if provided
            if (downloadTime !== null) {
                lastDownloadTime = downloadTime;
                console.log('Updated lastDownloadTime to:', lastDownloadTime);
            }
            if (downloadSize !== null) {
                lastDownloadSize = downloadSize;
                console.log('Updated lastDownloadSize to:', lastDownloadSize);
            }
            
            document.getElementById('downloadProgressSection').classList.add('hidden');
            // Show completion state instead of just hiding
            showDownloadCompletion();
        }

        function showDownloadCompletion() {
            // Set download completion state
            isDownloadCompleted = true;
            
            // Hide download section and show download completion screen
            document.getElementById('downloadSection').classList.add('hidden');
            document.getElementById('downloadCompletionScreen').classList.remove('hidden');
            
            // Debug: Log the values being used
            console.log('showDownloadCompletion called with:', {
                lastDownloadTime,
                lastDownloadSize,
                timeInSeconds: lastDownloadTime / 1000,
                sizeInMB: lastDownloadSize / 1024 / 1024
            });
            
            // Update completion stats
            if (lastDownloadTime > 0 && lastDownloadSize > 0) {
                // Format time as HH:MM:SS
                const totalSeconds = Math.floor(lastDownloadTime / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('downloadCompletionTimeFullScreen').textContent = `Total time ${timeString}`;                
                // Calculate speed in Mbps
                const mb = lastDownloadSize / 1024 / 1024;
                const sec = lastDownloadTime / 1000;
                const speedMBs = mb / sec;
                const speedMbps = speedMBs * 8;
                
                console.log('Speed calculation:', {
                    mb: mb.toFixed(2),
                    sec: sec.toFixed(2),
                    speedMBs: speedMBs.toFixed(2),
                    speedMbps: speedMbps.toFixed(2)
                });
                
                document.getElementById('downloadCompletionSpeedFullScreen').textContent = `${speedMbps.toFixed(2)} Mbps`;                
                // Format size in GB
                const sizeGB = (lastDownloadSize / (1024 * 1024 * 1024)).toFixed(2);
                document.getElementById('downloadCompletionDownloaded').textContent = `${sizeGB} GB`;
            } else {
                console.log('Download completion data missing:', {
                    lastDownloadTime,
                    lastDownloadSize
                });
            }
            
            // Populate file list in completion screen
            populateCompletionFileList();
            
            // Re-enable all download buttons
            enableAllDownloadButtons();
        }

        // Function to populate file list in completion screen
        async function populateCompletionFileList() {
            try {
                const response = await fetch('/api/files');
                const files = await response.json();
                
                const fileList = document.getElementById('completionFileList');
                fileList.innerHTML = '';

                if (files.length === 0) {
                    fileList.innerHTML = '<div style="text-align: center; color: #888; padding: 40px;">No files found.</div>';
                    return;
                }

                files.forEach(file => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.innerHTML = `
                        <div class="file-info">
                            <div class="file-name">${file.name}</div>
                            <div class="file-size">${formatFileSize(file.size)}</div>
                        </div>
                        <button class="download-btn" onclick="downloadFile('${file.name}')">Download</button>
                    `;
                    fileList.appendChild(fileItem);
                });
            } catch (error) {
                console.error('Error:', error);
                const fileList = document.getElementById('completionFileList');
                fileList.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">Error loading files.</div>';
            }
        }

        function updateDownloadCircularProgress(percentage, elapsedTime, speed, downloaded, total, eta = null) {
            // Update circular progress for downloads
            const progressCircle = document.getElementById('downloadProgressCircle');
            const roundedPercentage = Math.round(percentage);
            progressCircle.style.setProperty('--progress', roundedPercentage);
            
            // Update text content
            document.getElementById('downloadProgressPercentage').textContent = `${roundedPercentage}% completed`;
            document.getElementById('downloadTimeRemaining').textContent = elapsedTime; // Show elapsed time
            document.getElementById('downloadSpeed').textContent = speed;
            
            // Update time remaining ETA if provided
            if (eta) {
                document.getElementById('downloadTimeRemainingETA').textContent = eta;
            }
            
            // Update stats
            const downloadedGB = (downloaded / (1024 * 1024 * 1024)).toFixed(2);
            const totalGB = (total / (1024 * 1024 * 1024)).toFixed(2);
            document.getElementById('downloadProgressText').textContent = `${downloadedGB} GB / ${totalGB} GB`;
        }

        function cancelUpload() {
            // Set cancellation flag to stop new uploads IMMEDIATELY
            isUploadCancelled = true;
            console.log('Upload cancellation requested - stopping all active uploads');
            
            // Immediately disable performance tracking to prevent any more logging
            performanceTracker.disabled = true;
            
            // Abort all active XMLHttpRequest objects
            activeXhrRequests.forEach((xhr, index) => {
                if (xhr && xhr.readyState !== XMLHttpRequest.DONE) {
                    console.log(`Aborting active upload request ${index + 1}/${activeXhrRequests.length}`);
                    xhr.abort();
                }
            });
            activeXhrRequests = []; // Clear the array
            
            // Reset global upload state
            isUploadActive = false;
            isUploadCompleted = false;
            console.log('Upload cancelled - resetting global state');
            
            // Hide progress section and show upload section
            hideProgressSection();
            
            // Clear any running timers
            if (uploadTimerInterval) clearInterval(uploadTimerInterval);
            
            // Clear selected files
            if (selectedFiles && selectedFiles.length > 0) {
                selectedFiles = [];
                updateSelectedFilesDisplay();
                updateSendButton();
            }
            
            // Reset file input
            const fileInput = document.getElementById('fileInput');
            if (fileInput) fileInput.value = '';
            
            // Reset progress displays
            const progressCircle = document.getElementById('progressCircle');
            if (progressCircle) progressCircle.style.setProperty('--progress', 0);
            
            const progressPercentage = document.getElementById('progressPercentage');
            if (progressPercentage) progressPercentage.textContent = '0% completed';
            
            const timeRemaining = document.getElementById('timeRemaining');
            if (timeRemaining) timeRemaining.textContent = '00:00:00';
            
            const timeRemainingETA = document.getElementById('timeRemainingETA');
            if (timeRemainingETA) timeRemainingETA.textContent = 'Calculating...';
            
            const uploadSpeed = document.getElementById('uploadSpeed');
            if (uploadSpeed) uploadSpeed.textContent = '0.00 Mbps';
            
            const uploadProgress = document.getElementById('uploadProgress');
            if (uploadProgress) uploadProgress.textContent = '0 GB / 0 GB';
            
            // Reset upload tracking variables
            lastUploadTime = 0;
            lastUploadSize = 0;
            lastLoaded = 0;
            uploadStartTime = 0;
            etaHistory = [];
            speedHistory = [];
            
            // Reset cancellation flag after cleanup
            setTimeout(() => {
                isUploadCancelled = false;
                console.log('Upload cancellation cleanup complete');
            }, 1000);
            
            // No alert popup - silent cancellation
        }

        // Global variables
        let selectedFiles = [];
        let currentSection = 'upload'; // 'upload' or 'download'

        // Global upload state tracking
        let isUploadActive = false;
        let isUploadCompleted = false;
        let isUploadCancelled = false; // Add cancellation flag
        let isDownloadActive = false; // Add download active flag
        let isDownloadCompleted = false; // Add download completion flag
        let currentDownloadFileName = null; // Track currently downloading file
        let activeXhrRequests = []; // Track active XMLHttpRequest objects for cancellation

        // üõë CLEANUP - Reset states to stop any running intervals
        (function cleanup() {
            isUploadActive = false;
            isUploadCancelled = false;
            isDownloadActive = false;
            activeUploads = 0;
            console.log('üõë States reset - any running intervals will auto-stop');
        })();

        // Tab Management
        function switchTab(tabName) {
            const uploadSection = document.getElementById('uploadSection');
            const downloadSection = document.getElementById('downloadSection');
            const progressSection = document.getElementById('progressSection');
            const completionSection = document.getElementById('completionSection');
            const downloadCompletionScreen = document.getElementById('downloadCompletionScreen');
            const uploadTab = document.getElementById('uploadTab');
            const downloadTab = document.getElementById('downloadTab');
            
            // Update tab states
            uploadTab.classList.remove('active');
            downloadTab.classList.remove('active');
            
            // Show/hide sections
            if (tabName === 'upload') {
                downloadSection.classList.add('hidden');
                downloadCompletionScreen.classList.add('hidden'); // Hide download completion when switching to upload
                uploadTab.classList.add('active');
                currentSection = 'upload';
                
                // Check what state we should show in upload tab based on global state
                if (isUploadActive) {
                    // There's an active upload - show progress section
                    uploadSection.classList.add('hidden');
                    progressSection.classList.remove('hidden');
                    completionSection.classList.add('hidden');
                    console.log('Showing progress section - upload is active');
                } else if (isUploadCompleted) {
                    // There's a completion screen - show it
                    uploadSection.classList.add('hidden');
                    progressSection.classList.add('hidden');
                    completionSection.classList.remove('hidden');
                    console.log('Showing completion section - upload completed');
                } else {
                    // Normal state - show upload section
                    uploadSection.classList.remove('hidden');
                    progressSection.classList.add('hidden');
                    completionSection.classList.add('hidden');
                    console.log('Showing upload section - normal state');
                }
            } else if (tabName === 'download') {
                uploadSection.classList.add('hidden');
                progressSection.classList.add('hidden'); // Hide progress when switching to download (but don't change state)
                completionSection.classList.add('hidden'); // Hide upload completion when switching to download
                downloadTab.classList.add('active');
                currentSection = 'download';
                
                // Check what state we should show in download tab based on global state
                if (isDownloadActive) {
                    // There's an active download - show download section with progress
                    downloadSection.classList.remove('hidden');
                    downloadCompletionScreen.classList.add('hidden');
                    document.getElementById('downloadProgressSection').classList.remove('hidden');
                    console.log('Showing download progress - download is active');
                } else if (isDownloadCompleted) {
                    // Download completion is active - show full-screen completion
                    downloadSection.classList.add('hidden');
                    downloadCompletionScreen.classList.remove('hidden');
                    document.getElementById('downloadProgressSection').classList.add('hidden');
                    console.log('Showing download completion screen');
                } else {
                    // Normal state - show download section
                    downloadSection.classList.remove('hidden');
                    downloadCompletionScreen.classList.add('hidden');
                    document.getElementById('downloadProgressSection').classList.add('hidden');
                    refreshFileList(); // Refresh file list when switching to downloads
                    console.log('Showing download section - normal state');
                }
            }
        }

        // File Selection Management
        function updateSelectedFilesDisplay() {
            const uploadZone = document.getElementById('uploadZone');
            const uploadContent = document.getElementById('uploadContent');
            const uploadZoneFiles = document.getElementById('uploadZoneFiles');
            const selectedFilesDiv = document.getElementById('selectedFiles');
            
            // Hide the old selected files section
                selectedFilesDiv.style.display = 'none';
            
            if (selectedFiles.length === 0) {
                // No files - show normal upload content
                uploadZone.classList.remove('has-files');
                uploadContent.style.display = 'flex';
                uploadZoneFiles.innerHTML = '';
                return;
            }
            
            // Has files - show files inside upload zone
            uploadZone.classList.add('has-files');
            uploadContent.style.display = 'flex';
            uploadZoneFiles.innerHTML = '';
            
            selectedFiles.forEach((file, index) => {
                const fileDiv = document.createElement('div');
                fileDiv.className = 'upload-zone-file';
                fileDiv.innerHTML = `
                    <div class="upload-zone-file-info">
                        <div class="upload-zone-file-name">${file.name}</div>
                        <div class="upload-zone-file-size">${formatFileSize(file.size)}</div>
                    </div>
                    <button class="upload-zone-file-remove" onclick="removeFile(${index})" title="Remove file">‚úï</button>
                `;
                uploadZoneFiles.appendChild(fileDiv);
            });
        }

        function removeFile(index) {
            selectedFiles.splice(index, 1);
            updateSelectedFilesDisplay();
            updateSendButton();
        }

        function updateSendButton() {
            const sendButton = document.getElementById('sendButton');
            sendButton.disabled = selectedFiles.length === 0;
        }

        // Drag and Drop Functionality
        function setupDragAndDrop() {
            const uploadZone = document.getElementById('uploadZone');
            
            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('dragover');
            });
            
            uploadZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('dragover');
            });
            
            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('dragover');
                
                const files = Array.from(e.dataTransfer.files);
                if (files.length > 0) {
                    // Filter for video files only
                    const videoFiles = files.filter(file => isValidVideoFile(file));
                    if (videoFiles.length > 0) {
                        // Only allow 1 file at a time - replace existing selection
                        selectedFiles = [videoFiles[0]]; // Take only the first file
                        updateSelectedFilesDisplay();
                        updateSendButton();
                    } else {
                        alert('Please select video files only.');
                    }
                }
            });
        }

        // File Input Event Listeners
        function setupFileInputs() {
            const fileInput = document.getElementById('fileInput');
            const folderInput = document.getElementById('folderInput');
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    const files = Array.from(e.target.files);
                    const videoFiles = files.filter(file => isValidVideoFile(file));
                    if (videoFiles.length > 0) {
                        // Only allow 1 file at a time - replace existing selection
                        selectedFiles = [videoFiles[0]]; // Take only the first file
                        updateSelectedFilesDisplay();
                        updateSendButton();
                    } else {
                        alert('Please select video files only.');
                    }
                }
            });
            
            folderInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    const files = Array.from(e.target.files);
                    const videoFiles = files.filter(file => isValidVideoFile(file));
                    if (videoFiles.length > 0) {
                        // Only allow 1 file at a time - replace existing selection
                        selectedFiles = [videoFiles[0]]; // Take only the first file
                        updateSelectedFilesDisplay();
                        updateSendButton();
                    } else {
                        alert('No video files found in the selected folder(s).');
                    }
                }
            });
        }

        // Video file validation
        function isValidVideoFile(file) {
            // List of supported video formats
            const supportedFormats = {
                'video/mp4': '.mp4',
                'video/quicktime': '.mov',
                'video/x-msvideo': '.avi',
                'video/x-matroska': '.mkv',
                'video/webm': '.webm',
                'video/x-ms-wmv': '.wmv',
                'application/mxf': '.mxf'  // Added MXF format
            };

            // Check file extension
            const extension = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));
            const validExtension = Object.values(supportedFormats).includes(extension);

            // Check MIME type
            const validMimeType = Object.keys(supportedFormats).includes(file.type);

            if (!validExtension && !validMimeType) {
                const supportedList = Object.values(supportedFormats).join(', ');
                alert(`Unsupported video format. Please use one of these formats: ${supportedList}`);
                return false;
            }

            return true;
        }

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');
            const minutes = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0');
            const seconds = String(totalSeconds % 60).padStart(2, '0');
            return `${hours}:${minutes}:${seconds}`;
        }

        function formatFileSize(bytes) {
            if (bytes >= 1024 * 1024 * 1024) {
                return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
            } else if (bytes >= 1024 * 1024) {
                return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
            } else if (bytes >= 1024) {
                return (bytes / 1024).toFixed(2) + ' KB';
            }
            return bytes + ' bytes';
        }

        function getTimestampedFilename(filename) {
            const dotIndex = filename.lastIndexOf('.');
            const base = dotIndex !== -1 ? filename.substring(0, dotIndex) : filename;
            const ext = dotIndex !== -1 ? filename.substring(dotIndex) : '';
            const now = new Date();
            const timestamp = `${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}_${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}${String(now.getSeconds()).padStart(2,'0')}`;
            return `${base}_${timestamp}${ext}`;
        }

        // Smooth ETA calculation to prevent jumping
        function calculateSmoothETA(loaded, total, currentSpeed) {
            if (currentSpeed <= 0) return 'Calculating...';
            
            const remainingBytes = total - loaded;
            const rawEta = remainingBytes / (currentSpeed * 1024 * 1024); // seconds
            
            // Add to history for smoothing
            etaHistory.push(rawEta);
            if (etaHistory.length > 15) etaHistory.shift(); // Keep last 15 readings for more stability
            
            // Calculate weighted average (recent readings have more weight)
            let weightedSum = 0;
            let weightSum = 0;
            for (let i = 0; i < etaHistory.length; i++) {
                const weight = i + 1; // Newer readings get higher weight
                weightedSum += etaHistory[i] * weight;
                weightSum += weight;
            }
            
            const smoothedEta = weightedSum / weightSum;
            return formatTime(smoothedEta * 1000);
        }

        // Smooth speed calculation with better averaging
        function calculateSmoothSpeed(bytesSinceLast, timeSinceLast) {
            if (timeSinceLast <= 0) return 0;
            
            const currentSpeed = (bytesSinceLast / 1024 / 1024) / timeSinceLast; // MB/s
            
            // Add to history for smoothing
            speedHistory.push(currentSpeed);
            if (speedHistory.length > 12) speedHistory.shift(); // Keep last 12 readings for stability
            
            // Calculate weighted average with exponential smoothing
            let weightedSum = 0;
            let weightSum = 0;
            for (let i = 0; i < speedHistory.length; i++) {
                const weight = Math.pow(1.5, i); // Exponential weighting
                weightedSum += speedHistory[i] * weight;
                weightSum += weight;
            }
            
            return weightedSum / weightSum;
        }

        // Initialize the interface
        document.addEventListener('DOMContentLoaded', function() {
            setupDragAndDrop();
            setupFileInputs();
            updateSendButton();
            
            // Initial file list load for downloads
            refreshFileList();
        });

        function showCompletionScreen(totalTime, fileSize, avgSpeed, fileCount = 1) {
            isUploadActive = false;
            isUploadCompleted = true;
            console.log('Upload completed - setting isUploadCompleted to true');
            
            document.getElementById('progressSection').classList.add('hidden');
            document.getElementById('completionSection').classList.remove('hidden');
            
            // Update completion screen content
            document.getElementById('completionTime').textContent = `Total time ${formatTime(totalTime)}`;
            document.getElementById('completionSpeed').textContent = `${avgSpeed.toFixed(2)} Mbps`;
            
            const fileSizeGB = (fileSize / (1024 * 1024 * 1024)).toFixed(2);
            document.getElementById('completionUploaded').textContent = `${fileSizeGB} GB`;
        }

        function startNewUpload() {
            // Reset upload states
            isUploadActive = false;
            isUploadCompleted = false;
            
            // Hide completion screen and show upload section
            document.getElementById('completionSection').classList.add('hidden');
            document.getElementById('uploadSection').classList.remove('hidden');
            
            // Clear selected files
            if (selectedFiles && selectedFiles.length > 0) {
                        selectedFiles = [];
                        updateSelectedFilesDisplay();
                        updateSendButton();
            }
            
            // Reset file input
            const fileInput = document.getElementById('fileInput');
            if (fileInput) fileInput.value = '';
        }

        // Function to disable all download buttons
        function disableAllDownloadButtons() {
            const downloadButtons = document.querySelectorAll('.download-btn');
            downloadButtons.forEach(button => {
                button.disabled = true;
                button.style.opacity = '0.5';
                button.style.cursor = 'not-allowed';
                // Only change text for buttons that aren't the active download
                if (button.textContent === 'Download') {
                    button.textContent = 'Another Download in Progress...';
                }
            });
        }

        // Function to enable all download buttons
        function enableAllDownloadButtons() {
            const downloadButtons = document.querySelectorAll('.download-btn');
            downloadButtons.forEach(button => {
                button.disabled = false;
                button.style.opacity = '1';
                button.style.cursor = 'pointer';
                button.textContent = 'Download';
            });
        }

        function hideDownloadProgressOnError() {
            // Reset download active state on error
            isDownloadActive = false;
            isDownloadCompleted = false;
            currentDownloadFileName = null;
            console.log('Download error - resetting download states');
            
            document.getElementById('downloadProgressSection').classList.add('hidden');
            // Hide completion screen if it was shown
            document.getElementById('downloadCompletionScreen').classList.add('hidden');
            // Show download section
            document.getElementById('downloadSection').classList.remove('hidden');
            // Re-enable all download buttons without showing completion
            enableAllDownloadButtons();
        }

        function startNewDownload() {
            // Reset download completion state
            isDownloadCompleted = false;
            
            // Hide completion screen and show download section
            document.getElementById('downloadCompletionScreen').classList.add('hidden');
            document.getElementById('downloadSection').classList.remove('hidden');
            
            // Refresh file list in the main download section
            refreshFileList();
        }

        // üöÄ STREAMING DOWNLOAD WITHOUT BLOB - Bypasses Chrome's blob processing delays
        async function streamingDownloadNoBlobDelay(fileName, publicUrl, fileSize, startTime) {
            try {
                console.log('Starting real progress download...');
                
                const response = await fetch(publicUrl);
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                
                const reader = response.body.getReader();
                let receivedLength = 0;
                let chunks = [];
                let lastTime = Date.now();
                let lastBytes = 0;
                let speeds = [];
                
                console.log('Real download progress started');
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    chunks.push(value);
                    receivedLength += value.length;
                    
                    // Update progress every 500ms for responsive UI
                    const now = Date.now();
                    if (now - lastTime >= 500) {
                        const percent = Math.round((receivedLength / fileSize) * 100);
                        const bytesSinceLast = receivedLength - lastBytes;
                        const timeSinceLast = (now - lastTime) / 1000;
                        const currentSpeed = (bytesSinceLast / 1024 / 1024) / timeSinceLast; // MB/s
                        
                        speeds.push(currentSpeed);
                        if (speeds.length > 8) speeds.shift(); // Keep last 8 readings
                        
                        const avgSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
                        const avgSpeedMbps = avgSpeed * 8; // Convert to Mbps
                        
                        // Calculate ETA
                        const remainingBytes = fileSize - receivedLength;
                        const eta = remainingBytes / (avgSpeed * 1024 * 1024);
                        const elapsedTime = now - startTime;
                        
                        // Update download circular progress with real data
                        updateDownloadCircularProgress(
                            percent,
                            formatTime(elapsedTime),
                            `${avgSpeedMbps.toFixed(2)} Mbps`,
                            receivedLength,
                            fileSize,
                            formatTime(eta * 1000)
                        );
                        
                        lastTime = now;
                        lastBytes = receivedLength;
                    }
                }
                
                console.log('Download complete, creating optimized blob...');
                
                // Optimized blob creation with immediate download
                const blob = new Blob(chunks, { 
                    type: 'application/octet-stream'
                });
                
                // Immediate download trigger
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.style.display = 'none';
                document.body.appendChild(a);
                
                // Trigger download immediately
                a.click();
                
                // Clean up after short delay
                setTimeout(() => {
                    window.URL.revokeObjectURL(url);
                    a.remove();
                }, 1000);
                
                // Success with real timing
                clearInterval(downloadTimerInterval);
                const downloadTime = Date.now() - startTime;
                const downloadSize = blob.size;
                
                hideDownloadProgress(downloadTime, downloadSize);
                
                // Show real average speed
                if (downloadTime > 0 && downloadSize > 0) {
                    const mb = downloadSize / 1024 / 1024;
                    const sec = downloadTime / 1000;
                    const speedMBs = mb / sec;
                    const speedMbps = speedMBs * 8;
                    document.getElementById('downloadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps (avg)`;
                }
                
                console.log(`Real download complete: ${formatFileSize(downloadSize)} in ${formatTime(downloadTime)}`);
                
                // Log download
                await logDownload(fileName, downloadSize, 'real-progress', document.getElementById('downloadSpeed').textContent);
                
            } catch (error) {
                console.error('Download error:', error);
                hideDownloadProgressOnError();
                clearInterval(downloadTimerInterval);
                document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
                alert(`Download failed: ${error.message}`);
            }
        }

        // üåä STREAMING DOWNLOAD with ERR_CONTENT_LENGTH_MISMATCH detection
        async function streamingDownload(fileName, publicUrl, fileSize, startTime) {
            try {
                const response = await fetch(publicUrl);
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                
                const reader = response.body.getReader();
                let receivedLength = 0;
                let chunks = [];
                let lastTime = Date.now();
                let lastBytes = 0;
                let speeds = [];
                
                console.log('Streaming download started');
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    chunks.push(value);
                    receivedLength += value.length;
                    
                    // Update progress
                    const percent = Math.round((receivedLength / fileSize) * 100);
                    
                    // Calculate speed and ETA (update every 1 second for stability)
                    const now = Date.now();
                    if (now - lastTime >= 1000) {
                        const bytesSinceLast = receivedLength - lastBytes;
                        const timeSinceLast = (now - lastTime) / 1000;
                        const currentSpeed = (bytesSinceLast / 1024 / 1024) / timeSinceLast; // MB/s
                        
                        speeds.push(currentSpeed);
                        if (speeds.length > 6) speeds.shift(); // Keep fewer readings for stability
                        
                        const avgSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
                        const avgSpeedMbps = avgSpeed * 8; // Convert to Mbps
                        
                        // Calculate ETA with smoothing
                        const remainingBytes = fileSize - receivedLength;
                        const eta = remainingBytes / (avgSpeed * 1024 * 1024);
                        const elapsedTime = now - startTime;
                        
                        // Update download circular progress
                        updateDownloadCircularProgress(
                            percent,
                            formatTime(elapsedTime), // Show elapsed time
                            `${avgSpeedMbps.toFixed(2)} Mbps`,
                            receivedLength,
                            fileSize,
                            formatTime(eta * 1000) // Show time remaining
                        );
                        
                        lastTime = now;
                        lastBytes = receivedLength;
                    }
                }
                
                // Check for content-length mismatch
                if (receivedLength !== fileSize) {
                    console.warn(`ERR_CONTENT_LENGTH_MISMATCH detected: expected ${fileSize}, received ${receivedLength}`);
                    throw new Error(`ERR_CONTENT_LENGTH_MISMATCH: Content-Length promised ${fileSize} bytes but only ${receivedLength} bytes received`);
                }
                
                // Create and download blob with optimizations
                const blob = new Blob(chunks, { 
                    type: 'application/octet-stream',
                    // Add explicit type to help Chrome's scanner
                    endings: 'native'
                });

                // Download assembled file with optimizations
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.style.display = 'none';
                document.body.appendChild(a);

                // Force immediate download
                setTimeout(() => {
                    a.click();
                    setTimeout(() => {
                        window.URL.revokeObjectURL(url);
                        a.remove();
                    }, 1000);
                }, 100);
                
                // Success
                clearInterval(downloadTimerInterval);
                const downloadTime = Date.now() - startTime;
                const downloadSize = blob.size;
                
                hideDownloadProgress(downloadTime, downloadSize);
                
                // Show average speed
                if (downloadTime > 0 && downloadSize > 0) {
                    const mb = downloadSize / 1024 / 1024;
                    const sec = downloadTime / 1000;
                    const speedMBs = mb / sec; // MB/s
                    const speedMbps = speedMBs * 8; // Convert to Mbps
                    document.getElementById('downloadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps (avg)`;
                }
                
                console.log(`Streaming download complete: ${formatFileSize(downloadSize)} in ${formatTime(downloadTime)}`);
                
                // Log download
                await logDownload(fileName, downloadSize, 'streaming', document.getElementById('downloadSpeed').textContent);
                
            } catch (error) {
                console.error('Streaming download error:', error);
                
                // Detect content-length mismatch errors
                if (error.message.includes('ERR_CONTENT_LENGTH_MISMATCH') || error.message.includes('Content-Length')) {
                    console.log('Content-Length mismatch detected, falling back to chunked download');
                    await chunkedDownload(fileName, publicUrl, fileSize, startTime);
                } else {
                    // Show error
                    hideDownloadProgressOnError();
                    clearInterval(downloadTimerInterval);
                    document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
                    alert(`Download failed: ${error.message}`);
                }
            }
        }

        // üß© CHUNKED DOWNLOAD: Last resort for ERR_CONTENT_LENGTH_MISMATCH
        async function chunkedDownload(fileName, publicUrl, fileSize, startTime) {
            try {
                const CHUNK_SIZE = 10 * 1024 * 1024; // 10MB chunks
                const totalChunks = Math.ceil(fileSize / CHUNK_SIZE);
                let chunks = new Array(totalChunks);
                let bytesDownloaded = 0;
                let lastTime = Date.now();
                let lastBytes = 0;
                let speeds = [];
                
                console.log(`Chunked download started: ${totalChunks} chunks of ${formatFileSize(CHUNK_SIZE)}`);
                
                async function downloadChunk(chunkIndex, retries = 3) {
                    const start = chunkIndex * CHUNK_SIZE;
                    const end = Math.min(start + CHUNK_SIZE - 1, fileSize - 1);
                    
                    for (let attempt = 1; attempt <= retries; attempt++) {
                        try {
                            const response = await fetch(publicUrl, {
                                headers: { 'Range': `bytes=${start}-${end}` }
                            });
                            
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            
                            const chunk = await response.arrayBuffer();
                            chunks[chunkIndex] = chunk;
                            
                            const chunkSize = chunk.byteLength;
                            bytesDownloaded += chunkSize;
                            
                            // Update progress
                            const percent = Math.round((bytesDownloaded / fileSize) * 100);
                            
                            // Calculate speed and ETA
                            const now = Date.now();
                            if (now - lastTime >= 500) {
                                const bytesSinceLast = bytesDownloaded - lastBytes;
                                const timeSinceLast = (now - lastTime) / 1000;
                                const currentSpeed = (bytesSinceLast / 1024 / 1024) / timeSinceLast; // MB/s
                                
                                speeds.push(currentSpeed);
                                if (speeds.length > 6) speeds.shift();
                                
                                const avgSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
                                const avgSpeedMbps = avgSpeed * 8; // Convert to Mbps
                                
                                const remainingBytes = fileSize - bytesDownloaded;
                                const eta = remainingBytes / (avgSpeed * 1024 * 1024);
                                const elapsedTime = now - startTime;
                                
                                // Update download circular progress
                                updateDownloadCircularProgress(
                                    percent,
                                    formatTime(elapsedTime), // Show elapsed time
                                    `${avgSpeedMbps.toFixed(2)} Mbps`,
                                    bytesDownloaded,
                                    fileSize,
                                    formatTime(eta * 1000) // Show time remaining
                                );
                                
                                lastTime = now;
                                lastBytes = bytesDownloaded;
                            }
                            
                            console.log(`Chunk ${chunkIndex + 1}/${totalChunks} complete (${formatFileSize(chunkSize)})`);
                            return;
                            
                        } catch (error) {
                            console.warn(`Chunk ${chunkIndex + 1} attempt ${attempt} failed:`, error.message);
                            
                            if (attempt === retries) {
                                throw new Error(`Chunk ${chunkIndex + 1} failed after ${retries} attempts: ${error.message}`);
                            }
                            
                            // Wait before retry
                            await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                        }
                    }
                }
                
                // Download all chunks in parallel (limited concurrency)
                const concurrency = 3;
                for (let i = 0; i < totalChunks; i += concurrency) {
                    const batch = [];
                    for (let j = 0; j < concurrency && i + j < totalChunks; j++) {
                        batch.push(downloadChunk(i + j));
                    }
                    await Promise.all(batch);
                }
                
                // Reassemble file
                const blob = new Blob(chunks.map(chunk => new Uint8Array(chunk)), { type: 'application/octet-stream' });
                
                // Download assembled file
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                a.remove();
                
                // Success
                clearInterval(downloadTimerInterval);
                const downloadTime = Date.now() - startTime;
                const downloadSize = blob.size;
                
                hideDownloadProgress(downloadTime, downloadSize);
                
                // Show average speed
                if (downloadTime > 0 && downloadSize > 0) {
                    const mb = downloadSize / 1024 / 1024;
                    const sec = downloadTime / 1000;
                    const speedMBs = mb / sec; // MB/s
                    const speedMbps = speedMBs * 8; // Convert to Mbps
                    document.getElementById('downloadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps (avg)`;
                }
                
                console.log(`Chunked download complete: ${formatFileSize(downloadSize)} in ${formatTime(downloadTime)}`);
                
                // Log download
                await logDownload(fileName, downloadSize, 'chunked', document.getElementById('downloadSpeed').textContent);
                
            } catch (error) {
                console.error('Chunked download error:', error);
                hideDownloadProgressOnError();
                clearInterval(downloadTimerInterval);
                document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
                alert(`Chunked download failed: ${error.message}`);
            }
        }

        // üìä Log download to backend
        async function logDownload(fileName, fileSize, method, speed) {
            try {
                const connectionQuality = typeof detectConnectionQuality === 'function' ? await detectConnectionQuality() : 'unknown';
                await fetch('/api/log-download', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileName,
                        fileSize,
                        method,
                        contentType: 'application/octet-stream',
                        connectionQuality,
                        speed,
                        userAgent: navigator.userAgent
                    })
                });
            } catch (error) {
                console.warn('Failed to log download:', error.message);
            }
        }

        // üîó DIRECT URL DOWNLOAD: For HTTP environments without File System Access API
        async function directUrlDownload(fileName, publicUrl, fileSize, startTime) {
            try {
                console.log('Starting direct URL download (HTTP environment)...');
                
                // Show fake progress for UI while browser handles download
                let fakeProgress = 0;
                const progressInterval = setInterval(() => {
                    if (fakeProgress < 95) {
                        fakeProgress += Math.random() * 15;
                        const elapsedTime = Date.now() - startTime;
                        
                        updateDownloadCircularProgress(
                            Math.round(Math.min(fakeProgress, 95)),
                            formatTime(elapsedTime),
                            'Preparing...',
                            (fakeProgress / 100) * fileSize,
                            fileSize,
                            'Calculating...'
                        );
                    }
                }, 200);
                
                // Create download link with direct URL
                const a = document.createElement('a');
                a.href = publicUrl;
                a.download = fileName;
                a.style.display = 'none';
                a.rel = 'noopener';
                document.body.appendChild(a);
                
                // Trigger download
                a.click();
                
                // Clean up
                setTimeout(() => {
                    a.remove();
                    clearInterval(progressInterval);
                    
                    // Go directly to completion screen
                    const downloadTime = Date.now() - startTime;
                    
                    // Show final speed for small files
                    const estimatedSpeed = (fileSize / 1024 / 1024) / (downloadTime / 1000) * 8; // Rough estimate in Mbps
                    document.getElementById('downloadSpeed').textContent = `${estimatedSpeed.toFixed(2)} Mbps (est)`;
                    
                    // Go directly to completion screen without delay
                        hideDownloadProgress(downloadTime, fileSize);
                        console.log(`Direct URL download initiated: ${formatFileSize(fileSize)}`);
                }, 2000);
                
            } catch (error) {
                console.error('Direct URL download error:', error);
                hideDownloadProgressOnError();
                clearInterval(downloadTimerInterval);
                alert(`Download failed: ${error.message}`);
            }
        }

        // üìä Log download to backend
        async function logDownload(fileName, fileSize, method, speed) {
            try {
                const connectionQuality = typeof detectConnectionQuality === 'function' ? await detectConnectionQuality() : 'unknown';
                await fetch('/api/log-download', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fileName,
                        fileSize,
                        method,
                        contentType: 'application/octet-stream',
                        connectionQuality,
                        speed,
                        userAgent: navigator.userAgent
                    })
                });
            } catch (error) {
                console.warn('Failed to log download:', error.message);
            }
        }

        // On page load, set timers to last value or 00:00:00
        window.onload = function() {
            if (lastUploadTime > 0 && lastUploadSize > 0) {
                const mb = lastUploadSize / 1024 / 1024;
                const sec = lastUploadTime / 1000;
                const speedMBs = mb / sec; // MB/s
                const speedMbps = speedMBs * 8; // Convert to Mbps
                document.getElementById('uploadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps`;
            } else {
                document.getElementById('uploadSpeed').textContent = '0.00 Mbps';
            }
            if (lastDownloadTime > 0 && lastDownloadSize > 0) {
                const mb = lastDownloadSize / 1024 / 1024;
                const sec = lastDownloadTime / 1000;
                const speedMBs = mb / sec; // MB/s
                const speedMbps = speedMBs * 8; // Convert to Mbps
                document.getElementById('downloadSpeed').textContent = `${speedMbps.toFixed(2)} Mbps`;
            } else {
                document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
            }
        };

        // Initial file list load
        refreshFileList();

        // Simple static password protection
        (function() {
            var password = 'wnet';
            var entered = sessionStorage.getItem('wnet_auth');
            if (entered !== password) {
                while (true) {
                    var input = prompt('Enter password to access this page:');
                    if (input === null) {
                        document.body.innerHTML = '<h2>Access denied.</h2>';
                        throw new Error('Access denied');
                    }
                    if (input === password) {
                        sessionStorage.setItem('wnet_auth', password);
                        break;
                    }
                }
            }
        })();

        // UI Management Functions - keeping the beautiful UI
        function generatePackageId() {
            const now = new Date();
            const timestamp = now.getFullYear().toString() + 
                             (now.getMonth() + 1).toString().padStart(2, '0') + 
                             now.getDate().toString().padStart(2, '0') + 
                             now.getHours().toString().padStart(2, '0') + 
                             now.getMinutes().toString().padStart(2, '0') + 
                             now.getSeconds().toString().padStart(2, '0');
            return `WNET-R2-${timestamp}`;
        }

        function showProgressSection(fileName) {
            isUploadActive = true;
            isUploadCompleted = false;
            isUploadCancelled = false; // Reset cancellation flag for new upload
            activeXhrRequests = []; // Clear any previous requests
            performanceTracker.disabled = false; // Re-enable performance tracking for new upload
            console.log('Upload started - setting isUploadActive to true');
            document.getElementById('uploadSection').classList.add('hidden');
            document.getElementById('progressSection').classList.remove('hidden');
        }

        function hideProgressSection() {
            document.getElementById('uploadSection').classList.remove('hidden');
            document.getElementById('progressSection').classList.add('hidden');
        }

        function updateCircularProgress(percentage, elapsedTime, speed, uploaded, total, eta = null) {
            const progressCircle = document.getElementById('progressCircle');
            // Use percentage directly (0-100)
            progressCircle.style.setProperty('--progress', percentage);
            
            document.getElementById('progressPercentage').textContent = `${percentage}% completed`;
            document.getElementById('timeRemaining').textContent = elapsedTime; // Show elapsed time
            document.getElementById('uploadSpeed').textContent = speed;
            
            // Update time remaining ETA if provided
            if (eta) {
                document.getElementById('timeRemainingETA').textContent = eta;
            }
            
            const uploadedGB = (uploaded / (1024 * 1024 * 1024)).toFixed(2);
            const totalGB = (total / (1024 * 1024 * 1024)).toFixed(2);
            document.getElementById('uploadProgress').textContent = `${uploadedGB} GB / ${totalGB} GB`;
        }

        function showDownloadProgress(fileName) {
            // Set download active state and track current file
            isDownloadActive = true;
            isDownloadCompleted = false;
            currentDownloadFileName = fileName;
            console.log('Download started - setting isDownloadActive to true');
            
            // RESET PROGRESS BAR: Clear any previous green completion styling
            const progressCircle = document.getElementById('downloadProgressCircle');
            progressCircle.style.setProperty('--progress', 0);
            progressCircle.style.background = ''; // Reset to default blue gradient
            
            // Reset text content to default blue styling
            document.getElementById('downloadProgressPercentage').textContent = '0% completed';
            document.getElementById('downloadProgressPercentage').style.color = '#4A90E2'; // Blue text
            document.getElementById('downloadTimeRemaining').textContent = '00:00:00';
            document.getElementById('downloadTimeRemainingETA').textContent = 'Calculating...';
            document.getElementById('downloadSpeed').textContent = '0.00 Mbps';
            
            // Hide completion screen if it's currently showing
            document.getElementById('downloadCompletionScreen').classList.add('hidden');
            // Show download section and progress
            document.getElementById('downloadSection').classList.remove('hidden');
            document.getElementById('downloadProgressSection').classList.remove('hidden');
            
            // Disable all download buttons and mark the active one
            disableAllDownloadButtons();
            markActiveDownloadButton(fileName);
        }

        // Function to mark the active download button
        function markActiveDownloadButton(fileName) {
            const downloadButtons = document.querySelectorAll('.download-btn');
            downloadButtons.forEach(button => {
                // Find the button for this specific file
                const fileItem = button.closest('.file-item');
                if (fileItem) {
                    const fileNameElement = fileItem.querySelector('.file-name');
                    if (fileNameElement && fileNameElement.textContent === fileName) {
                        button.textContent = 'Downloading...';
                        button.style.background = '#e0f2fe';
                        button.style.borderColor = '#0ea5e9';
                        button.style.color = '#0ea5e9';
                    }
                }
            });
        }

        function hideDownloadProgress(downloadTime = null, downloadSize = null) {
            // Reset download active state and clear current file
            isDownloadActive = false;
            currentDownloadFileName = null;
            console.log('Download completed - setting isDownloadActive to false');
            
            // Debug: Log the parameters being passed
            console.log('hideDownloadProgress called with:', {
                downloadTime,
                downloadSize,
                downloadTimeInSeconds: downloadTime ? downloadTime / 1000 : null,
                downloadSizeInMB: downloadSize ? downloadSize / 1024 / 1024 : null
            });
            
            // Update global variables if provided
            if (downloadTime !== null) {
                lastDownloadTime = downloadTime;
                console.log('Updated lastDownloadTime to:', lastDownloadTime);
            }
            if (downloadSize !== null) {
                lastDownloadSize = downloadSize;
                console.log('Updated lastDownloadSize to:', lastDownloadSize);
            }
            
            document.getElementById('downloadProgressSection').classList.add('hidden');
            // Show completion state instead of just hiding
            showDownloadCompletion();
        }

        function showDownloadCompletion() {
            // Set download completion state
            isDownloadCompleted = true;
            
            // Hide download section and show download completion screen
            document.getElementById('downloadSection').classList.add('hidden');
            document.getElementById('downloadCompletionScreen').classList.remove('hidden');
            
            // Debug: Log the values being used
            console.log('showDownloadCompletion called with:', {
                lastDownloadTime,
                lastDownloadSize,
                timeInSeconds: lastDownloadTime / 1000,
                sizeInMB: lastDownloadSize / 1024 / 1024
            });
            
            // Update completion stats
            if (lastDownloadTime > 0 && lastDownloadSize > 0) {
                // Format time as HH:MM:SS
                const totalSeconds = Math.floor(lastDownloadTime / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('downloadCompletionTimeFullScreen').textContent = `Total time ${timeString}`;                
                // Calculate speed in Mbps
                const mb = lastDownloadSize / 1024 / 1024;
                const sec = lastDownloadTime / 1000;
                const speedMBs = mb / sec;
                const speedMbps = speedMBs * 8;
                
                console.log('Speed calculation:', {
                    mb: mb.toFixed(2),
                    sec: sec.toFixed(2),
                    speedMBs: speedMBs.toFixed(2),
                    speedMbps: speedMbps.toFixed(2)
                });
                
                document.getElementById('downloadCompletionSpeedFullScreen').textContent = `${speedMbps.toFixed(2)} Mbps`;                
                // Format size in GB
                const sizeGB = (lastDownloadSize / (1024 * 1024 * 1024)).toFixed(2);
                document.getElementById('downloadCompletionDownloaded').textContent = `${sizeGB} GB`;
            } else {
                console.log('Download completion data missing:', {
                    lastDownloadTime,
                    lastDownloadSize
                });
            }
            
            // Populate file list in completion screen
            populateCompletionFileList();
            
            // Re-enable all download buttons
            enableAllDownloadButtons();
        }

        // Function to populate file list in completion screen
        async function populateCompletionFileList() {
            try {
                const response = await fetch('/api/files');
                const files = await response.json();
                
                const fileList = document.getElementById('completionFileList');
                fileList.innerHTML = '';

                if (files.length === 0) {
                    fileList.innerHTML = '<div style="text-align: center; color: #888; padding: 40px;">No files found.</div>';
                    return;
                }

                files.forEach(file => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.innerHTML = `
                        <div class="file-info">
                            <div class="file-name">${file.name}</div>
                            <div class="file-size">${formatFileSize(file.size)}</div>
                        </div>
                        <button class="download-btn" onclick="downloadFile('${file.name}')">Download</button>
                    `;
                    fileList.appendChild(fileItem);
                });
            } catch (error) {
                console.error('Error:', error);
                const fileList = document.getElementById('completionFileList');
                fileList.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">Error loading files.</div>';
            }
        }

        function updateDownloadCircularProgress(percentage, elapsedTime, speed, downloaded, total, eta = null) {
            // Update circular progress for downloads
            const progressCircle = document.getElementById('downloadProgressCircle');
            const roundedPercentage = Math.round(percentage);
            progressCircle.style.setProperty('--progress', roundedPercentage);
            
            // Update text content
            document.getElementById('downloadProgressPercentage').textContent = `${roundedPercentage}% completed`;
            document.getElementById('downloadTimeRemaining').textContent = elapsedTime; // Show elapsed time
            document.getElementById('downloadSpeed').textContent = speed;
            
            // Update time remaining ETA if provided
            if (eta) {
                document.getElementById('downloadTimeRemainingETA').textContent = eta;
            }
            
            // Update stats
            const downloadedGB = (downloaded / (1024 * 1024 * 1024)).toFixed(2);
            const totalGB = (total / (1024 * 1024 * 1024)).toFixed(2);
            document.getElementById('downloadProgressText').textContent = `${downloadedGB} GB / ${totalGB} GB`;
        }
        
        // üöÄ EARLY CONNECTION ESTABLISHMENT: Trigger on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ Triggering early connection establishment...');
            
            // Fire early connection requests to warm up the pipeline
            const earlyWarmupPromises = [];
            
            // Ping endpoints immediately
            earlyWarmupPromises.push(
                fetch('/api/ping', { method: 'HEAD', keepalive: true }).catch(() => {})
            );
            
            // Warm up upload endpoints
            earlyWarmupPromises.push(
                fetch('/api/multipart/start', { method: 'OPTIONS', keepalive: true }).catch(() => {})
            );
            
            // Additional connection triggers (use data URLs to avoid 404s)
            const img1 = new Image();
            img1.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            const img2 = new Image();
            img2.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';
            
            Promise.allSettled(earlyWarmupPromises).then(() => {
                console.log('üî• Early connection establishment complete');
            });
        });
    </script>
</body>
</html> 