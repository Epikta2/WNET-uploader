<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WNET R2 Upload/Download Test - VPS Accelerated</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .section {
            border: 1px solid #ccc;
            padding: 20px;
            border-radius: 5px;
        }
        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        #fileList {
            margin-top: 10px;
        }
        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #eee;
        }
        .vps-status {
            background: #e8f5e8;
            border: 1px solid #4caf50;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        .vps-indicator {
            color: #4caf50;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>WNET R2 Upload/Download Test - VPS Accelerated 🚀</h1>
    
    <div class="container">
        <div class="section">
            <h2>Upload to R2 via VPS</h2>
            
            <div class="vps-status">
                <div class="vps-indicator">🚀 VPS PROXY MODE ENABLED</div>
                <div style="font-size: 12px; color: #555; margin-top: 5px;">
                    Files upload: Browser → VPS → R2 (optimized protocol)
                </div>
                <div id="vpsConnectionStatus" style="font-size: 12px; margin-top: 5px;">
                    Checking VPS connection...
                </div>
            </div>
            
            <input type="file" id="fileInput" accept=".mp4,.mov,.avi,.mkv,.webm,.wmv,.mxf,video/*">
            <button onclick="uploadFile()">Upload via VPS</button>
            <div style="margin-top:5px; color:#555;">
                <span>Upload Timer: </span><span id="uploadTimer">00:00:00</span>
            </div>
            <div style="margin-top:2px; color:#555;">
                <span>Upload Speed: </span><span id="uploadSpeed">0.00 MB/s</span>
            </div>
            <div id="uploadProgressContainer" style="display:none; margin-top:10px;">
                <progress id="uploadProgress" value="0" max="100" style="width:100%"></progress>
                <span id="uploadProgressText"></span>
            </div>
            <div id="uploadFileSize" style="margin-top:2px; color:#555;"></div>
            <div id="uploadETA" style="margin-top:5px; color:#555;"></div>
            <div id="uploadLog" style="margin-top:15px; padding:10px; background:#f8f9fa; border-radius:5px; font-family:monospace; font-size:12px; display:none; max-height:200px; overflow-y:auto;">
                <div style="font-weight:bold; margin-bottom:5px; color:#333;">📊 VPS Upload Log:</div>
                <div id="logContent"></div>
            </div>
        </div>

        <div class="section">
            <h2>Download from R2</h2>
            <button onclick="refreshFileList()">Refresh File List</button>
            <div style="margin-top:5px; color:#555;">
                <span>Download Timer: </span><span id="downloadTimer">00:00:00</span>
            </div>
            <div style="margin-top:2px; color:#555;">
                <span>Download Speed: </span><span id="downloadSpeed">0.00 MB/s</span>
            </div>
            <div id="downloadProgressContainer" style="display:none; margin-top:10px;">
                <progress id="downloadProgress" value="0" max="100" style="width:100%"></progress>
                <span id="downloadProgressText"></span>
            </div>
            <div id="fileList"></div>
        </div>
    </div>

    <script>
        // VPS Configuration
        const VPS_ENDPOINT = 'http://178.156.167.243:3000'; // Your Hetzner VPS IP
        
        // Set your R2 Public Development URL base here for downloads
        const R2_PUBLIC_URL_BASE = 'https://pub-2078a13599a74a339318b659bb618965.r2.dev';

        let uploadTimerInterval = null;
        let downloadTimerInterval = null;
        let lastUploadTime = 0;
        let lastDownloadTime = 0;
        let lastUploadSize = 0;
        let lastDownloadSize = 0;
        let uploadStartTime = 0;

        // Check VPS connection status
        async function checkVPSConnection() {
            const statusElement = document.getElementById('vpsConnectionStatus');
            try {
                const response = await fetch(`${VPS_ENDPOINT}/health`, {
                    method: 'GET',
                    mode: 'cors'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    statusElement.innerHTML = `✅ VPS Connected: ${data.message}`;
                    statusElement.style.color = '#4caf50';
                    return true;
                } else {
                    throw new Error(`VPS responded with status ${response.status}`);
                }
            } catch (error) {
                console.error('VPS connection failed:', error);
                statusElement.innerHTML = `❌ VPS Connection Failed: ${error.message}`;
                statusElement.style.color = '#f44336';
                return false;
            }
        }

        // Log function for VPS upload progress
        function logMessage(message, type = 'info') {
            const logContainer = document.getElementById('uploadLog');
            const logContent = document.getElementById('logContent');
            
            if (logContainer.style.display === 'none') {
                logContainer.style.display = 'block';
            }
            
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.style.marginBottom = '3px';
            logEntry.style.color = type === 'error' ? '#f44336' : type === 'success' ? '#4caf50' : '#333';
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            logContent.appendChild(logEntry);
            logContent.scrollTop = logContent.scrollHeight;
        }

        // Format time helper
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // Format file size helper
        function formatFileSize(bytes) {
            if (bytes >= 1024 * 1024 * 1024) {
                return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
            } else if (bytes >= 1024 * 1024) {
                return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
            } else if (bytes >= 1024) {
                return (bytes / 1024).toFixed(2) + ' KB';
            }
            return bytes + ' bytes';
        }

        // Validate video file
        function isValidVideoFile(file) {
            const validExtensions = ['.mp4', '.mov', '.avi', '.mkv', '.webm', '.wmv', '.mxf'];
            const fileName = file.name.toLowerCase();
            const isValidExtension = validExtensions.some(ext => fileName.endsWith(ext));
            
            if (!isValidExtension) {
                alert('Please select a valid video file (.mp4, .mov, .avi, .mkv, .webm, .wmv, .mxf)');
                return false;
            }
            
            // Check file size (10GB limit)
            if (file.size > 10 * 1024 * 1024 * 1024) {
                alert('File size must be less than 10GB');
                return false;
            }
            
            return true;
        }

        // Main upload function - now uploads to VPS
        async function uploadFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            const progressContainer = document.getElementById('uploadProgressContainer');
            const progressBar = document.getElementById('uploadProgress');
            const progressText = document.getElementById('uploadProgressText');
            const timerDisplay = document.getElementById('uploadTimer');
            const speedDisplay = document.getElementById('uploadSpeed');
            const fileSizeDisplay = document.getElementById('uploadFileSize');
            const etaDisplay = document.getElementById('uploadETA');

            if (!file) {
                alert('Please select a file first');
                return;
            }

            if (!isValidVideoFile(file)) {
                return;
            }

            // Check VPS connection before upload
            logMessage('Checking VPS connection...');
            const vpsConnected = await checkVPSConnection();
            if (!vpsConnected) {
                alert('VPS is not available. Please try again later.');
                return;
            }

            // Reset displays
            progressContainer.style.display = 'block';
            progressBar.value = 0;
            progressText.textContent = `0% (0 / ${formatFileSize(file.size)})`;
            timerDisplay.textContent = '00:00:00';
            speedDisplay.textContent = '0.00 MB/s';
            etaDisplay.textContent = 'Connecting to VPS...';
            fileSizeDisplay.textContent = `File Size: ${formatFileSize(file.size)}`;

            logMessage(`🚀 Starting VPS upload: ${file.name} (${formatFileSize(file.size)})`);

            // Start timer
            uploadStartTime = Date.now();
            if (uploadTimerInterval) clearInterval(uploadTimerInterval);
            uploadTimerInterval = setInterval(() => {
                timerDisplay.textContent = formatTime(Date.now() - uploadStartTime);
            }, 100);

            try {
                // Create FormData for multipart upload to VPS
                const formData = new FormData();
                formData.append('file', file);

                // Create EventSource for SSE progress updates
                const uploadUrl = `${VPS_ENDPOINT}/upload`;
                
                logMessage('📡 Connecting to VPS upload endpoint...');

                // Start the upload via XHR for file transfer + EventSource for progress
                const xhr = new XMLHttpRequest();
                xhr.open('POST', uploadUrl, true);

                // Handle upload progress (local to VPS)
                xhr.upload.onprogress = function(event) {
                    if (event.lengthComputable) {
                        const percent = Math.round((event.loaded / event.total) * 100);
                        logMessage(`📤 Browser→VPS: ${percent}% (${formatFileSize(event.loaded)})`);
                    }
                };

                // Handle response which will be SSE stream
                xhr.onreadystatechange = function() {
                    if (xhr.readyState === XMLHttpRequest.LOADING || xhr.readyState === XMLHttpRequest.DONE) {
                        // Parse SSE data from response
                        const responseText = xhr.responseText;
                        const lines = responseText.split('\n');
                        
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.substring(6));
                                    handleVPSProgress(data);
                                } catch (e) {
                                    // Ignore JSON parse errors
                                }
                            }
                        }
                    }
                };

                xhr.onerror = function() {
                    throw new Error('Network error during VPS upload');
                };

                xhr.send(formData);

            } catch (error) {
                console.error('Upload error:', error);
                logMessage(`❌ Upload failed: ${error.message}`, 'error');
                
                progressContainer.style.display = 'none';
                clearInterval(uploadTimerInterval);
                lastUploadTime = Date.now() - uploadStartTime;
                timerDisplay.textContent = formatTime(lastUploadTime);
                
                alert('Upload failed: ' + error.message);
            }
        }

        // Handle progress updates from VPS
        function handleVPSProgress(data) {
            const progressBar = document.getElementById('uploadProgress');
            const progressText = document.getElementById('uploadProgressText');
            const speedDisplay = document.getElementById('uploadSpeed');
            const etaDisplay = document.getElementById('uploadETA');
            const timerDisplay = document.getElementById('uploadTimer');

            console.log('VPS Progress:', data);

            switch(data.type) {
                case 'started':
                    logMessage(`🚀 ${data.message}`, 'success');
                    progressText.textContent = 'VPS processing file...';
                    break;

                case 'multipart_started':
                    logMessage(`📦 ${data.message}`);
                    break;

                case 'strategy':
                    logMessage(`📊 ${data.message}`);
                    break;

                case 'part_completed':
                    // Update progress based on VPS feedback
                    progressBar.value = data.progress;
                    progressText.textContent = `${data.progress.toFixed(1)}% (${data.completedParts}/${data.totalParts} parts)`;
                    speedDisplay.textContent = `${data.avgSpeed} MB/s`;
                    
                    if (data.completedParts % 10 === 0) {
                        logMessage(`✅ Progress: ${data.completedParts}/${data.totalParts} parts, ${data.avgSpeed} MB/s avg`);
                    }
                    break;

                case 'progress':
                    progressBar.value = data.progress;
                    progressText.textContent = `${data.progress}% - ${data.message}`;
                    break;

                case 'multipart_completed':
                    logMessage(`🏁 ${data.message}`, 'success');
                    speedDisplay.textContent = `${data.finalSpeed} MB/s`;
                    break;

                case 'completed':
                    logMessage(`✅ ${data.message}`, 'success');
                    
                    // Finalize upload
                    progressContainer.style.display = 'none';
                    clearInterval(uploadTimerInterval);
                    lastUploadTime = Date.now() - uploadStartTime;
                    timerDisplay.textContent = formatTime(lastUploadTime);
                    
                    // Calculate final average speed
                    const fileInput = document.getElementById('fileInput');
                    const file = fileInput.files[0];
                    if (file && lastUploadTime > 0) {
                        const mb = file.size / 1024 / 1024;
                        const sec = lastUploadTime / 1000;
                        speedDisplay.textContent = `${(mb / sec).toFixed(2)} MB/s`;
                        lastUploadSize = file.size;
                    }
                    
                    alert('File uploaded successfully via VPS!');
                    refreshFileList();
                    break;

                case 'error':
                    logMessage(`❌ ${data.message}`, 'error');
                    
                    progressContainer.style.display = 'none';
                    clearInterval(uploadTimerInterval);
                    lastUploadTime = Date.now() - uploadStartTime;
                    timerDisplay.textContent = formatTime(lastUploadTime);
                    
                    alert('Upload failed: ' + data.message);
                    break;
            }
        }

        // Download functionality (unchanged - still direct from R2)
        async function downloadFile(fileName) {
            const progressContainer = document.getElementById('downloadProgressContainer');
            const progressBar = document.getElementById('downloadProgress');
            const progressText = document.getElementById('downloadProgressText');
            const timerDisplay = document.getElementById('downloadTimer');
            const speedDisplay = document.getElementById('downloadSpeed');

            progressContainer.style.display = 'block';
            progressBar.value = 0;
            progressText.textContent = '0%';
            timerDisplay.textContent = '00:00:00';
            speedDisplay.textContent = '0.00 MB/s';

            let startTime = Date.now();
            if (downloadTimerInterval) clearInterval(downloadTimerInterval);
            downloadTimerInterval = setInterval(() => {
                timerDisplay.textContent = formatTime(Date.now() - startTime);
            }, 100);

            try {
                const url = `${R2_PUBLIC_URL_BASE}/${fileName}`;
                const response = await fetch(url);
                if (!response.ok) throw new Error('Download failed');

                const contentLength = +response.headers.get('Content-Length');
                const reader = response.body.getReader();
                let receivedLength = 0;
                let chunks = [];
                let lastTime = Date.now();
                let lastLoaded = 0;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    chunks.push(value);
                    receivedLength += value.length;

                    const percent = Math.round((receivedLength / contentLength) * 100);
                    progressBar.value = percent;
                    progressText.textContent = `${percent}% (${formatFileSize(receivedLength)})`;

                    const now = Date.now();
                    const bytesSinceLast = receivedLength - lastLoaded;
                    const timeSinceLast = (now - lastTime) / 1000;
                    if (timeSinceLast > 0 && bytesSinceLast > 0) {
                        const speed = (bytesSinceLast / 1024 / 1024) / timeSinceLast;
                        speedDisplay.textContent = speed.toFixed(2) + ' MB/s';
                    }
                    lastLoaded = receivedLength;
                    lastTime = now;
                }

                const blob = new Blob(chunks);
                const downloadUrl = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(downloadUrl);

                progressContainer.style.display = 'none';
                clearInterval(downloadTimerInterval);
                lastDownloadTime = Date.now() - startTime;
                lastDownloadSize = receivedLength;
                timerDisplay.textContent = formatTime(lastDownloadTime);
                if (lastDownloadTime > 0 && lastDownloadSize > 0) {
                    const mb = lastDownloadSize / 1024 / 1024;
                    const sec = lastDownloadTime / 1000;
                    speedDisplay.textContent = (mb / sec).toFixed(2) + ' MB/s';
                }

            } catch (error) {
                console.error('Download error:', error);
                progressContainer.style.display = 'none';
                clearInterval(downloadTimerInterval);
                alert('Download failed: ' + error.message);
            }
        }

        // File list functionality (unchanged)
        async function refreshFileList() {
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = 'Loading...';

            try {
                const response = await fetch('/api/list-files');
                if (!response.ok) throw new Error('Failed to fetch file list');
                
                const files = await response.json();
                
                if (files.length === 0) {
                    fileList.innerHTML = '<p>No files found.</p>';
                    return;
                }

                fileList.innerHTML = '';
                files.forEach(file => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.innerHTML = `
                        <div>
                            <strong>${file.name}</strong><br>
                            <small>${formatFileSize(file.size)} | ${new Date(file.lastModified).toLocaleString()}</small>
                        </div>
                        <button onclick="downloadFile('${file.name}')">Download</button>
                    `;
                    fileList.appendChild(fileItem);
                });
            } catch (error) {
                console.error('Error loading file list:', error);
                fileList.innerHTML = '<p>Error loading files.</p>';
            }
        }

        // Initialize page
        window.onload = function() {
            // Restore previous timing if available
            document.getElementById('uploadTimer').textContent = lastUploadTime ? formatTime(lastUploadTime) : '00:00:00';
            document.getElementById('downloadTimer').textContent = lastDownloadTime ? formatTime(lastDownloadTime) : '00:00:00';
            
            if (lastUploadTime > 0 && lastUploadSize > 0) {
                const mb = lastUploadSize / 1024 / 1024;
                const sec = lastUploadTime / 1000;
                document.getElementById('uploadSpeed').textContent = `${(mb / sec).toFixed(2)} MB/s`;
            } else {
                document.getElementById('uploadSpeed').textContent = '0.00 MB/s';
            }
            
            if (lastDownloadTime > 0 && lastDownloadSize > 0) {
                const mb = lastDownloadSize / 1024 / 1024;
                const sec = lastDownloadTime / 1000;
                document.getElementById('downloadSpeed').textContent = `${(mb / sec).toFixed(2)} MB/s`;
            } else {
                document.getElementById('downloadSpeed').textContent = '0.00 MB/s';
            }

            // Check VPS connection on load
            checkVPSConnection();
            
            // Load file list
            refreshFileList();
        };

        // Simple static password protection
        (function() {
            var password = 'wnet';
            var entered = sessionStorage.getItem('wnet_auth');
            if (entered !== password) {
                while (true) {
                    var input = prompt('Enter password to access this page:');
                    if (input === null) {
                        document.body.innerHTML = '<h2>Access denied.</h2>';
                        throw new Error('Access denied');
                    }
                    if (input === password) {
                        sessionStorage.setItem('wnet_auth', password);
                        break;
                    }
                }
            }
        })();
    </script>
</body>
</html> 